Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     51.9 MiB     51.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     52.9 MiB      0.0 MiB         129       for row in grid:
    32     52.9 MiB      0.0 MiB       16512           for spot in row:
    33     52.9 MiB      0.9 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     52.9 MiB      0.0 MiB           1       count = 0
    36     52.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     52.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     52.9 MiB      0.0 MiB           1       came_from = {}
    39     54.5 MiB      1.6 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     54.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     55.9 MiB      1.4 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     55.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     55.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     55.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     55.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     55.9 MiB      0.0 MiB         910       while not open_set.empty():
    49     55.9 MiB      0.0 MiB         910           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     55.9 MiB      0.0 MiB         910           current = open_set.get()[2]
    55     55.9 MiB      0.0 MiB         910           open_set_hash.remove(current)
    56                                         
    57     55.9 MiB      0.0 MiB         910           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     55.9 MiB      0.0 MiB         910           if current == end:
    62     55.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     55.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     55.9 MiB      0.0 MiB        8181           for neighbor in current.neighbors:
    67     55.9 MiB      0.0 MiB        7272               if current.row != neighbor.row and current.col != neighbor.col:
    68     55.9 MiB      0.0 MiB        3636                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     55.9 MiB      0.0 MiB        3636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     55.9 MiB      0.0 MiB        7272               if temp_g_score < g_score[neighbor]:
    73     55.9 MiB      0.0 MiB        1196                   came_from[neighbor] = current
    74     55.9 MiB      0.0 MiB        1196                   g_score[neighbor] = temp_g_score
    75     55.9 MiB      0.0 MiB        1196                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     55.9 MiB      0.0 MiB        1196                   if neighbor not in open_set_hash:
    77     55.9 MiB      0.0 MiB        1196                       count += 1
    78     55.9 MiB      0.0 MiB        1196                       open_set.put((f_score[neighbor], count, neighbor))
    79     55.9 MiB      0.0 MiB        1196                       open_set_hash.add(neighbor)
    80                                                             
    81     55.9 MiB      0.0 MiB         909           if draw is not None:
    82                                                     draw()
    83                                         
    84     55.9 MiB      0.0 MiB         909           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     59.8 MiB     59.8 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     60.8 MiB      0.0 MiB         129       for row in grid:
    32     60.8 MiB      0.0 MiB       16512           for spot in row:
    33     60.8 MiB      1.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     60.8 MiB      0.0 MiB           1       count = 0
    36     60.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     60.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     60.8 MiB      0.0 MiB           1       came_from = {}
    39     61.9 MiB      1.1 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     61.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     63.0 MiB      1.1 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     63.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     63.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     63.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46     63.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     63.0 MiB      0.0 MiB         120       while not open_set.empty():
    49     63.0 MiB      0.0 MiB         120           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     63.0 MiB      0.0 MiB         120           current = open_set.get()[2]
    55     63.0 MiB      0.0 MiB         120           open_set_hash.remove(current)
    56                                         
    57     63.0 MiB      0.0 MiB         120           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     63.0 MiB      0.0 MiB         120           if current == end:
    62     63.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     63.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     63.0 MiB      0.0 MiB        1071           for neighbor in current.neighbors:
    67     63.0 MiB      0.0 MiB         952               if current.row != neighbor.row and current.col != neighbor.col:
    68     63.0 MiB      0.0 MiB         476                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     63.0 MiB      0.0 MiB         476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     63.0 MiB      0.0 MiB         952               if temp_g_score < g_score[neighbor]:
    73     63.0 MiB      0.0 MiB         186                   came_from[neighbor] = current
    74     63.0 MiB      0.0 MiB         186                   g_score[neighbor] = temp_g_score
    75     63.0 MiB      0.0 MiB         186                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     63.0 MiB      0.0 MiB         186                   if neighbor not in open_set_hash:
    77     63.0 MiB      0.0 MiB         186                       count += 1
    78     63.0 MiB      0.0 MiB         186                       open_set.put((f_score[neighbor], count, neighbor))
    79     63.0 MiB      0.0 MiB         186                       open_set_hash.add(neighbor)
    80                                                             
    81     63.0 MiB      0.0 MiB         119           if draw is not None:
    82                                                     draw()
    83                                         
    84     63.0 MiB      0.0 MiB         119           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     64.2 MiB     64.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     64.2 MiB      0.0 MiB         129       for row in grid:
    32     64.2 MiB      0.0 MiB       16512           for spot in row:
    33     64.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     64.2 MiB      0.0 MiB           1       count = 0
    36     64.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     64.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     64.2 MiB      0.0 MiB           1       came_from = {}
    39     65.0 MiB      0.9 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     65.0 MiB      0.0 MiB           1       g_score[start] = 0
    41     65.6 MiB      0.6 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     65.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     65.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     65.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     65.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     65.7 MiB      0.0 MiB         280       while not open_set.empty():
    49     65.7 MiB      0.0 MiB         280           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     65.7 MiB      0.0 MiB         280           current = open_set.get()[2]
    55     65.7 MiB      0.0 MiB         280           open_set_hash.remove(current)
    56                                         
    57     65.7 MiB      0.0 MiB         280           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     65.7 MiB      0.0 MiB         280           if current == end:
    62     65.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     65.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     65.7 MiB      0.0 MiB        2511           for neighbor in current.neighbors:
    67     65.7 MiB      0.0 MiB        2232               if current.row != neighbor.row and current.col != neighbor.col:
    68     65.7 MiB      0.0 MiB        1116                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     65.7 MiB      0.0 MiB        1116                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     65.7 MiB      0.0 MiB        2232               if temp_g_score < g_score[neighbor]:
    73     65.7 MiB      0.0 MiB         410                   came_from[neighbor] = current
    74     65.7 MiB      0.0 MiB         410                   g_score[neighbor] = temp_g_score
    75     65.7 MiB      0.0 MiB         410                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     65.7 MiB      0.0 MiB         410                   if neighbor not in open_set_hash:
    77     65.7 MiB      0.0 MiB         410                       count += 1
    78     65.7 MiB      0.0 MiB         410                       open_set.put((f_score[neighbor], count, neighbor))
    79     65.7 MiB      0.0 MiB         410                       open_set_hash.add(neighbor)
    80                                                             
    81     65.7 MiB      0.0 MiB         279           if draw is not None:
    82                                                     draw()
    83                                         
    84     65.7 MiB      0.0 MiB         279           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     68.5 MiB     68.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     69.5 MiB      0.0 MiB         129       for row in grid:
    32     69.5 MiB      0.0 MiB       16512           for spot in row:
    33     69.5 MiB      1.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     69.5 MiB      0.0 MiB           1       count = 0
    36     69.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     69.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     69.5 MiB      0.0 MiB           1       came_from = {}
    39     70.0 MiB      0.5 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.0 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.0 MiB      1.1 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.0 MiB      0.0 MiB         750       while not open_set.empty():
    49     71.0 MiB      0.0 MiB         750           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.0 MiB      0.0 MiB         750           current = open_set.get()[2]
    55     71.0 MiB      0.0 MiB         750           open_set_hash.remove(current)
    56                                         
    57     71.0 MiB      0.0 MiB         750           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.0 MiB      0.0 MiB         750           if current == end:
    62     71.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.0 MiB      0.0 MiB        6741           for neighbor in current.neighbors:
    67     71.0 MiB      0.0 MiB        5992               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.0 MiB      0.0 MiB        2996                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.0 MiB      0.0 MiB        2996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.0 MiB      0.0 MiB        5992               if temp_g_score < g_score[neighbor]:
    73     71.0 MiB      0.0 MiB         908                   came_from[neighbor] = current
    74     71.0 MiB      0.0 MiB         908                   g_score[neighbor] = temp_g_score
    75     71.0 MiB      0.0 MiB         908                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.0 MiB      0.0 MiB         908                   if neighbor not in open_set_hash:
    77     71.0 MiB      0.0 MiB         908                       count += 1
    78     71.0 MiB      0.0 MiB         908                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.0 MiB      0.0 MiB         908                       open_set_hash.add(neighbor)
    80                                                             
    81     71.0 MiB      0.0 MiB         749           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.0 MiB      0.0 MiB         749           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.3 MiB     70.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.3 MiB      0.0 MiB         129       for row in grid:
    32     70.3 MiB      0.0 MiB       16512           for spot in row:
    33     70.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.3 MiB      0.0 MiB           1       count = 0
    36     70.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.3 MiB      0.0 MiB           1       came_from = {}
    39     70.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.3 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.3 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.3 MiB      0.0 MiB         413       while not open_set.empty():
    49     70.3 MiB      0.0 MiB         413           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.3 MiB      0.0 MiB         413           current = open_set.get()[2]
    55     70.3 MiB      0.0 MiB         413           open_set_hash.remove(current)
    56                                         
    57     70.3 MiB      0.0 MiB         413           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.3 MiB      0.0 MiB         413           if current == end:
    62     70.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.3 MiB      0.0 MiB        3708           for neighbor in current.neighbors:
    67     70.3 MiB      0.0 MiB        3296               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.3 MiB      0.0 MiB        1648                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.3 MiB      0.0 MiB        1648                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.3 MiB      0.0 MiB        3296               if temp_g_score < g_score[neighbor]:
    73     70.3 MiB      0.0 MiB         557                   came_from[neighbor] = current
    74     70.3 MiB      0.0 MiB         557                   g_score[neighbor] = temp_g_score
    75     70.3 MiB      0.0 MiB         557                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.3 MiB      0.0 MiB         557                   if neighbor not in open_set_hash:
    77     70.3 MiB      0.0 MiB         557                       count += 1
    78     70.3 MiB      0.0 MiB         557                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.3 MiB      0.0 MiB         557                       open_set_hash.add(neighbor)
    80                                                             
    81     70.3 MiB      0.0 MiB         412           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.3 MiB      0.0 MiB         412           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.3 MiB     70.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.3 MiB      0.0 MiB         129       for row in grid:
    32     70.3 MiB      0.0 MiB       16512           for spot in row:
    33     70.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.3 MiB      0.0 MiB           1       count = 0
    36     70.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.3 MiB      0.0 MiB           1       came_from = {}
    39     70.6 MiB      0.3 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.1 MiB      0.5 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.1 MiB      0.0 MiB         960       while not open_set.empty():
    49     71.1 MiB      0.0 MiB         960           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.1 MiB      0.0 MiB         960           current = open_set.get()[2]
    55     71.1 MiB      0.0 MiB         960           open_set_hash.remove(current)
    56                                         
    57     71.1 MiB      0.0 MiB         960           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.1 MiB      0.0 MiB         960           if current == end:
    62     71.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.1 MiB      0.0 MiB        8631           for neighbor in current.neighbors:
    67     71.1 MiB      0.0 MiB        7672               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.1 MiB      0.0 MiB        3836                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.1 MiB      0.0 MiB        3836                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.1 MiB      0.0 MiB        7672               if temp_g_score < g_score[neighbor]:
    73     71.1 MiB      0.0 MiB        1190                   came_from[neighbor] = current
    74     71.1 MiB      0.0 MiB        1190                   g_score[neighbor] = temp_g_score
    75     71.1 MiB      0.0 MiB        1190                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.1 MiB      0.0 MiB        1190                   if neighbor not in open_set_hash:
    77     71.1 MiB      0.0 MiB        1190                       count += 1
    78     71.1 MiB      0.0 MiB        1190                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.1 MiB      0.0 MiB        1190                       open_set_hash.add(neighbor)
    80                                                             
    81     71.1 MiB      0.0 MiB         959           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.1 MiB      0.0 MiB         959           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.4 MiB     70.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.4 MiB   -170.8 MiB         129       for row in grid:
    32     70.4 MiB -21841.2 MiB       16512           for spot in row:
    33     70.4 MiB -21673.8 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     65.1 MiB     -5.3 MiB           1       count = 0
    36     65.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     65.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     65.1 MiB      0.0 MiB           1       came_from = {}
    39     65.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     65.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     65.4 MiB      0.3 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     65.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     65.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     65.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     65.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     65.4 MiB      0.0 MiB         119       while not open_set.empty():
    49     65.4 MiB      0.0 MiB         119           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     65.4 MiB      0.0 MiB         119           current = open_set.get()[2]
    55     65.4 MiB      0.0 MiB         119           open_set_hash.remove(current)
    56                                         
    57     65.4 MiB      0.0 MiB         119           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     65.4 MiB      0.0 MiB         119           if current == end:
    62     65.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     65.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     65.4 MiB      0.0 MiB        1062           for neighbor in current.neighbors:
    67     65.4 MiB      0.0 MiB         944               if current.row != neighbor.row and current.col != neighbor.col:
    68     65.4 MiB      0.0 MiB         472                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     65.4 MiB      0.0 MiB         472                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     65.4 MiB      0.0 MiB         944               if temp_g_score < g_score[neighbor]:
    73     65.4 MiB      0.0 MiB         199                   came_from[neighbor] = current
    74     65.4 MiB      0.0 MiB         199                   g_score[neighbor] = temp_g_score
    75     65.4 MiB      0.0 MiB         199                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     65.4 MiB      0.0 MiB         199                   if neighbor not in open_set_hash:
    77     65.4 MiB      0.0 MiB         199                       count += 1
    78     65.4 MiB      0.0 MiB         199                       open_set.put((f_score[neighbor], count, neighbor))
    79     65.4 MiB      0.0 MiB         199                       open_set_hash.add(neighbor)
    80                                                             
    81     65.4 MiB      0.0 MiB         118           if draw is not None:
    82                                                     draw()
    83                                         
    84     65.4 MiB      0.0 MiB         118           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     65.5 MiB     65.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     65.5 MiB      0.0 MiB         129       for row in grid:
    32     65.5 MiB      0.0 MiB       16512           for spot in row:
    33     65.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     65.5 MiB      0.0 MiB           1       count = 0
    36     65.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     65.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     65.5 MiB      0.0 MiB           1       came_from = {}
    39     65.9 MiB      0.4 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     65.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     67.0 MiB      1.1 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     67.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     67.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     67.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46     67.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     67.0 MiB      0.0 MiB         100       while not open_set.empty():
    49     67.0 MiB      0.0 MiB         100           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     67.0 MiB      0.0 MiB         100           current = open_set.get()[2]
    55     67.0 MiB      0.0 MiB         100           open_set_hash.remove(current)
    56                                         
    57     67.0 MiB      0.0 MiB         100           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     67.0 MiB      0.0 MiB         100           if current == end:
    62     67.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     67.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     67.0 MiB      0.0 MiB         891           for neighbor in current.neighbors:
    67     67.0 MiB      0.0 MiB         792               if current.row != neighbor.row and current.col != neighbor.col:
    68     67.0 MiB      0.0 MiB         396                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     67.0 MiB      0.0 MiB         396                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     67.0 MiB      0.0 MiB         792               if temp_g_score < g_score[neighbor]:
    73     67.0 MiB      0.0 MiB         158                   came_from[neighbor] = current
    74     67.0 MiB      0.0 MiB         158                   g_score[neighbor] = temp_g_score
    75     67.0 MiB      0.0 MiB         158                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     67.0 MiB      0.0 MiB         158                   if neighbor not in open_set_hash:
    77     67.0 MiB      0.0 MiB         158                       count += 1
    78     67.0 MiB      0.0 MiB         158                       open_set.put((f_score[neighbor], count, neighbor))
    79     67.0 MiB      0.0 MiB         158                       open_set_hash.add(neighbor)
    80                                                             
    81     67.0 MiB      0.0 MiB          99           if draw is not None:
    82                                                     draw()
    83                                         
    84     67.0 MiB      0.0 MiB          99           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     67.0 MiB     67.0 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     67.0 MiB      0.0 MiB         129       for row in grid:
    32     67.0 MiB      0.0 MiB       16512           for spot in row:
    33     67.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     67.0 MiB      0.0 MiB           1       count = 0
    36     67.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     67.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     67.0 MiB      0.0 MiB           1       came_from = {}
    39     67.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     67.0 MiB      0.0 MiB           1       g_score[start] = 0
    41     67.0 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     67.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     67.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     67.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46     67.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     67.0 MiB      0.0 MiB        1248       while not open_set.empty():
    49     67.0 MiB      0.0 MiB        1248           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     67.0 MiB      0.0 MiB        1248           current = open_set.get()[2]
    55     67.0 MiB      0.0 MiB        1248           open_set_hash.remove(current)
    56                                         
    57     67.0 MiB      0.0 MiB        1248           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     67.0 MiB      0.0 MiB        1248           if current == end:
    62     67.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     67.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     67.0 MiB      0.0 MiB       11223           for neighbor in current.neighbors:
    67     67.0 MiB      0.0 MiB        9976               if current.row != neighbor.row and current.col != neighbor.col:
    68     67.0 MiB      0.0 MiB        4988                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     67.0 MiB      0.0 MiB        4988                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     67.0 MiB      0.0 MiB        9976               if temp_g_score < g_score[neighbor]:
    73     67.0 MiB      0.0 MiB        1466                   came_from[neighbor] = current
    74     67.0 MiB      0.0 MiB        1466                   g_score[neighbor] = temp_g_score
    75     67.0 MiB      0.0 MiB        1466                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     67.0 MiB      0.0 MiB        1466                   if neighbor not in open_set_hash:
    77     67.0 MiB      0.0 MiB        1466                       count += 1
    78     67.0 MiB      0.0 MiB        1466                       open_set.put((f_score[neighbor], count, neighbor))
    79     67.0 MiB      0.0 MiB        1466                       open_set_hash.add(neighbor)
    80                                                             
    81     67.0 MiB      0.0 MiB        1247           if draw is not None:
    82                                                     draw()
    83                                         
    84     67.0 MiB      0.0 MiB        1247           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     67.2 MiB     67.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     67.2 MiB      0.0 MiB         129       for row in grid:
    32     67.2 MiB      0.0 MiB       16512           for spot in row:
    33     67.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     67.2 MiB      0.0 MiB           1       count = 0
    36     67.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     67.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     67.2 MiB      0.0 MiB           1       came_from = {}
    39     67.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     67.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     67.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     67.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     67.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     67.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     67.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     67.2 MiB      0.0 MiB         624       while not open_set.empty():
    49     67.2 MiB      0.0 MiB         624           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     67.2 MiB      0.0 MiB         624           current = open_set.get()[2]
    55     67.2 MiB      0.0 MiB         624           open_set_hash.remove(current)
    56                                         
    57     67.2 MiB      0.0 MiB         624           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     67.2 MiB      0.0 MiB         624           if current == end:
    62     67.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     67.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     67.2 MiB      0.0 MiB        5607           for neighbor in current.neighbors:
    67     67.2 MiB      0.0 MiB        4984               if current.row != neighbor.row and current.col != neighbor.col:
    68     67.2 MiB      0.0 MiB        2492                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     67.2 MiB      0.0 MiB        2492                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     67.2 MiB      0.0 MiB        4984               if temp_g_score < g_score[neighbor]:
    73     67.2 MiB      0.0 MiB         770                   came_from[neighbor] = current
    74     67.2 MiB      0.0 MiB         770                   g_score[neighbor] = temp_g_score
    75     67.2 MiB      0.0 MiB         770                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     67.2 MiB      0.0 MiB         770                   if neighbor not in open_set_hash:
    77     67.2 MiB      0.0 MiB         770                       count += 1
    78     67.2 MiB      0.0 MiB         770                       open_set.put((f_score[neighbor], count, neighbor))
    79     67.2 MiB      0.0 MiB         770                       open_set_hash.add(neighbor)
    80                                                             
    81     67.2 MiB      0.0 MiB         623           if draw is not None:
    82                                                     draw()
    83                                         
    84     67.2 MiB      0.0 MiB         623           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     67.3 MiB     67.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     67.3 MiB      0.0 MiB         129       for row in grid:
    32     67.3 MiB      0.0 MiB       16512           for spot in row:
    33     67.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     67.3 MiB      0.0 MiB           1       count = 0
    36     67.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     67.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     67.3 MiB      0.0 MiB           1       came_from = {}
    39     67.6 MiB      0.2 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     67.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     67.6 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     67.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     67.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     67.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     67.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     67.6 MiB      0.0 MiB         528       while not open_set.empty():
    49     67.6 MiB      0.0 MiB         528           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     67.6 MiB      0.0 MiB         528           current = open_set.get()[2]
    55     67.6 MiB      0.0 MiB         528           open_set_hash.remove(current)
    56                                         
    57     67.6 MiB      0.0 MiB         528           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     67.6 MiB      0.0 MiB         528           if current == end:
    62     67.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     67.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     67.6 MiB      0.0 MiB        4743           for neighbor in current.neighbors:
    67     67.6 MiB      0.0 MiB        4216               if current.row != neighbor.row and current.col != neighbor.col:
    68     67.6 MiB      0.0 MiB        2108                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     67.6 MiB      0.0 MiB        2108                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     67.6 MiB      0.0 MiB        4216               if temp_g_score < g_score[neighbor]:
    73     67.6 MiB      0.0 MiB         662                   came_from[neighbor] = current
    74     67.6 MiB      0.0 MiB         662                   g_score[neighbor] = temp_g_score
    75     67.6 MiB      0.0 MiB         662                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     67.6 MiB      0.0 MiB         662                   if neighbor not in open_set_hash:
    77     67.6 MiB      0.0 MiB         662                       count += 1
    78     67.6 MiB      0.0 MiB         662                       open_set.put((f_score[neighbor], count, neighbor))
    79     67.6 MiB      0.0 MiB         662                       open_set_hash.add(neighbor)
    80                                                             
    81     67.6 MiB      0.0 MiB         527           if draw is not None:
    82                                                     draw()
    83                                         
    84     67.6 MiB      0.0 MiB         527           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.3 MiB     70.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.3 MiB      0.0 MiB         129       for row in grid:
    32     70.3 MiB      0.0 MiB       16512           for spot in row:
    33     70.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.3 MiB      0.0 MiB           1       count = 0
    36     70.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.3 MiB      0.0 MiB           1       came_from = {}
    39     70.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.3 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.6 MiB      0.3 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.6 MiB      0.0 MiB         600       while not open_set.empty():
    49     70.6 MiB      0.0 MiB         600           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.6 MiB      0.0 MiB         600           current = open_set.get()[2]
    55     70.6 MiB      0.0 MiB         600           open_set_hash.remove(current)
    56                                         
    57     70.6 MiB      0.0 MiB         600           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.6 MiB      0.0 MiB         600           if current == end:
    62     70.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.6 MiB      0.0 MiB        5391           for neighbor in current.neighbors:
    67     70.6 MiB      0.0 MiB        4792               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.6 MiB      0.0 MiB        2396                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.6 MiB      0.0 MiB        2396                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.6 MiB      0.0 MiB        4792               if temp_g_score < g_score[neighbor]:
    73     70.6 MiB      0.0 MiB         758                   came_from[neighbor] = current
    74     70.6 MiB      0.0 MiB         758                   g_score[neighbor] = temp_g_score
    75     70.6 MiB      0.0 MiB         758                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.6 MiB      0.0 MiB         758                   if neighbor not in open_set_hash:
    77     70.6 MiB      0.0 MiB         758                       count += 1
    78     70.6 MiB      0.0 MiB         758                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.6 MiB      0.0 MiB         758                       open_set_hash.add(neighbor)
    80                                                             
    81     70.6 MiB      0.0 MiB         599           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.6 MiB      0.0 MiB         599           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.6 MiB     70.6 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.6 MiB      0.0 MiB         129       for row in grid:
    32     70.6 MiB      0.0 MiB       16512           for spot in row:
    33     70.6 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.6 MiB      0.0 MiB           1       count = 0
    36     70.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.6 MiB      0.0 MiB           1       came_from = {}
    39     70.8 MiB      0.2 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.8 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.8 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.8 MiB      0.0 MiB         610       while not open_set.empty():
    49     70.8 MiB      0.0 MiB         610           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.8 MiB      0.0 MiB         610           current = open_set.get()[2]
    55     70.8 MiB      0.0 MiB         610           open_set_hash.remove(current)
    56                                         
    57     70.8 MiB      0.0 MiB         610           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.8 MiB      0.0 MiB         610           if current == end:
    62     70.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.8 MiB      0.0 MiB        5481           for neighbor in current.neighbors:
    67     70.8 MiB      0.0 MiB        4872               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.8 MiB      0.0 MiB        2436                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.8 MiB      0.0 MiB        2436                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.8 MiB      0.0 MiB        4872               if temp_g_score < g_score[neighbor]:
    73     70.8 MiB      0.0 MiB         770                   came_from[neighbor] = current
    74     70.8 MiB      0.0 MiB         770                   g_score[neighbor] = temp_g_score
    75     70.8 MiB      0.0 MiB         770                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.8 MiB      0.0 MiB         770                   if neighbor not in open_set_hash:
    77     70.8 MiB      0.0 MiB         770                       count += 1
    78     70.8 MiB      0.0 MiB         770                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.8 MiB      0.0 MiB         770                       open_set_hash.add(neighbor)
    80                                                             
    81     70.8 MiB      0.0 MiB         609           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.8 MiB      0.0 MiB         609           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.9 MiB     70.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.9 MiB      0.0 MiB         129       for row in grid:
    32     70.9 MiB      0.0 MiB       16512           for spot in row:
    33     70.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.9 MiB      0.0 MiB           1       count = 0
    36     70.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.9 MiB      0.0 MiB           1       came_from = {}
    39     70.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.5 MiB      0.6 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.5 MiB      0.0 MiB         124       while not open_set.empty():
    49     71.5 MiB      0.0 MiB         124           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.5 MiB      0.0 MiB         124           current = open_set.get()[2]
    55     71.5 MiB      0.0 MiB         124           open_set_hash.remove(current)
    56                                         
    57     71.5 MiB      0.0 MiB         124           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.5 MiB      0.0 MiB         124           if current == end:
    62     71.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.5 MiB      0.0 MiB        1107           for neighbor in current.neighbors:
    67     71.5 MiB      0.0 MiB         984               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.5 MiB      0.0 MiB         492                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.5 MiB      0.0 MiB         492                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.5 MiB      0.0 MiB         984               if temp_g_score < g_score[neighbor]:
    73     71.5 MiB      0.0 MiB         374                   came_from[neighbor] = current
    74     71.5 MiB      0.0 MiB         374                   g_score[neighbor] = temp_g_score
    75     71.5 MiB      0.0 MiB         374                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.5 MiB      0.0 MiB         374                   if neighbor not in open_set_hash:
    77     71.5 MiB      0.0 MiB         374                       count += 1
    78     71.5 MiB      0.0 MiB         374                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.5 MiB      0.0 MiB         374                       open_set_hash.add(neighbor)
    80                                                             
    81     71.5 MiB      0.0 MiB         123           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.5 MiB      0.0 MiB         123           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.5 MiB     71.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.5 MiB      0.0 MiB         129       for row in grid:
    32     71.5 MiB      0.0 MiB       16512           for spot in row:
    33     71.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.5 MiB      0.0 MiB           1       count = 0
    36     71.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.5 MiB      0.0 MiB           1       came_from = {}
    39     71.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.5 MiB      0.0 MiB         600       while not open_set.empty():
    49     71.5 MiB      0.0 MiB         600           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.5 MiB      0.0 MiB         600           current = open_set.get()[2]
    55     71.5 MiB      0.0 MiB         600           open_set_hash.remove(current)
    56                                         
    57     71.5 MiB      0.0 MiB         600           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.5 MiB      0.0 MiB         600           if current == end:
    62     71.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.5 MiB      0.0 MiB        5391           for neighbor in current.neighbors:
    67     71.5 MiB      0.0 MiB        4792               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.5 MiB      0.0 MiB        2396                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.5 MiB      0.0 MiB        2396                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.5 MiB      0.0 MiB        4792               if temp_g_score < g_score[neighbor]:
    73     71.5 MiB      0.0 MiB         858                   came_from[neighbor] = current
    74     71.5 MiB      0.0 MiB         858                   g_score[neighbor] = temp_g_score
    75     71.5 MiB      0.0 MiB         858                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.5 MiB      0.0 MiB         858                   if neighbor not in open_set_hash:
    77     71.5 MiB      0.0 MiB         858                       count += 1
    78     71.5 MiB      0.0 MiB         858                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.5 MiB      0.0 MiB         858                       open_set_hash.add(neighbor)
    80                                                             
    81     71.5 MiB      0.0 MiB         599           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.5 MiB      0.0 MiB         599           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.5 MiB     71.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.5 MiB      0.0 MiB         129       for row in grid:
    32     71.5 MiB      0.0 MiB       16512           for spot in row:
    33     71.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.5 MiB      0.0 MiB           1       count = 0
    36     71.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.5 MiB      0.0 MiB           1       came_from = {}
    39     71.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.5 MiB   -153.3 MiB         784       while not open_set.empty():
    49     71.5 MiB   -153.4 MiB         784           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.5 MiB   -153.5 MiB         784           current = open_set.get()[2]
    55     71.5 MiB   -153.6 MiB         784           open_set_hash.remove(current)
    56                                         
    57     71.5 MiB   -153.7 MiB         784           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.5 MiB   -153.8 MiB         784           if current == end:
    62     69.4 MiB     -2.1 MiB           1               if draw:
    63                                                         end.make_end()
    64     69.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.5 MiB  -1332.1 MiB        7026           for neighbor in current.neighbors:
    67     71.5 MiB  -1179.2 MiB        6243               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.5 MiB   -583.6 MiB        3118                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.5 MiB   -596.1 MiB        3125                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.5 MiB  -1180.0 MiB        6243               if temp_g_score < g_score[neighbor]:
    73     71.5 MiB   -208.4 MiB        1181                   came_from[neighbor] = current
    74     71.5 MiB   -208.4 MiB        1181                   g_score[neighbor] = temp_g_score
    75     71.5 MiB   -208.4 MiB        1181                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.5 MiB   -208.4 MiB        1181                   if neighbor not in open_set_hash:
    77     71.5 MiB   -208.4 MiB        1181                       count += 1
    78     71.5 MiB   -208.4 MiB        1181                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.5 MiB   -208.4 MiB        1181                       open_set_hash.add(neighbor)
    80                                                             
    81     71.5 MiB   -153.3 MiB         783           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.5 MiB   -153.3 MiB         783           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     69.4 MiB     69.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     69.4 MiB      0.0 MiB         129       for row in grid:
    32     69.4 MiB      0.0 MiB       16512           for spot in row:
    33     69.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     69.4 MiB      0.0 MiB           1       count = 0
    36     69.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     69.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     69.4 MiB      0.0 MiB           1       came_from = {}
    39     69.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     69.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     69.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     69.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     69.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     69.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     69.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     69.4 MiB      0.0 MiB         368       while not open_set.empty():
    49     69.4 MiB      0.0 MiB         368           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     69.4 MiB      0.0 MiB         368           current = open_set.get()[2]
    55     69.4 MiB      0.0 MiB         368           open_set_hash.remove(current)
    56                                         
    57     69.4 MiB      0.0 MiB         368           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     69.4 MiB      0.0 MiB         368           if current == end:
    62     69.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     69.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     69.4 MiB      0.0 MiB        3303           for neighbor in current.neighbors:
    67     69.4 MiB      0.0 MiB        2936               if current.row != neighbor.row and current.col != neighbor.col:
    68     69.4 MiB      0.0 MiB        1468                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     69.4 MiB      0.0 MiB        1468                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     69.4 MiB      0.0 MiB        2936               if temp_g_score < g_score[neighbor]:
    73     69.4 MiB      0.0 MiB         490                   came_from[neighbor] = current
    74     69.4 MiB      0.0 MiB         490                   g_score[neighbor] = temp_g_score
    75     69.4 MiB      0.0 MiB         490                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     69.4 MiB      0.0 MiB         490                   if neighbor not in open_set_hash:
    77     69.4 MiB      0.0 MiB         490                       count += 1
    78     69.4 MiB      0.0 MiB         490                       open_set.put((f_score[neighbor], count, neighbor))
    79     69.4 MiB      0.0 MiB         490                       open_set_hash.add(neighbor)
    80                                                             
    81     69.4 MiB      0.0 MiB         367           if draw is not None:
    82                                                     draw()
    83                                         
    84     69.4 MiB      0.0 MiB         367           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     69.4 MiB     69.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     69.4 MiB      0.0 MiB         129       for row in grid:
    32     69.4 MiB      0.0 MiB       16512           for spot in row:
    33     69.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     69.4 MiB      0.0 MiB           1       count = 0
    36     69.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     69.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     69.4 MiB      0.0 MiB           1       came_from = {}
    39     69.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     69.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     69.7 MiB      0.2 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     69.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     69.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     69.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     69.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     69.7 MiB      0.0 MiB        1230       while not open_set.empty():
    49     69.7 MiB      0.0 MiB        1230           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     69.7 MiB      0.0 MiB        1230           current = open_set.get()[2]
    55     69.7 MiB      0.0 MiB        1230           open_set_hash.remove(current)
    56                                         
    57     69.7 MiB      0.0 MiB        1230           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     69.7 MiB      0.0 MiB        1230           if current == end:
    62     69.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     69.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     69.7 MiB      0.0 MiB       11058           for neighbor in current.neighbors:
    67     69.7 MiB      0.0 MiB        9829               if current.row != neighbor.row and current.col != neighbor.col:
    68     69.7 MiB      0.0 MiB        4914                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     69.7 MiB      0.0 MiB        4915                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     69.7 MiB      0.0 MiB        9829               if temp_g_score < g_score[neighbor]:
    73     69.7 MiB      0.0 MiB        1449                   came_from[neighbor] = current
    74     69.7 MiB      0.0 MiB        1449                   g_score[neighbor] = temp_g_score
    75     69.7 MiB      0.0 MiB        1449                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     69.7 MiB      0.0 MiB        1449                   if neighbor not in open_set_hash:
    77     69.7 MiB      0.0 MiB        1449                       count += 1
    78     69.7 MiB      0.0 MiB        1449                       open_set.put((f_score[neighbor], count, neighbor))
    79     69.7 MiB      0.0 MiB        1449                       open_set_hash.add(neighbor)
    80                                                             
    81     69.7 MiB      0.0 MiB        1229           if draw is not None:
    82                                                     draw()
    83                                         
    84     69.7 MiB      0.0 MiB        1229           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     69.7 MiB     69.7 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     69.7 MiB      0.0 MiB         129       for row in grid:
    32     69.7 MiB      0.0 MiB       16512           for spot in row:
    33     69.7 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     69.7 MiB      0.0 MiB           1       count = 0
    36     69.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     69.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     69.7 MiB      0.0 MiB           1       came_from = {}
    39     70.4 MiB      0.7 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.4 MiB      0.0 MiB         238       while not open_set.empty():
    49     70.4 MiB      0.0 MiB         238           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.4 MiB      0.0 MiB         238           current = open_set.get()[2]
    55     70.4 MiB      0.0 MiB         238           open_set_hash.remove(current)
    56                                         
    57     70.4 MiB      0.0 MiB         238           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.4 MiB      0.0 MiB         238           if current == end:
    62     70.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.4 MiB      0.0 MiB        2133           for neighbor in current.neighbors:
    67     70.4 MiB      0.0 MiB        1896               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.4 MiB      0.0 MiB         948                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.4 MiB      0.0 MiB         948                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.4 MiB      0.0 MiB        1896               if temp_g_score < g_score[neighbor]:
    73     70.4 MiB      0.0 MiB         332                   came_from[neighbor] = current
    74     70.4 MiB      0.0 MiB         332                   g_score[neighbor] = temp_g_score
    75     70.4 MiB      0.0 MiB         332                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.4 MiB      0.0 MiB         332                   if neighbor not in open_set_hash:
    77     70.4 MiB      0.0 MiB         332                       count += 1
    78     70.4 MiB      0.0 MiB         332                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.4 MiB      0.0 MiB         332                       open_set_hash.add(neighbor)
    80                                                             
    81     70.4 MiB      0.0 MiB         237           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.4 MiB      0.0 MiB         237           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.4 MiB     70.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.4 MiB      0.0 MiB         129       for row in grid:
    32     70.4 MiB      0.0 MiB       16512           for spot in row:
    33     70.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.4 MiB      0.0 MiB           1       count = 0
    36     70.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.4 MiB      0.0 MiB           1       came_from = {}
    39     70.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.4 MiB      0.0 MiB         424       while not open_set.empty():
    49     70.4 MiB      0.0 MiB         424           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.4 MiB      0.0 MiB         424           current = open_set.get()[2]
    55     70.4 MiB      0.0 MiB         424           open_set_hash.remove(current)
    56                                         
    57     70.4 MiB      0.0 MiB         424           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.4 MiB      0.0 MiB         424           if current == end:
    62     70.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.4 MiB      0.0 MiB        3807           for neighbor in current.neighbors:
    67     70.4 MiB      0.0 MiB        3384               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.4 MiB      0.0 MiB        1692                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.4 MiB      0.0 MiB        1692                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.4 MiB      0.0 MiB        3384               if temp_g_score < g_score[neighbor]:
    73     70.4 MiB      0.0 MiB         650                   came_from[neighbor] = current
    74     70.4 MiB      0.0 MiB         650                   g_score[neighbor] = temp_g_score
    75     70.4 MiB      0.0 MiB         650                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.4 MiB      0.0 MiB         650                   if neighbor not in open_set_hash:
    77     70.4 MiB      0.0 MiB         650                       count += 1
    78     70.4 MiB      0.0 MiB         650                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.4 MiB      0.0 MiB         650                       open_set_hash.add(neighbor)
    80                                                             
    81     70.4 MiB      0.0 MiB         423           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.4 MiB      0.0 MiB         423           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.4 MiB     70.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.4 MiB      0.0 MiB         129       for row in grid:
    32     70.4 MiB      0.0 MiB       16512           for spot in row:
    33     70.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.4 MiB      0.0 MiB           1       count = 0
    36     70.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.4 MiB      0.0 MiB           1       came_from = {}
    39     70.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.4 MiB      0.0 MiB        1095       while not open_set.empty():
    49     70.4 MiB      0.0 MiB        1095           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.4 MiB      0.0 MiB        1095           current = open_set.get()[2]
    55     70.4 MiB      0.0 MiB        1095           open_set_hash.remove(current)
    56                                         
    57     70.4 MiB      0.0 MiB        1095           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.4 MiB      0.0 MiB        1095           if current == end:
    62     70.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.4 MiB      0.0 MiB        9630           for neighbor in current.neighbors:
    67     70.4 MiB      0.0 MiB        8536               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.4 MiB      0.0 MiB        4232                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.4 MiB      0.0 MiB        4304                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.4 MiB      0.0 MiB        8536               if temp_g_score < g_score[neighbor]:
    73     70.4 MiB      0.0 MiB        1225                   came_from[neighbor] = current
    74     70.4 MiB      0.0 MiB        1225                   g_score[neighbor] = temp_g_score
    75     70.4 MiB      0.0 MiB        1225                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.4 MiB      0.0 MiB        1225                   if neighbor not in open_set_hash:
    77     70.4 MiB      0.0 MiB        1225                       count += 1
    78     70.4 MiB      0.0 MiB        1225                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.4 MiB      0.0 MiB        1225                       open_set_hash.add(neighbor)
    80                                                             
    81     70.4 MiB      0.0 MiB        1094           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.4 MiB      0.0 MiB        1094           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.4 MiB     70.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.4 MiB     -0.4 MiB         129       for row in grid:
    32     70.4 MiB    -55.5 MiB       16512           for spot in row:
    33     70.4 MiB    -55.1 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.4 MiB     -0.0 MiB           1       count = 0
    36     70.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.4 MiB      0.0 MiB           1       came_from = {}
    39     70.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.4 MiB      0.0 MiB           9       while not open_set.empty():
    49     70.4 MiB      0.0 MiB           9           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.4 MiB      0.0 MiB           9           current = open_set.get()[2]
    55     70.4 MiB      0.0 MiB           9           open_set_hash.remove(current)
    56                                         
    57     70.4 MiB      0.0 MiB           9           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.4 MiB      0.0 MiB           9           if current == end:
    62     70.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.4 MiB      0.0 MiB          72           for neighbor in current.neighbors:
    67     70.4 MiB      0.0 MiB          64               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.4 MiB      0.0 MiB          32                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.4 MiB      0.0 MiB          32                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.4 MiB      0.0 MiB          64               if temp_g_score < g_score[neighbor]:
    73     70.4 MiB      0.0 MiB          25                   came_from[neighbor] = current
    74     70.4 MiB      0.0 MiB          25                   g_score[neighbor] = temp_g_score
    75     70.4 MiB      0.0 MiB          25                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.4 MiB      0.0 MiB          25                   if neighbor not in open_set_hash:
    77     70.4 MiB      0.0 MiB          25                       count += 1
    78     70.4 MiB      0.0 MiB          25                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.4 MiB      0.0 MiB          25                       open_set_hash.add(neighbor)
    80                                                             
    81     70.4 MiB      0.0 MiB           8           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.4 MiB      0.0 MiB           8           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.4 MiB     70.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.4 MiB      0.0 MiB         129       for row in grid:
    32     70.4 MiB      0.0 MiB       16512           for spot in row:
    33     70.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.4 MiB      0.0 MiB           1       count = 0
    36     70.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.4 MiB      0.0 MiB           1       came_from = {}
    39     70.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.5 MiB      0.1 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.5 MiB   -895.5 MiB        3198       while not open_set.empty():
    49     70.5 MiB   -895.5 MiB        3198           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.5 MiB   -895.5 MiB        3198           current = open_set.get()[2]
    55     70.5 MiB   -895.5 MiB        3198           open_set_hash.remove(current)
    56                                         
    57     70.5 MiB   -895.5 MiB        3198           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.5 MiB   -895.5 MiB        3198           if current == end:
    62     69.9 MiB     -0.6 MiB           1               if draw:
    63                                                         end.make_end()
    64     69.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.5 MiB  -8057.2 MiB       28773           for neighbor in current.neighbors:
    67     70.5 MiB  -7162.0 MiB       25576               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.5 MiB  -3582.1 MiB       12788                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.5 MiB  -3580.0 MiB       12788                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.5 MiB  -7162.1 MiB       25576               if temp_g_score < g_score[neighbor]:
    73     70.5 MiB   -961.4 MiB        3516                   came_from[neighbor] = current
    74     70.5 MiB   -961.4 MiB        3516                   g_score[neighbor] = temp_g_score
    75     70.5 MiB   -961.4 MiB        3516                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.5 MiB   -961.4 MiB        3516                   if neighbor not in open_set_hash:
    77     70.5 MiB   -961.4 MiB        3516                       count += 1
    78     70.5 MiB   -961.4 MiB        3516                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.5 MiB   -961.4 MiB        3516                       open_set_hash.add(neighbor)
    80                                                             
    81     70.5 MiB   -895.5 MiB        3197           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.5 MiB   -895.5 MiB        3197           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     68.9 MiB     68.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     68.9 MiB      0.0 MiB         129       for row in grid:
    32     68.9 MiB      0.0 MiB       16512           for spot in row:
    33     68.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     68.9 MiB      0.0 MiB           1       count = 0
    36     68.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     68.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     68.9 MiB      0.0 MiB           1       came_from = {}
    39     68.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     68.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     68.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     68.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     68.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     68.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     68.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     68.9 MiB      0.0 MiB         459       while not open_set.empty():
    49     68.9 MiB      0.0 MiB         459           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     68.9 MiB      0.0 MiB         459           current = open_set.get()[2]
    55     68.9 MiB      0.0 MiB         459           open_set_hash.remove(current)
    56                                         
    57     68.9 MiB      0.0 MiB         459           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     68.9 MiB      0.0 MiB         459           if current == end:
    62     68.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     68.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     68.9 MiB      0.0 MiB        4122           for neighbor in current.neighbors:
    67     68.9 MiB      0.0 MiB        3664               if current.row != neighbor.row and current.col != neighbor.col:
    68     68.9 MiB      0.0 MiB        1832                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     68.9 MiB      0.0 MiB        1832                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     68.9 MiB      0.0 MiB        3664               if temp_g_score < g_score[neighbor]:
    73     68.9 MiB      0.0 MiB         579                   came_from[neighbor] = current
    74     68.9 MiB      0.0 MiB         579                   g_score[neighbor] = temp_g_score
    75     68.9 MiB      0.0 MiB         579                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     68.9 MiB      0.0 MiB         579                   if neighbor not in open_set_hash:
    77     68.9 MiB      0.0 MiB         579                       count += 1
    78     68.9 MiB      0.0 MiB         579                       open_set.put((f_score[neighbor], count, neighbor))
    79     68.9 MiB      0.0 MiB         579                       open_set_hash.add(neighbor)
    80                                                             
    81     68.9 MiB      0.0 MiB         458           if draw is not None:
    82                                                     draw()
    83                                         
    84     68.9 MiB      0.0 MiB         458           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     68.9 MiB     68.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     68.9 MiB      0.0 MiB         129       for row in grid:
    32     68.9 MiB      0.0 MiB       16512           for spot in row:
    33     68.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     68.9 MiB      0.0 MiB           1       count = 0
    36     68.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     68.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     68.9 MiB      0.0 MiB           1       came_from = {}
    39     68.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     68.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     69.3 MiB      0.3 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     69.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     69.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     69.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46     69.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     69.3 MiB      0.0 MiB        1152       while not open_set.empty():
    49     69.3 MiB      0.0 MiB        1152           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     69.3 MiB      0.0 MiB        1152           current = open_set.get()[2]
    55     69.3 MiB      0.0 MiB        1152           open_set_hash.remove(current)
    56                                         
    57     69.3 MiB      0.0 MiB        1152           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     69.3 MiB      0.0 MiB        1152           if current == end:
    62     69.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     69.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     69.3 MiB      0.0 MiB       10359           for neighbor in current.neighbors:
    67     69.3 MiB      0.0 MiB        9208               if current.row != neighbor.row and current.col != neighbor.col:
    68     69.3 MiB      0.0 MiB        4604                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     69.3 MiB      0.0 MiB        4604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     69.3 MiB      0.0 MiB        9208               if temp_g_score < g_score[neighbor]:
    73     69.3 MiB      0.1 MiB        1470                   came_from[neighbor] = current
    74     69.3 MiB      0.0 MiB        1470                   g_score[neighbor] = temp_g_score
    75     69.3 MiB      0.0 MiB        1470                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     69.3 MiB      0.0 MiB        1470                   if neighbor not in open_set_hash:
    77     69.3 MiB      0.0 MiB        1470                       count += 1
    78     69.3 MiB      0.0 MiB        1470                       open_set.put((f_score[neighbor], count, neighbor))
    79     69.3 MiB      0.0 MiB        1470                       open_set_hash.add(neighbor)
    80                                                             
    81     69.3 MiB      0.0 MiB        1151           if draw is not None:
    82                                                     draw()
    83                                         
    84     69.3 MiB      0.0 MiB        1151           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     69.3 MiB     69.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     69.3 MiB      0.0 MiB         129       for row in grid:
    32     69.3 MiB      0.0 MiB       16512           for spot in row:
    33     69.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     69.3 MiB      0.0 MiB           1       count = 0
    36     69.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     69.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     69.3 MiB      0.0 MiB           1       came_from = {}
    39     69.5 MiB      0.2 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     69.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     69.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     69.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     69.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     69.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     69.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     69.5 MiB      0.0 MiB         833       while not open_set.empty():
    49     69.5 MiB      0.0 MiB         833           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     69.5 MiB      0.0 MiB         833           current = open_set.get()[2]
    55     69.5 MiB      0.0 MiB         833           open_set_hash.remove(current)
    56                                         
    57     69.5 MiB      0.0 MiB         833           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     69.5 MiB      0.0 MiB         833           if current == end:
    62     69.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     69.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     69.5 MiB      0.0 MiB        7488           for neighbor in current.neighbors:
    67     69.5 MiB      0.0 MiB        6656               if current.row != neighbor.row and current.col != neighbor.col:
    68     69.5 MiB      0.0 MiB        3328                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     69.5 MiB      0.0 MiB        3328                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     69.5 MiB      0.0 MiB        6656               if temp_g_score < g_score[neighbor]:
    73     69.5 MiB      0.0 MiB         997                   came_from[neighbor] = current
    74     69.5 MiB      0.0 MiB         997                   g_score[neighbor] = temp_g_score
    75     69.5 MiB      0.0 MiB         997                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     69.5 MiB      0.0 MiB         997                   if neighbor not in open_set_hash:
    77     69.5 MiB      0.0 MiB         997                       count += 1
    78     69.5 MiB      0.0 MiB         997                       open_set.put((f_score[neighbor], count, neighbor))
    79     69.5 MiB      0.0 MiB         997                       open_set_hash.add(neighbor)
    80                                                             
    81     69.5 MiB      0.0 MiB         832           if draw is not None:
    82                                                     draw()
    83                                         
    84     69.5 MiB      0.0 MiB         832           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     69.5 MiB     69.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     69.5 MiB      0.0 MiB         129       for row in grid:
    32     69.5 MiB      0.0 MiB       16512           for spot in row:
    33     69.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     69.5 MiB      0.0 MiB           1       count = 0
    36     69.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     69.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     69.5 MiB      0.0 MiB           1       came_from = {}
    39     69.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     69.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     69.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     69.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     69.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     69.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     69.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     69.5 MiB      0.0 MiB        2079       while not open_set.empty():
    49     69.5 MiB      0.0 MiB        2079           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     69.5 MiB      0.0 MiB        2079           current = open_set.get()[2]
    55     69.5 MiB      0.0 MiB        2079           open_set_hash.remove(current)
    56                                         
    57     69.5 MiB      0.0 MiB        2079           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     69.5 MiB      0.0 MiB        2079           if current == end:
    62     69.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     69.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     69.5 MiB      0.0 MiB       18702           for neighbor in current.neighbors:
    67     69.5 MiB      0.0 MiB       16624               if current.row != neighbor.row and current.col != neighbor.col:
    68     69.5 MiB      0.0 MiB        8312                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     69.5 MiB      0.0 MiB        8312                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     69.5 MiB      0.0 MiB       16624               if temp_g_score < g_score[neighbor]:
    73     69.5 MiB      0.0 MiB        2339                   came_from[neighbor] = current
    74     69.5 MiB      0.0 MiB        2339                   g_score[neighbor] = temp_g_score
    75     69.5 MiB      0.0 MiB        2339                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     69.5 MiB      0.0 MiB        2339                   if neighbor not in open_set_hash:
    77     69.5 MiB      0.0 MiB        2339                       count += 1
    78     69.5 MiB      0.0 MiB        2339                       open_set.put((f_score[neighbor], count, neighbor))
    79     69.5 MiB      0.0 MiB        2339                       open_set_hash.add(neighbor)
    80                                                             
    81     69.5 MiB      0.0 MiB        2078           if draw is not None:
    82                                                     draw()
    83                                         
    84     69.5 MiB      0.0 MiB        2078           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     69.6 MiB     69.6 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     69.6 MiB      0.0 MiB         129       for row in grid:
    32     69.6 MiB      0.0 MiB       16512           for spot in row:
    33     69.6 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     69.6 MiB      0.0 MiB           1       count = 0
    36     69.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     69.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     69.6 MiB      0.0 MiB           1       came_from = {}
    39     69.6 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     69.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     69.6 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     69.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     69.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     69.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     69.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     69.6 MiB      0.0 MiB        1088       while not open_set.empty():
    49     69.6 MiB      0.0 MiB        1088           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     69.6 MiB      0.0 MiB        1088           current = open_set.get()[2]
    55     69.6 MiB      0.0 MiB        1088           open_set_hash.remove(current)
    56                                         
    57     69.6 MiB      0.0 MiB        1088           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     69.6 MiB      0.0 MiB        1088           if current == end:
    62     69.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     69.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     69.6 MiB      0.0 MiB        9582           for neighbor in current.neighbors:
    67     69.6 MiB      0.0 MiB        8495               if current.row != neighbor.row and current.col != neighbor.col:
    68     69.6 MiB      0.0 MiB        4214                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     69.6 MiB      0.0 MiB        4281                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     69.6 MiB      0.0 MiB        8495               if temp_g_score < g_score[neighbor]:
    73     69.6 MiB      0.0 MiB        1217                   came_from[neighbor] = current
    74     69.6 MiB      0.0 MiB        1217                   g_score[neighbor] = temp_g_score
    75     69.6 MiB      0.0 MiB        1217                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     69.6 MiB      0.0 MiB        1217                   if neighbor not in open_set_hash:
    77     69.6 MiB      0.0 MiB        1217                       count += 1
    78     69.6 MiB      0.0 MiB        1217                       open_set.put((f_score[neighbor], count, neighbor))
    79     69.6 MiB      0.0 MiB        1217                       open_set_hash.add(neighbor)
    80                                                             
    81     69.6 MiB      0.0 MiB        1087           if draw is not None:
    82                                                     draw()
    83                                         
    84     69.6 MiB      0.0 MiB        1087           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.3 MiB     70.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.3 MiB      0.0 MiB         129       for row in grid:
    32     70.3 MiB      0.0 MiB       16512           for spot in row:
    33     70.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.3 MiB      0.0 MiB           1       count = 0
    36     70.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.3 MiB      0.0 MiB           1       came_from = {}
    39     70.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.3 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.6 MiB      0.3 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.6 MiB      0.0 MiB         216       while not open_set.empty():
    49     70.6 MiB      0.0 MiB         216           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.6 MiB      0.0 MiB         216           current = open_set.get()[2]
    55     70.6 MiB      0.0 MiB         216           open_set_hash.remove(current)
    56                                         
    57     70.6 MiB      0.0 MiB         216           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.6 MiB      0.0 MiB         216           if current == end:
    62     70.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.6 MiB      0.0 MiB        1935           for neighbor in current.neighbors:
    67     70.6 MiB      0.0 MiB        1720               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.6 MiB      0.0 MiB         860                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.6 MiB      0.0 MiB         860                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.6 MiB      0.0 MiB        1720               if temp_g_score < g_score[neighbor]:
    73     70.6 MiB      0.0 MiB         438                   came_from[neighbor] = current
    74     70.6 MiB      0.0 MiB         438                   g_score[neighbor] = temp_g_score
    75     70.6 MiB      0.0 MiB         438                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.6 MiB      0.0 MiB         438                   if neighbor not in open_set_hash:
    77     70.6 MiB      0.0 MiB         438                       count += 1
    78     70.6 MiB      0.0 MiB         438                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.6 MiB      0.0 MiB         438                       open_set_hash.add(neighbor)
    80                                                             
    81     70.6 MiB      0.0 MiB         215           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.6 MiB      0.0 MiB         215           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.6 MiB     70.6 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.6 MiB      0.0 MiB         129       for row in grid:
    32     70.6 MiB      0.0 MiB       16512           for spot in row:
    33     70.6 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.6 MiB      0.0 MiB           1       count = 0
    36     70.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.6 MiB      0.0 MiB           1       came_from = {}
    39     70.6 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.2 MiB      0.6 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.2 MiB      0.0 MiB         399       while not open_set.empty():
    49     71.2 MiB      0.0 MiB         399           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.2 MiB      0.0 MiB         399           current = open_set.get()[2]
    55     71.2 MiB      0.0 MiB         399           open_set_hash.remove(current)
    56                                         
    57     71.2 MiB      0.0 MiB         399           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.2 MiB      0.0 MiB         399           if current == end:
    62     71.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.2 MiB      0.0 MiB        3582           for neighbor in current.neighbors:
    67     71.2 MiB      0.0 MiB        3184               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.2 MiB      0.0 MiB        1592                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.2 MiB      0.0 MiB        1592                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.2 MiB      0.0 MiB        3184               if temp_g_score < g_score[neighbor]:
    73     71.2 MiB      0.0 MiB         639                   came_from[neighbor] = current
    74     71.2 MiB      0.0 MiB         639                   g_score[neighbor] = temp_g_score
    75     71.2 MiB      0.0 MiB         639                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.2 MiB      0.0 MiB         639                   if neighbor not in open_set_hash:
    77     71.2 MiB      0.0 MiB         639                       count += 1
    78     71.2 MiB      0.0 MiB         639                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.2 MiB      0.0 MiB         639                       open_set_hash.add(neighbor)
    80                                                             
    81     71.2 MiB      0.0 MiB         398           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.2 MiB      0.0 MiB         398           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.2 MiB     71.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.2 MiB      0.0 MiB         129       for row in grid:
    32     71.2 MiB      0.0 MiB       16512           for spot in row:
    33     71.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.2 MiB      0.0 MiB           1       count = 0
    36     71.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.2 MiB      0.0 MiB           1       came_from = {}
    39     71.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.2 MiB      0.0 MiB        1449       while not open_set.empty():
    49     71.2 MiB      0.0 MiB        1449           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.2 MiB      0.0 MiB        1449           current = open_set.get()[2]
    55     71.2 MiB      0.0 MiB        1449           open_set_hash.remove(current)
    56                                         
    57     71.2 MiB      0.0 MiB        1449           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.2 MiB      0.0 MiB        1449           if current == end:
    62     71.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.2 MiB      0.0 MiB       13032           for neighbor in current.neighbors:
    67     71.2 MiB      0.0 MiB       11584               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.2 MiB      0.0 MiB        5792                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.2 MiB      0.0 MiB        5792                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.2 MiB      0.0 MiB       11584               if temp_g_score < g_score[neighbor]:
    73     71.2 MiB      0.0 MiB        1745                   came_from[neighbor] = current
    74     71.2 MiB      0.0 MiB        1745                   g_score[neighbor] = temp_g_score
    75     71.2 MiB      0.0 MiB        1745                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.2 MiB      0.0 MiB        1745                   if neighbor not in open_set_hash:
    77     71.2 MiB      0.0 MiB        1745                       count += 1
    78     71.2 MiB      0.0 MiB        1745                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.2 MiB      0.0 MiB        1745                       open_set_hash.add(neighbor)
    80                                                             
    81     71.2 MiB      0.0 MiB        1448           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.2 MiB      0.0 MiB        1448           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.2 MiB     71.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.2 MiB      0.0 MiB         129       for row in grid:
    32     71.2 MiB      0.0 MiB       16512           for spot in row:
    33     71.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.2 MiB      0.0 MiB           1       count = 0
    36     71.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.2 MiB      0.0 MiB           1       came_from = {}
    39     71.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.2 MiB      0.0 MiB         750       while not open_set.empty():
    49     71.2 MiB      0.0 MiB         750           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.2 MiB      0.0 MiB         750           current = open_set.get()[2]
    55     71.2 MiB      0.0 MiB         750           open_set_hash.remove(current)
    56                                         
    57     71.2 MiB      0.0 MiB         750           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.2 MiB      0.0 MiB         750           if current == end:
    62     71.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.2 MiB      0.0 MiB        6741           for neighbor in current.neighbors:
    67     71.2 MiB      0.0 MiB        5992               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.2 MiB      0.0 MiB        2996                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.2 MiB      0.0 MiB        2996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.2 MiB      0.0 MiB        5992               if temp_g_score < g_score[neighbor]:
    73     71.2 MiB      0.0 MiB         908                   came_from[neighbor] = current
    74     71.2 MiB      0.0 MiB         908                   g_score[neighbor] = temp_g_score
    75     71.2 MiB      0.0 MiB         908                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.2 MiB      0.0 MiB         908                   if neighbor not in open_set_hash:
    77     71.2 MiB      0.0 MiB         908                       count += 1
    78     71.2 MiB      0.0 MiB         908                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.2 MiB      0.0 MiB         908                       open_set_hash.add(neighbor)
    80                                                             
    81     71.2 MiB      0.0 MiB         749           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.2 MiB      0.0 MiB         749           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.2 MiB     71.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.2 MiB      0.0 MiB         129       for row in grid:
    32     71.2 MiB      0.0 MiB       16512           for spot in row:
    33     71.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.2 MiB      0.0 MiB           1       count = 0
    36     71.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.2 MiB      0.0 MiB           1       came_from = {}
    39     71.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.2 MiB      0.0 MiB         288       while not open_set.empty():
    49     71.2 MiB      0.0 MiB         288           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.2 MiB      0.0 MiB         288           current = open_set.get()[2]
    55     71.2 MiB      0.0 MiB         288           open_set_hash.remove(current)
    56                                         
    57     71.2 MiB      0.0 MiB         288           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.2 MiB      0.0 MiB         288           if current == end:
    62     71.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.2 MiB      0.0 MiB        2583           for neighbor in current.neighbors:
    67     71.2 MiB      0.0 MiB        2296               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.2 MiB      0.0 MiB        1148                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.2 MiB      0.0 MiB        1148                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.2 MiB      0.0 MiB        2296               if temp_g_score < g_score[neighbor]:
    73     71.2 MiB      0.0 MiB         432                   came_from[neighbor] = current
    74     71.2 MiB      0.0 MiB         432                   g_score[neighbor] = temp_g_score
    75     71.2 MiB      0.0 MiB         432                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.2 MiB      0.0 MiB         432                   if neighbor not in open_set_hash:
    77     71.2 MiB      0.0 MiB         432                       count += 1
    78     71.2 MiB      0.0 MiB         432                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.2 MiB      0.0 MiB         432                       open_set_hash.add(neighbor)
    80                                                             
    81     71.2 MiB      0.0 MiB         287           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.2 MiB      0.0 MiB         287           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.2 MiB     71.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.2 MiB      0.0 MiB         129       for row in grid:
    32     71.2 MiB      0.0 MiB       16512           for spot in row:
    33     71.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.2 MiB      0.0 MiB           1       count = 0
    36     71.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.2 MiB      0.0 MiB           1       came_from = {}
    39     71.3 MiB      0.1 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.3 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.5 MiB      0.2 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.5 MiB      0.0 MiB         290       while not open_set.empty():
    49     71.5 MiB      0.0 MiB         290           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.5 MiB      0.0 MiB         290           current = open_set.get()[2]
    55     71.5 MiB      0.0 MiB         290           open_set_hash.remove(current)
    56                                         
    57     71.5 MiB      0.0 MiB         290           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.5 MiB      0.0 MiB         290           if current == end:
    62     71.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.5 MiB      0.0 MiB        2601           for neighbor in current.neighbors:
    67     71.5 MiB      0.0 MiB        2312               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.5 MiB      0.0 MiB        1156                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.5 MiB      0.0 MiB        1156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.5 MiB      0.0 MiB        2312               if temp_g_score < g_score[neighbor]:
    73     71.5 MiB      0.0 MiB         424                   came_from[neighbor] = current
    74     71.5 MiB      0.0 MiB         424                   g_score[neighbor] = temp_g_score
    75     71.5 MiB      0.0 MiB         424                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.5 MiB      0.0 MiB         424                   if neighbor not in open_set_hash:
    77     71.5 MiB      0.0 MiB         424                       count += 1
    78     71.5 MiB      0.0 MiB         424                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.5 MiB      0.0 MiB         424                       open_set_hash.add(neighbor)
    80                                                             
    81     71.5 MiB      0.0 MiB         289           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.5 MiB      0.0 MiB         289           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.5 MiB     71.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.5 MiB      0.0 MiB         129       for row in grid:
    32     71.5 MiB      0.0 MiB       16512           for spot in row:
    33     71.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.5 MiB      0.0 MiB           1       count = 0
    36     71.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.5 MiB      0.0 MiB           1       came_from = {}
    39     71.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.5 MiB      0.0 MiB         966       while not open_set.empty():
    49     71.5 MiB      0.0 MiB         966           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.5 MiB      0.0 MiB         966           current = open_set.get()[2]
    55     71.5 MiB      0.0 MiB         966           open_set_hash.remove(current)
    56                                         
    57     71.5 MiB      0.0 MiB         966           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.5 MiB      0.0 MiB         966           if current == end:
    62     71.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.5 MiB      0.0 MiB        8685           for neighbor in current.neighbors:
    67     71.5 MiB      0.0 MiB        7720               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.5 MiB      0.0 MiB        3860                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.5 MiB      0.0 MiB        3860                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.5 MiB      0.0 MiB        7720               if temp_g_score < g_score[neighbor]:
    73     71.5 MiB      0.0 MiB        1158                   came_from[neighbor] = current
    74     71.5 MiB      0.0 MiB        1158                   g_score[neighbor] = temp_g_score
    75     71.5 MiB      0.0 MiB        1158                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.5 MiB      0.0 MiB        1158                   if neighbor not in open_set_hash:
    77     71.5 MiB      0.0 MiB        1158                       count += 1
    78     71.5 MiB      0.0 MiB        1158                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.5 MiB      0.0 MiB        1158                       open_set_hash.add(neighbor)
    80                                                             
    81     71.5 MiB      0.0 MiB         965           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.5 MiB      0.0 MiB         965           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.5 MiB     71.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.5 MiB      0.0 MiB         129       for row in grid:
    32     71.5 MiB      0.0 MiB       16512           for spot in row:
    33     71.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.5 MiB      0.0 MiB           1       count = 0
    36     71.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.5 MiB      0.0 MiB           1       came_from = {}
    39     71.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.5 MiB      0.0 MiB         473       while not open_set.empty():
    49     71.5 MiB      0.0 MiB         473           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.5 MiB      0.0 MiB         473           current = open_set.get()[2]
    55     71.5 MiB      0.0 MiB         473           open_set_hash.remove(current)
    56                                         
    57     71.5 MiB      0.0 MiB         473           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.5 MiB      0.0 MiB         473           if current == end:
    62     71.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.5 MiB      0.0 MiB        4248           for neighbor in current.neighbors:
    67     71.5 MiB      0.0 MiB        3776               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.5 MiB      0.0 MiB        1888                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.5 MiB      0.0 MiB        1888                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.5 MiB      0.0 MiB        3776               if temp_g_score < g_score[neighbor]:
    73     71.5 MiB      0.0 MiB         665                   came_from[neighbor] = current
    74     71.5 MiB      0.0 MiB         665                   g_score[neighbor] = temp_g_score
    75     71.5 MiB      0.0 MiB         665                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.5 MiB      0.0 MiB         665                   if neighbor not in open_set_hash:
    77     71.5 MiB      0.0 MiB         665                       count += 1
    78     71.5 MiB      0.0 MiB         665                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.5 MiB      0.0 MiB         665                       open_set_hash.add(neighbor)
    80                                                             
    81     71.5 MiB      0.0 MiB         472           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.5 MiB      0.0 MiB         472           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.5 MiB     71.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.5 MiB      0.0 MiB         129       for row in grid:
    32     71.5 MiB      0.0 MiB       16512           for spot in row:
    33     71.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.5 MiB      0.0 MiB           1       count = 0
    36     71.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.5 MiB      0.0 MiB           1       came_from = {}
    39     71.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.5 MiB      0.0 MiB         572       while not open_set.empty():
    49     71.5 MiB      0.0 MiB         572           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.5 MiB      0.0 MiB         572           current = open_set.get()[2]
    55     71.5 MiB      0.0 MiB         572           open_set_hash.remove(current)
    56                                         
    57     71.5 MiB      0.0 MiB         572           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.5 MiB      0.0 MiB         572           if current == end:
    62     71.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.5 MiB      0.0 MiB        5139           for neighbor in current.neighbors:
    67     71.5 MiB      0.0 MiB        4568               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.5 MiB      0.0 MiB        2284                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.5 MiB      0.0 MiB        2284                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.5 MiB      0.0 MiB        4568               if temp_g_score < g_score[neighbor]:
    73     71.5 MiB      0.0 MiB         710                   came_from[neighbor] = current
    74     71.5 MiB      0.0 MiB         710                   g_score[neighbor] = temp_g_score
    75     71.5 MiB      0.0 MiB         710                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.5 MiB      0.0 MiB         710                   if neighbor not in open_set_hash:
    77     71.5 MiB      0.0 MiB         710                       count += 1
    78     71.5 MiB      0.0 MiB         710                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.5 MiB      0.0 MiB         710                       open_set_hash.add(neighbor)
    80                                                             
    81     71.5 MiB      0.0 MiB         571           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.5 MiB      0.0 MiB         571           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.5 MiB     71.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.5 MiB      0.0 MiB         129       for row in grid:
    32     71.5 MiB      0.0 MiB       16512           for spot in row:
    33     71.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.5 MiB      0.0 MiB           1       count = 0
    36     71.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.5 MiB      0.0 MiB           1       came_from = {}
    39     71.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.5 MiB      0.0 MiB         168       while not open_set.empty():
    49     71.5 MiB      0.0 MiB         168           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.5 MiB      0.0 MiB         168           current = open_set.get()[2]
    55     71.5 MiB      0.0 MiB         168           open_set_hash.remove(current)
    56                                         
    57     71.5 MiB      0.0 MiB         168           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.5 MiB      0.0 MiB         168           if current == end:
    62     71.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.5 MiB      0.0 MiB        1503           for neighbor in current.neighbors:
    67     71.5 MiB      0.0 MiB        1336               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.5 MiB      0.0 MiB         668                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.5 MiB      0.0 MiB         668                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.5 MiB      0.0 MiB        1336               if temp_g_score < g_score[neighbor]:
    73     71.5 MiB      0.0 MiB         242                   came_from[neighbor] = current
    74     71.5 MiB      0.0 MiB         242                   g_score[neighbor] = temp_g_score
    75     71.5 MiB      0.0 MiB         242                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.5 MiB      0.0 MiB         242                   if neighbor not in open_set_hash:
    77     71.5 MiB      0.0 MiB         242                       count += 1
    78     71.5 MiB      0.0 MiB         242                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.5 MiB      0.0 MiB         242                       open_set_hash.add(neighbor)
    80                                                             
    81     71.5 MiB      0.0 MiB         167           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.5 MiB      0.0 MiB         167           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.5 MiB     71.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.5 MiB      0.0 MiB         129       for row in grid:
    32     71.5 MiB      0.0 MiB       16512           for spot in row:
    33     71.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.5 MiB      0.0 MiB           1       count = 0
    36     71.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.5 MiB      0.0 MiB           1       came_from = {}
    39     71.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.5 MiB      0.0 MiB         165       while not open_set.empty():
    49     71.5 MiB      0.0 MiB         165           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.5 MiB      0.0 MiB         165           current = open_set.get()[2]
    55     71.5 MiB      0.0 MiB         165           open_set_hash.remove(current)
    56                                         
    57     71.5 MiB      0.0 MiB         165           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.5 MiB      0.0 MiB         165           if current == end:
    62     71.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.5 MiB      0.0 MiB        1476           for neighbor in current.neighbors:
    67     71.5 MiB      0.0 MiB        1312               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.5 MiB      0.0 MiB         656                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.5 MiB      0.0 MiB         656                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.5 MiB      0.0 MiB        1312               if temp_g_score < g_score[neighbor]:
    73     71.5 MiB      0.0 MiB         245                   came_from[neighbor] = current
    74     71.5 MiB      0.0 MiB         245                   g_score[neighbor] = temp_g_score
    75     71.5 MiB      0.0 MiB         245                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.5 MiB      0.0 MiB         245                   if neighbor not in open_set_hash:
    77     71.5 MiB      0.0 MiB         245                       count += 1
    78     71.5 MiB      0.0 MiB         245                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.5 MiB      0.0 MiB         245                       open_set_hash.add(neighbor)
    80                                                             
    81     71.5 MiB      0.0 MiB         164           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.5 MiB      0.0 MiB         164           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.5 MiB     71.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.5 MiB      0.0 MiB         129       for row in grid:
    32     71.5 MiB      0.0 MiB       16512           for spot in row:
    33     71.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.5 MiB      0.0 MiB           1       count = 0
    36     71.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.5 MiB      0.0 MiB           1       came_from = {}
    39     71.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.5 MiB      0.0 MiB         792       while not open_set.empty():
    49     71.5 MiB      0.0 MiB         792           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.5 MiB      0.0 MiB         792           current = open_set.get()[2]
    55     71.5 MiB      0.0 MiB         792           open_set_hash.remove(current)
    56                                         
    57     71.5 MiB      0.0 MiB         792           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.5 MiB      0.0 MiB         792           if current == end:
    62     71.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.5 MiB      0.0 MiB        7119           for neighbor in current.neighbors:
    67     71.5 MiB      0.0 MiB        6328               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.5 MiB      0.0 MiB        3164                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.5 MiB      0.0 MiB        3164                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.5 MiB      0.0 MiB        6328               if temp_g_score < g_score[neighbor]:
    73     71.5 MiB      0.0 MiB         950                   came_from[neighbor] = current
    74     71.5 MiB      0.0 MiB         950                   g_score[neighbor] = temp_g_score
    75     71.5 MiB      0.0 MiB         950                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.5 MiB      0.0 MiB         950                   if neighbor not in open_set_hash:
    77     71.5 MiB      0.0 MiB         950                       count += 1
    78     71.5 MiB      0.0 MiB         950                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.5 MiB      0.0 MiB         950                       open_set_hash.add(neighbor)
    80                                                             
    81     71.5 MiB      0.0 MiB         791           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.5 MiB      0.0 MiB         791           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.5 MiB     71.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.5 MiB      0.0 MiB         129       for row in grid:
    32     71.5 MiB      0.0 MiB       16512           for spot in row:
    33     71.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.5 MiB      0.0 MiB           1       count = 0
    36     71.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.5 MiB      0.0 MiB           1       came_from = {}
    39     71.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.5 MiB      0.0 MiB        1638       while not open_set.empty():
    49     71.5 MiB      0.0 MiB        1638           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.5 MiB      0.0 MiB        1638           current = open_set.get()[2]
    55     71.5 MiB      0.0 MiB        1638           open_set_hash.remove(current)
    56                                         
    57     71.5 MiB      0.0 MiB        1638           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.5 MiB      0.0 MiB        1638           if current == end:
    62     71.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.5 MiB      0.0 MiB       14733           for neighbor in current.neighbors:
    67     71.5 MiB      0.0 MiB       13096               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.5 MiB      0.0 MiB        6548                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.5 MiB      0.0 MiB        6548                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.5 MiB      0.0 MiB       13096               if temp_g_score < g_score[neighbor]:
    73     71.5 MiB      0.0 MiB        1940                   came_from[neighbor] = current
    74     71.5 MiB      0.0 MiB        1940                   g_score[neighbor] = temp_g_score
    75     71.5 MiB      0.0 MiB        1940                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.5 MiB      0.0 MiB        1940                   if neighbor not in open_set_hash:
    77     71.5 MiB      0.0 MiB        1940                       count += 1
    78     71.5 MiB      0.0 MiB        1940                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.5 MiB      0.0 MiB        1940                       open_set_hash.add(neighbor)
    80                                                             
    81     71.5 MiB      0.0 MiB        1637           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.5 MiB      0.0 MiB        1637           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.5 MiB     71.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.5 MiB      0.0 MiB         129       for row in grid:
    32     71.5 MiB      0.0 MiB       16512           for spot in row:
    33     71.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.5 MiB      0.0 MiB           1       count = 0
    36     71.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.5 MiB      0.0 MiB           1       came_from = {}
    39     71.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.5 MiB      0.0 MiB         130       while not open_set.empty():
    49     71.5 MiB      0.0 MiB         130           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.5 MiB      0.0 MiB         130           current = open_set.get()[2]
    55     71.5 MiB      0.0 MiB         130           open_set_hash.remove(current)
    56                                         
    57     71.5 MiB      0.0 MiB         130           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.5 MiB      0.0 MiB         130           if current == end:
    62     71.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.5 MiB      0.0 MiB        1161           for neighbor in current.neighbors:
    67     71.5 MiB      0.0 MiB        1032               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.5 MiB      0.0 MiB         516                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.5 MiB      0.0 MiB         516                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.5 MiB      0.0 MiB        1032               if temp_g_score < g_score[neighbor]:
    73     71.5 MiB      0.0 MiB         266                   came_from[neighbor] = current
    74     71.5 MiB      0.0 MiB         266                   g_score[neighbor] = temp_g_score
    75     71.5 MiB      0.0 MiB         266                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.5 MiB      0.0 MiB         266                   if neighbor not in open_set_hash:
    77     71.5 MiB      0.0 MiB         266                       count += 1
    78     71.5 MiB      0.0 MiB         266                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.5 MiB      0.0 MiB         266                       open_set_hash.add(neighbor)
    80                                                             
    81     71.5 MiB      0.0 MiB         129           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.5 MiB      0.0 MiB         129           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.5 MiB     70.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.5 MiB      0.0 MiB         129       for row in grid:
    32     70.5 MiB      0.0 MiB       16512           for spot in row:
    33     70.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.5 MiB      0.0 MiB           1       count = 0
    36     70.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.5 MiB      0.0 MiB           1       came_from = {}
    39     70.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.5 MiB      0.0 MiB        2068       while not open_set.empty():
    49     70.5 MiB      0.0 MiB        2068           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.5 MiB      0.0 MiB        2068           current = open_set.get()[2]
    55     70.5 MiB      0.0 MiB        2068           open_set_hash.remove(current)
    56                                         
    57     70.5 MiB      0.0 MiB        2068           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.5 MiB      0.0 MiB        2068           if current == end:
    62     70.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.5 MiB      0.0 MiB       18603           for neighbor in current.neighbors:
    67     70.5 MiB      0.0 MiB       16536               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.5 MiB      0.0 MiB        8268                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.5 MiB      0.0 MiB        8268                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.5 MiB      0.0 MiB       16536               if temp_g_score < g_score[neighbor]:
    73     70.5 MiB      0.0 MiB        2342                   came_from[neighbor] = current
    74     70.5 MiB      0.0 MiB        2342                   g_score[neighbor] = temp_g_score
    75     70.5 MiB      0.0 MiB        2342                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.5 MiB      0.0 MiB        2342                   if neighbor not in open_set_hash:
    77     70.5 MiB      0.0 MiB        2342                       count += 1
    78     70.5 MiB      0.0 MiB        2342                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.5 MiB      0.0 MiB        2342                       open_set_hash.add(neighbor)
    80                                                             
    81     70.5 MiB      0.0 MiB        2067           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.5 MiB      0.0 MiB        2067           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.5 MiB     70.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.5 MiB      0.0 MiB         129       for row in grid:
    32     70.5 MiB      0.0 MiB       16512           for spot in row:
    33     70.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.5 MiB      0.0 MiB           1       count = 0
    36     70.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.5 MiB      0.0 MiB           1       came_from = {}
    39     70.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.6 MiB      0.2 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.6 MiB      0.0 MiB          60       while not open_set.empty():
    49     70.6 MiB      0.0 MiB          60           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.6 MiB      0.0 MiB          60           current = open_set.get()[2]
    55     70.6 MiB      0.0 MiB          60           open_set_hash.remove(current)
    56                                         
    57     70.6 MiB      0.0 MiB          60           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.6 MiB      0.0 MiB          60           if current == end:
    62     70.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.6 MiB      0.0 MiB         531           for neighbor in current.neighbors:
    67     70.6 MiB      0.0 MiB         472               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.6 MiB      0.0 MiB         236                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.6 MiB      0.0 MiB         236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.6 MiB      0.0 MiB         472               if temp_g_score < g_score[neighbor]:
    73     70.6 MiB      0.0 MiB         110                   came_from[neighbor] = current
    74     70.6 MiB      0.0 MiB         110                   g_score[neighbor] = temp_g_score
    75     70.6 MiB      0.0 MiB         110                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.6 MiB      0.0 MiB         110                   if neighbor not in open_set_hash:
    77     70.6 MiB      0.0 MiB         110                       count += 1
    78     70.6 MiB      0.0 MiB         110                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.6 MiB      0.0 MiB         110                       open_set_hash.add(neighbor)
    80                                                             
    81     70.6 MiB      0.0 MiB          59           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.6 MiB      0.0 MiB          59           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.6 MiB     70.6 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.6 MiB      0.0 MiB         129       for row in grid:
    32     70.6 MiB      0.0 MiB       16512           for spot in row:
    33     70.6 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.6 MiB      0.0 MiB           1       count = 0
    36     70.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.6 MiB      0.0 MiB           1       came_from = {}
    39     70.6 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.6 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.6 MiB      0.0 MiB         330       while not open_set.empty():
    49     70.6 MiB      0.0 MiB         330           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.6 MiB      0.0 MiB         330           current = open_set.get()[2]
    55     70.6 MiB      0.0 MiB         330           open_set_hash.remove(current)
    56                                         
    57     70.6 MiB      0.0 MiB         330           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.6 MiB      0.0 MiB         330           if current == end:
    62     70.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.6 MiB      0.0 MiB        2961           for neighbor in current.neighbors:
    67     70.6 MiB      0.0 MiB        2632               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.6 MiB      0.0 MiB        1316                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.6 MiB      0.0 MiB        1316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.6 MiB      0.0 MiB        2632               if temp_g_score < g_score[neighbor]:
    73     70.6 MiB      0.0 MiB         560                   came_from[neighbor] = current
    74     70.6 MiB      0.0 MiB         560                   g_score[neighbor] = temp_g_score
    75     70.6 MiB      0.0 MiB         560                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.6 MiB      0.0 MiB         560                   if neighbor not in open_set_hash:
    77     70.6 MiB      0.0 MiB         560                       count += 1
    78     70.6 MiB      0.0 MiB         560                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.6 MiB      0.0 MiB         560                       open_set_hash.add(neighbor)
    80                                                             
    81     70.6 MiB      0.0 MiB         329           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.6 MiB      0.0 MiB         329           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.4 MiB     71.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.4 MiB      0.0 MiB         129       for row in grid:
    32     71.4 MiB      0.0 MiB       16512           for spot in row:
    33     71.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.4 MiB      0.0 MiB           1       count = 0
    36     71.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.4 MiB      0.0 MiB           1       came_from = {}
    39     71.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.6 MiB      0.2 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.6 MiB      0.0 MiB          36       while not open_set.empty():
    49     71.6 MiB      0.0 MiB          36           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.6 MiB      0.0 MiB          36           current = open_set.get()[2]
    55     71.6 MiB      0.0 MiB          36           open_set_hash.remove(current)
    56                                         
    57     71.6 MiB      0.0 MiB          36           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.6 MiB      0.0 MiB          36           if current == end:
    62     71.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.6 MiB      0.0 MiB         315           for neighbor in current.neighbors:
    67     71.6 MiB      0.0 MiB         280               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.6 MiB      0.0 MiB         140                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.6 MiB      0.0 MiB         140                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.6 MiB      0.0 MiB         280               if temp_g_score < g_score[neighbor]:
    73     71.6 MiB      0.0 MiB          70                   came_from[neighbor] = current
    74     71.6 MiB      0.0 MiB          70                   g_score[neighbor] = temp_g_score
    75     71.6 MiB      0.0 MiB          70                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.6 MiB      0.0 MiB          70                   if neighbor not in open_set_hash:
    77     71.6 MiB      0.0 MiB          70                       count += 1
    78     71.6 MiB      0.0 MiB          70                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.6 MiB      0.0 MiB          70                       open_set_hash.add(neighbor)
    80                                                             
    81     71.6 MiB      0.0 MiB          35           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.6 MiB      0.0 MiB          35           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.6 MiB     71.6 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.6 MiB      0.0 MiB         129       for row in grid:
    32     71.6 MiB      0.0 MiB       16512           for spot in row:
    33     71.6 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.6 MiB      0.0 MiB           1       count = 0
    36     71.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.6 MiB      0.0 MiB           1       came_from = {}
    39     71.6 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.6 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.6 MiB      0.0 MiB        3024       while not open_set.empty():
    49     71.6 MiB      0.0 MiB        3024           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.6 MiB      0.0 MiB        3024           current = open_set.get()[2]
    55     71.6 MiB      0.0 MiB        3024           open_set_hash.remove(current)
    56                                         
    57     71.6 MiB      0.0 MiB        3024           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.6 MiB      0.0 MiB        3024           if current == end:
    62     71.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.6 MiB      0.0 MiB       27207           for neighbor in current.neighbors:
    67     71.6 MiB      0.0 MiB       24184               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.6 MiB      0.0 MiB       12092                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.6 MiB      0.0 MiB       12092                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.6 MiB      0.0 MiB       24184               if temp_g_score < g_score[neighbor]:
    73     71.6 MiB      0.0 MiB        3430                   came_from[neighbor] = current
    74     71.6 MiB      0.0 MiB        3430                   g_score[neighbor] = temp_g_score
    75     71.6 MiB      0.0 MiB        3430                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.6 MiB      0.0 MiB        3430                   if neighbor not in open_set_hash:
    77     71.6 MiB      0.0 MiB        3430                       count += 1
    78     71.6 MiB      0.0 MiB        3430                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.6 MiB      0.0 MiB        3430                       open_set_hash.add(neighbor)
    80                                                             
    81     71.6 MiB      0.0 MiB        3023           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.6 MiB      0.0 MiB        3023           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.6 MiB     71.6 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.6 MiB      0.0 MiB         129       for row in grid:
    32     71.6 MiB      0.0 MiB       16512           for spot in row:
    33     71.6 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.6 MiB      0.0 MiB           1       count = 0
    36     71.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.6 MiB      0.0 MiB           1       came_from = {}
    39     71.6 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.6 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.6 MiB      0.0 MiB         165       while not open_set.empty():
    49     71.6 MiB      0.0 MiB         165           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.6 MiB      0.0 MiB         165           current = open_set.get()[2]
    55     71.6 MiB      0.0 MiB         165           open_set_hash.remove(current)
    56                                         
    57     71.6 MiB      0.0 MiB         165           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.6 MiB      0.0 MiB         165           if current == end:
    62     71.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.6 MiB      0.0 MiB        1476           for neighbor in current.neighbors:
    67     71.6 MiB      0.0 MiB        1312               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.6 MiB      0.0 MiB         656                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.6 MiB      0.0 MiB         656                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.6 MiB      0.0 MiB        1312               if temp_g_score < g_score[neighbor]:
    73     71.6 MiB      0.0 MiB         389                   came_from[neighbor] = current
    74     71.6 MiB      0.0 MiB         389                   g_score[neighbor] = temp_g_score
    75     71.6 MiB      0.0 MiB         389                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.6 MiB      0.0 MiB         389                   if neighbor not in open_set_hash:
    77     71.6 MiB      0.0 MiB         389                       count += 1
    78     71.6 MiB      0.0 MiB         389                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.6 MiB      0.0 MiB         389                       open_set_hash.add(neighbor)
    80                                                             
    81     71.6 MiB      0.0 MiB         164           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.6 MiB      0.0 MiB         164           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.6 MiB     71.6 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.6 MiB      0.0 MiB         129       for row in grid:
    32     71.6 MiB      0.0 MiB       16512           for spot in row:
    33     71.6 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.6 MiB      0.0 MiB           1       count = 0
    36     71.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.6 MiB      0.0 MiB           1       came_from = {}
    39     71.6 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.6 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.6 MiB      0.0 MiB         704       while not open_set.empty():
    49     71.6 MiB      0.0 MiB         704           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.6 MiB      0.0 MiB         704           current = open_set.get()[2]
    55     71.6 MiB      0.0 MiB         704           open_set_hash.remove(current)
    56                                         
    57     71.6 MiB      0.0 MiB         704           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.6 MiB      0.0 MiB         704           if current == end:
    62     71.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.6 MiB      0.0 MiB        6327           for neighbor in current.neighbors:
    67     71.6 MiB      0.0 MiB        5624               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.6 MiB      0.0 MiB        2812                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.6 MiB      0.0 MiB        2812                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.6 MiB      0.0 MiB        5624               if temp_g_score < g_score[neighbor]:
    73     71.6 MiB      0.0 MiB         854                   came_from[neighbor] = current
    74     71.6 MiB      0.0 MiB         854                   g_score[neighbor] = temp_g_score
    75     71.6 MiB      0.0 MiB         854                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.6 MiB      0.0 MiB         854                   if neighbor not in open_set_hash:
    77     71.6 MiB      0.0 MiB         854                       count += 1
    78     71.6 MiB      0.0 MiB         854                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.6 MiB      0.0 MiB         854                       open_set_hash.add(neighbor)
    80                                                             
    81     71.6 MiB      0.0 MiB         703           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.6 MiB      0.0 MiB         703           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.6 MiB     71.6 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.6 MiB      0.0 MiB         129       for row in grid:
    32     71.6 MiB      0.0 MiB       16512           for spot in row:
    33     71.6 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.6 MiB      0.0 MiB           1       count = 0
    36     71.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.6 MiB      0.0 MiB           1       came_from = {}
    39     71.6 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.6 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.6 MiB      0.0 MiB        1428       while not open_set.empty():
    49     71.6 MiB      0.0 MiB        1428           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.6 MiB      0.0 MiB        1428           current = open_set.get()[2]
    55     71.6 MiB      0.0 MiB        1428           open_set_hash.remove(current)
    56                                         
    57     71.6 MiB      0.0 MiB        1428           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.6 MiB      0.0 MiB        1428           if current == end:
    62     71.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.6 MiB      0.0 MiB       12843           for neighbor in current.neighbors:
    67     71.6 MiB      0.0 MiB       11416               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.6 MiB      0.0 MiB        5708                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.6 MiB      0.0 MiB        5708                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.6 MiB      0.0 MiB       11416               if temp_g_score < g_score[neighbor]:
    73     71.6 MiB      0.0 MiB        1796                   came_from[neighbor] = current
    74     71.6 MiB      0.0 MiB        1796                   g_score[neighbor] = temp_g_score
    75     71.6 MiB      0.0 MiB        1796                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.6 MiB      0.0 MiB        1796                   if neighbor not in open_set_hash:
    77     71.6 MiB      0.0 MiB        1796                       count += 1
    78     71.6 MiB      0.0 MiB        1796                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.6 MiB      0.0 MiB        1796                       open_set_hash.add(neighbor)
    80                                                             
    81     71.6 MiB      0.0 MiB        1427           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.6 MiB      0.0 MiB        1427           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.6 MiB     71.6 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.6 MiB      0.0 MiB         129       for row in grid:
    32     71.6 MiB      0.0 MiB       16512           for spot in row:
    33     71.6 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.6 MiB      0.0 MiB           1       count = 0
    36     71.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.6 MiB      0.0 MiB           1       came_from = {}
    39     71.6 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.6 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.6 MiB      0.0 MiB           8       while not open_set.empty():
    49     71.6 MiB      0.0 MiB           8           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.6 MiB      0.0 MiB           8           current = open_set.get()[2]
    55     71.6 MiB      0.0 MiB           8           open_set_hash.remove(current)
    56                                         
    57     71.6 MiB      0.0 MiB           8           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.6 MiB      0.0 MiB           8           if current == end:
    62     71.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.6 MiB      0.0 MiB          63           for neighbor in current.neighbors:
    67     71.6 MiB      0.0 MiB          56               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.6 MiB      0.0 MiB          28                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.6 MiB      0.0 MiB          28                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.6 MiB      0.0 MiB          56               if temp_g_score < g_score[neighbor]:
    73     71.6 MiB      0.0 MiB          26                   came_from[neighbor] = current
    74     71.6 MiB      0.0 MiB          26                   g_score[neighbor] = temp_g_score
    75     71.6 MiB      0.0 MiB          26                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.6 MiB      0.0 MiB          26                   if neighbor not in open_set_hash:
    77     71.6 MiB      0.0 MiB          26                       count += 1
    78     71.6 MiB      0.0 MiB          26                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.6 MiB      0.0 MiB          26                       open_set_hash.add(neighbor)
    80                                                             
    81     71.6 MiB      0.0 MiB           7           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.6 MiB      0.0 MiB           7           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.6 MiB     71.6 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.6 MiB      0.0 MiB         129       for row in grid:
    32     71.6 MiB      0.0 MiB       16512           for spot in row:
    33     71.6 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.6 MiB      0.0 MiB           1       count = 0
    36     71.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.6 MiB      0.0 MiB           1       came_from = {}
    39     71.6 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.6 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.6 MiB      0.0 MiB         345       while not open_set.empty():
    49     71.6 MiB      0.0 MiB         345           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.6 MiB      0.0 MiB         345           current = open_set.get()[2]
    55     71.6 MiB      0.0 MiB         345           open_set_hash.remove(current)
    56                                         
    57     71.6 MiB      0.0 MiB         345           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.6 MiB      0.0 MiB         345           if current == end:
    62     71.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.6 MiB      0.0 MiB        3096           for neighbor in current.neighbors:
    67     71.6 MiB      0.0 MiB        2752               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.6 MiB      0.0 MiB        1376                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.6 MiB      0.0 MiB        1376                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.6 MiB      0.0 MiB        2752               if temp_g_score < g_score[neighbor]:
    73     71.6 MiB      0.0 MiB         449                   came_from[neighbor] = current
    74     71.6 MiB      0.0 MiB         449                   g_score[neighbor] = temp_g_score
    75     71.6 MiB      0.0 MiB         449                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.6 MiB      0.0 MiB         449                   if neighbor not in open_set_hash:
    77     71.6 MiB      0.0 MiB         449                       count += 1
    78     71.6 MiB      0.0 MiB         449                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.6 MiB      0.0 MiB         449                       open_set_hash.add(neighbor)
    80                                                             
    81     71.6 MiB      0.0 MiB         344           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.6 MiB      0.0 MiB         344           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.6 MiB     71.6 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.6 MiB      0.0 MiB         129       for row in grid:
    32     71.6 MiB      0.0 MiB       16512           for spot in row:
    33     71.6 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.6 MiB      0.0 MiB           1       count = 0
    36     71.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.6 MiB      0.0 MiB           1       came_from = {}
    39     71.6 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.6 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB          27       while not open_set.empty():
    49     72.2 MiB      0.0 MiB          27           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB          27           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB          27           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB          27           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB          27           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB         234           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB         208               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB         104                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB         104                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB         208               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB          83                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB          83                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB          83                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB          83                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB          83                       count += 1
    78     72.2 MiB      0.0 MiB          83                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB          83                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB          26           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB          26           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB         154       while not open_set.empty():
    49     72.2 MiB      0.0 MiB         154           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB         154           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB         154           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB         154           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB         154           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB        1377           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB        1224               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB         612                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB         612                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB        1224               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB         224                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB         224                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB         224                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB         224                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB         224                       count += 1
    78     72.2 MiB      0.0 MiB         224                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB         224                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB         153           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB         153           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB         589       while not open_set.empty():
    49     72.2 MiB      0.0 MiB         589           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB         589           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB         589           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB         589           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB         589           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB        5292           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB        4704               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB        2352                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB        2352                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB        4704               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB         749                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB         749                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB         749                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB         749                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB         749                       count += 1
    78     72.2 MiB      0.0 MiB         749                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB         749                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB         588           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB         588           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB        2024       while not open_set.empty():
    49     72.2 MiB      0.0 MiB        2024           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB        2024           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB        2024           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB        2024           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB        2024           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB       18204           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB       16181               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB        8090                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB        8091                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB       16181               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB        2291                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB        2291                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB        2291                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB        2291                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB        2291                       count += 1
    78     72.2 MiB      0.0 MiB        2291                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB        2291                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB        2023           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB        2023           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB         740       while not open_set.empty():
    49     72.2 MiB      0.0 MiB         740           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB         740           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB         740           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB         740           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB         740           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB        6651           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB        5912               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB        2956                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB        2956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB        5912               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB        1054                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB        1054                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB        1054                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB        1054                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB        1054                       count += 1
    78     72.2 MiB      0.0 MiB        1054                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB        1054                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB         739           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB         739           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB         120       while not open_set.empty():
    49     72.2 MiB      0.0 MiB         120           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB         120           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB         120           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB         120           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB         120           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB        1071           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB         952               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB         476                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB         476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB         952               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB         246                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB         246                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB         246                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB         246                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB         246                       count += 1
    78     72.2 MiB      0.0 MiB         246                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB         246                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB         119           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB         119           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB        1672       while not open_set.empty():
    49     72.2 MiB      0.0 MiB        1672           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB        1672           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB        1672           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB        1672           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB        1672           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB       15039           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB       13368               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB        6684                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB        6684                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB       13368               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB        1922                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB        1922                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB        1922                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB        1922                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB        1922                       count += 1
    78     72.2 MiB      0.0 MiB        1922                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB        1922                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB        1671           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB        1671           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB         282       while not open_set.empty():
    49     72.2 MiB      0.0 MiB         282           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB         282           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB         282           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB         282           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB         282           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB        2529           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB        2248               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB        1124                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB        1124                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB        2248               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB         480                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB         480                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB         480                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB         480                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB         480                       count += 1
    78     72.2 MiB      0.0 MiB         480                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB         480                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB         281           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB         281           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB        2116       while not open_set.empty():
    49     72.2 MiB      0.0 MiB        2116           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB        2116           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB        2116           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB        2116           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB        2116           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB       19035           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB       16920               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB        8460                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB        8460                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB       16920               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB        2390                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB        2390                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB        2390                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB        2390                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB        2390                       count += 1
    78     72.2 MiB      0.0 MiB        2390                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB        2390                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB        2115           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB        2115           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB           8       while not open_set.empty():
    49     72.2 MiB      0.0 MiB           8           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB           8           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB           8           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB           8           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB           8           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB          63           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB          56               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB          28                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB          28                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB          56               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB          26                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB          26                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB          26                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB          26                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB          26                       count += 1
    78     72.2 MiB      0.0 MiB          26                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB          26                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB           7           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB           7           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB         435       while not open_set.empty():
    49     72.2 MiB      0.0 MiB         435           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB         435           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB         435           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB         435           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB         435           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB        3906           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB        3472               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB        1736                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB        1736                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB        3472               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB         627                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB         627                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB         627                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB         627                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB         627                       count += 1
    78     72.2 MiB      0.0 MiB         627                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB         627                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB         434           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB         434           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB         410       while not open_set.empty():
    49     72.2 MiB      0.0 MiB         410           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB         410           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB         410           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB         410           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB         410           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB        3681           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB        3272               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB        1636                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB        1636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB        3272               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB         592                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB         592                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB         592                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB         592                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB         592                       count += 1
    78     72.2 MiB      0.0 MiB         592                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB         592                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB         409           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB         409           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB         782       while not open_set.empty():
    49     72.2 MiB      0.0 MiB         782           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB         782           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB         782           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB         782           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB         782           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB        7029           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB        6248               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB        3124                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB        3124                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB        6248               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB         940                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB         940                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB         940                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB         940                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB         940                       count += 1
    78     72.2 MiB      0.0 MiB         940                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB         940                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB         781           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB         781           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.8 MiB      0.6 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.8 MiB      0.0 MiB          96       while not open_set.empty():
    49     72.8 MiB      0.0 MiB          96           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.8 MiB      0.0 MiB          96           current = open_set.get()[2]
    55     72.8 MiB      0.0 MiB          96           open_set_hash.remove(current)
    56                                         
    57     72.8 MiB      0.0 MiB          96           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.8 MiB      0.0 MiB          96           if current == end:
    62     72.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.8 MiB      0.0 MiB         855           for neighbor in current.neighbors:
    67     72.8 MiB      0.0 MiB         760               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.8 MiB      0.0 MiB         380                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.8 MiB      0.0 MiB         380                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.8 MiB      0.0 MiB         760               if temp_g_score < g_score[neighbor]:
    73     72.8 MiB      0.0 MiB         158                   came_from[neighbor] = current
    74     72.8 MiB      0.0 MiB         158                   g_score[neighbor] = temp_g_score
    75     72.8 MiB      0.0 MiB         158                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.8 MiB      0.0 MiB         158                   if neighbor not in open_set_hash:
    77     72.8 MiB      0.0 MiB         158                       count += 1
    78     72.8 MiB      0.0 MiB         158                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.8 MiB      0.0 MiB         158                       open_set_hash.add(neighbor)
    80                                                             
    81     72.8 MiB      0.0 MiB          95           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.8 MiB      0.0 MiB          95           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.8 MiB     72.8 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.8 MiB      0.0 MiB         129       for row in grid:
    32     72.8 MiB      0.0 MiB       16512           for spot in row:
    33     72.8 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.8 MiB      0.0 MiB           1       count = 0
    36     72.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.8 MiB      0.0 MiB           1       came_from = {}
    39     72.8 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.8 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.8 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.8 MiB      0.0 MiB         495       while not open_set.empty():
    49     72.8 MiB      0.0 MiB         495           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.8 MiB      0.0 MiB         495           current = open_set.get()[2]
    55     72.8 MiB      0.0 MiB         495           open_set_hash.remove(current)
    56                                         
    57     72.8 MiB      0.0 MiB         495           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.8 MiB      0.0 MiB         495           if current == end:
    62     72.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.8 MiB      0.0 MiB        4446           for neighbor in current.neighbors:
    67     72.8 MiB      0.0 MiB        3952               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.8 MiB      0.0 MiB        1976                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.8 MiB      0.0 MiB        1976                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.8 MiB      0.0 MiB        3952               if temp_g_score < g_score[neighbor]:
    73     72.8 MiB      0.0 MiB         655                   came_from[neighbor] = current
    74     72.8 MiB      0.0 MiB         655                   g_score[neighbor] = temp_g_score
    75     72.8 MiB      0.0 MiB         655                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.8 MiB      0.0 MiB         655                   if neighbor not in open_set_hash:
    77     72.8 MiB      0.0 MiB         655                       count += 1
    78     72.8 MiB      0.0 MiB         655                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.8 MiB      0.0 MiB         655                       open_set_hash.add(neighbor)
    80                                                             
    81     72.8 MiB      0.0 MiB         494           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.8 MiB      0.0 MiB         494           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.8 MiB     72.8 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.8 MiB      0.0 MiB         129       for row in grid:
    32     72.8 MiB      0.0 MiB       16512           for spot in row:
    33     72.8 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.8 MiB      0.0 MiB           1       count = 0
    36     72.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.8 MiB      0.0 MiB           1       came_from = {}
    39     72.8 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.8 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.8 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.8 MiB      0.0 MiB         160       while not open_set.empty():
    49     72.8 MiB      0.0 MiB         160           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.8 MiB      0.0 MiB         160           current = open_set.get()[2]
    55     72.8 MiB      0.0 MiB         160           open_set_hash.remove(current)
    56                                         
    57     72.8 MiB      0.0 MiB         160           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.8 MiB      0.0 MiB         160           if current == end:
    62     72.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.8 MiB      0.0 MiB        1431           for neighbor in current.neighbors:
    67     72.8 MiB      0.0 MiB        1272               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.8 MiB      0.0 MiB         636                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.8 MiB      0.0 MiB         636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.8 MiB      0.0 MiB        1272               if temp_g_score < g_score[neighbor]:
    73     72.8 MiB      0.0 MiB         242                   came_from[neighbor] = current
    74     72.8 MiB      0.0 MiB         242                   g_score[neighbor] = temp_g_score
    75     72.8 MiB      0.0 MiB         242                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.8 MiB      0.0 MiB         242                   if neighbor not in open_set_hash:
    77     72.8 MiB      0.0 MiB         242                       count += 1
    78     72.8 MiB      0.0 MiB         242                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.8 MiB      0.0 MiB         242                       open_set_hash.add(neighbor)
    80                                                             
    81     72.8 MiB      0.0 MiB         159           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.8 MiB      0.0 MiB         159           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.8 MiB     72.8 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.8 MiB    -10.9 MiB         129       for row in grid:
    32     72.8 MiB  -1397.6 MiB       16512           for spot in row:
    33     72.8 MiB  -1387.2 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.1 MiB     -0.7 MiB           1       count = 0
    36     72.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.1 MiB      0.0 MiB           1       came_from = {}
    39     72.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.1 MiB      0.0 MiB        2848       while not open_set.empty():
    49     72.1 MiB      0.0 MiB        2848           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.1 MiB      0.0 MiB        2848           current = open_set.get()[2]
    55     72.1 MiB      0.0 MiB        2848           open_set_hash.remove(current)
    56                                         
    57     72.1 MiB      0.0 MiB        2848           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.1 MiB      0.0 MiB        2848           if current == end:
    62     72.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.1 MiB      0.0 MiB       25623           for neighbor in current.neighbors:
    67     72.1 MiB      0.0 MiB       22776               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.1 MiB      0.0 MiB       11388                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.1 MiB      0.0 MiB       11388                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.1 MiB      0.0 MiB       22776               if temp_g_score < g_score[neighbor]:
    73     72.1 MiB      0.0 MiB        3266                   came_from[neighbor] = current
    74     72.1 MiB      0.0 MiB        3266                   g_score[neighbor] = temp_g_score
    75     72.1 MiB      0.0 MiB        3266                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.1 MiB      0.0 MiB        3266                   if neighbor not in open_set_hash:
    77     72.1 MiB      0.0 MiB        3266                       count += 1
    78     72.1 MiB      0.0 MiB        3266                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.1 MiB      0.0 MiB        3266                       open_set_hash.add(neighbor)
    80                                                             
    81     72.1 MiB      0.0 MiB        2847           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.1 MiB      0.0 MiB        2847           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.1 MiB     72.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.1 MiB      0.0 MiB         129       for row in grid:
    32     72.1 MiB      0.0 MiB       16512           for spot in row:
    33     72.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.1 MiB      0.0 MiB           1       count = 0
    36     72.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.1 MiB      0.0 MiB           1       came_from = {}
    39     72.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.1 MiB      0.0 MiB         378       while not open_set.empty():
    49     72.1 MiB      0.0 MiB         378           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.1 MiB      0.0 MiB         378           current = open_set.get()[2]
    55     72.1 MiB      0.0 MiB         378           open_set_hash.remove(current)
    56                                         
    57     72.1 MiB      0.0 MiB         378           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.1 MiB      0.0 MiB         378           if current == end:
    62     72.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.1 MiB      0.0 MiB        3393           for neighbor in current.neighbors:
    67     72.1 MiB      0.0 MiB        3016               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.1 MiB      0.0 MiB        1508                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.1 MiB      0.0 MiB        1508                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.1 MiB      0.0 MiB        3016               if temp_g_score < g_score[neighbor]:
    73     72.1 MiB      0.0 MiB         526                   came_from[neighbor] = current
    74     72.1 MiB      0.0 MiB         526                   g_score[neighbor] = temp_g_score
    75     72.1 MiB      0.0 MiB         526                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.1 MiB      0.0 MiB         526                   if neighbor not in open_set_hash:
    77     72.1 MiB      0.0 MiB         526                       count += 1
    78     72.1 MiB      0.0 MiB         526                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.1 MiB      0.0 MiB         526                       open_set_hash.add(neighbor)
    80                                                             
    81     72.1 MiB      0.0 MiB         377           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.1 MiB      0.0 MiB         377           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.1 MiB     72.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.1 MiB    -97.4 MiB         129       for row in grid:
    32     72.1 MiB -12439.3 MiB       16512           for spot in row:
    33     72.1 MiB -12342.8 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.8 MiB     -1.3 MiB           1       count = 0
    36     70.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.8 MiB      0.0 MiB           1       came_from = {}
    39     70.8 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.8 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.8 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.8 MiB      0.0 MiB          24       while not open_set.empty():
    49     70.8 MiB      0.0 MiB          24           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.8 MiB      0.0 MiB          24           current = open_set.get()[2]
    55     70.8 MiB      0.0 MiB          24           open_set_hash.remove(current)
    56                                         
    57     70.8 MiB      0.0 MiB          24           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.8 MiB      0.0 MiB          24           if current == end:
    62     70.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.8 MiB      0.0 MiB         207           for neighbor in current.neighbors:
    67     70.8 MiB      0.0 MiB         184               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.8 MiB      0.0 MiB          92                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.8 MiB      0.0 MiB          92                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.8 MiB      0.0 MiB         184               if temp_g_score < g_score[neighbor]:
    73     70.8 MiB      0.0 MiB          50                   came_from[neighbor] = current
    74     70.8 MiB      0.0 MiB          50                   g_score[neighbor] = temp_g_score
    75     70.8 MiB      0.0 MiB          50                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.8 MiB      0.0 MiB          50                   if neighbor not in open_set_hash:
    77     70.8 MiB      0.0 MiB          50                       count += 1
    78     70.8 MiB      0.0 MiB          50                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.8 MiB      0.0 MiB          50                       open_set_hash.add(neighbor)
    80                                                             
    81     70.8 MiB      0.0 MiB          23           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.8 MiB      0.0 MiB          23           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.8 MiB     70.8 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.8 MiB      0.0 MiB         129       for row in grid:
    32     70.8 MiB      0.0 MiB       16512           for spot in row:
    33     70.8 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.8 MiB      0.0 MiB           1       count = 0
    36     70.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.8 MiB      0.0 MiB           1       came_from = {}
    39     70.8 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.8 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.8 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.8 MiB      0.0 MiB        1026       while not open_set.empty():
    49     70.8 MiB      0.0 MiB        1026           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.8 MiB      0.0 MiB        1026           current = open_set.get()[2]
    55     70.8 MiB      0.0 MiB        1026           open_set_hash.remove(current)
    56                                         
    57     70.8 MiB      0.0 MiB        1026           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.8 MiB      0.0 MiB        1026           if current == end:
    62     70.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.8 MiB      0.0 MiB        9225           for neighbor in current.neighbors:
    67     70.8 MiB      0.0 MiB        8200               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.8 MiB      0.0 MiB        4100                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.8 MiB      0.0 MiB        4100                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.8 MiB      0.0 MiB        8200               if temp_g_score < g_score[neighbor]:
    73     70.8 MiB      0.0 MiB        1230                   came_from[neighbor] = current
    74     70.8 MiB      0.0 MiB        1230                   g_score[neighbor] = temp_g_score
    75     70.8 MiB      0.0 MiB        1230                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.8 MiB      0.0 MiB        1230                   if neighbor not in open_set_hash:
    77     70.8 MiB      0.0 MiB        1230                       count += 1
    78     70.8 MiB      0.0 MiB        1230                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.8 MiB      0.0 MiB        1230                       open_set_hash.add(neighbor)
    80                                                             
    81     70.8 MiB      0.0 MiB        1025           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.8 MiB      0.0 MiB        1025           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.8 MiB     70.8 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.8 MiB      0.0 MiB         129       for row in grid:
    32     70.8 MiB      0.0 MiB       16512           for spot in row:
    33     70.8 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.8 MiB      0.0 MiB           1       count = 0
    36     70.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.8 MiB      0.0 MiB           1       came_from = {}
    39     70.8 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.8 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.6 MiB      0.7 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.6 MiB      0.0 MiB         148       while not open_set.empty():
    49     71.6 MiB      0.0 MiB         148           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.6 MiB      0.0 MiB         148           current = open_set.get()[2]
    55     71.6 MiB      0.0 MiB         148           open_set_hash.remove(current)
    56                                         
    57     71.6 MiB      0.0 MiB         148           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.6 MiB      0.0 MiB         148           if current == end:
    62     71.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.6 MiB      0.0 MiB        1323           for neighbor in current.neighbors:
    67     71.6 MiB      0.0 MiB        1176               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.6 MiB      0.0 MiB         588                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.6 MiB      0.0 MiB         588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.6 MiB      0.0 MiB        1176               if temp_g_score < g_score[neighbor]:
    73     71.6 MiB      0.0 MiB         302                   came_from[neighbor] = current
    74     71.6 MiB      0.0 MiB         302                   g_score[neighbor] = temp_g_score
    75     71.6 MiB      0.0 MiB         302                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.6 MiB      0.0 MiB         302                   if neighbor not in open_set_hash:
    77     71.6 MiB      0.0 MiB         302                       count += 1
    78     71.6 MiB      0.0 MiB         302                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.6 MiB      0.0 MiB         302                       open_set_hash.add(neighbor)
    80                                                             
    81     71.6 MiB      0.0 MiB         147           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.6 MiB      0.0 MiB         147           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.6 MiB     71.6 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.6 MiB      0.0 MiB         129       for row in grid:
    32     71.6 MiB      0.0 MiB       16512           for spot in row:
    33     71.6 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.6 MiB      0.0 MiB           1       count = 0
    36     71.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.6 MiB      0.0 MiB           1       came_from = {}
    39     71.6 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.6 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.6 MiB      0.0 MiB         585       while not open_set.empty():
    49     71.6 MiB      0.0 MiB         585           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.6 MiB      0.0 MiB         585           current = open_set.get()[2]
    55     71.6 MiB      0.0 MiB         585           open_set_hash.remove(current)
    56                                         
    57     71.6 MiB      0.0 MiB         585           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.6 MiB      0.0 MiB         585           if current == end:
    62     71.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.6 MiB      0.0 MiB        5256           for neighbor in current.neighbors:
    67     71.6 MiB      0.0 MiB        4672               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.6 MiB      0.0 MiB        2336                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.6 MiB      0.0 MiB        2336                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.6 MiB      0.0 MiB        4672               if temp_g_score < g_score[neighbor]:
    73     71.6 MiB      0.0 MiB         769                   came_from[neighbor] = current
    74     71.6 MiB      0.0 MiB         769                   g_score[neighbor] = temp_g_score
    75     71.6 MiB      0.0 MiB         769                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.6 MiB      0.0 MiB         769                   if neighbor not in open_set_hash:
    77     71.6 MiB      0.0 MiB         769                       count += 1
    78     71.6 MiB      0.0 MiB         769                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.6 MiB      0.0 MiB         769                       open_set_hash.add(neighbor)
    80                                                             
    81     71.6 MiB      0.0 MiB         584           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.6 MiB      0.0 MiB         584           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     69.6 MiB     69.6 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     69.6 MiB      0.0 MiB         129       for row in grid:
    32     69.6 MiB      0.0 MiB       16512           for spot in row:
    33     69.6 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     69.6 MiB      0.0 MiB           1       count = 0
    36     69.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     69.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     69.6 MiB      0.0 MiB           1       came_from = {}
    39     69.6 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     69.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     69.6 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     69.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     69.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     69.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     69.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     69.6 MiB      0.0 MiB          33       while not open_set.empty():
    49     69.6 MiB      0.0 MiB          33           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     69.6 MiB      0.0 MiB          33           current = open_set.get()[2]
    55     69.6 MiB      0.0 MiB          33           open_set_hash.remove(current)
    56                                         
    57     69.6 MiB      0.0 MiB          33           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     69.6 MiB      0.0 MiB          33           if current == end:
    62     69.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     69.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     69.6 MiB      0.0 MiB         288           for neighbor in current.neighbors:
    67     69.6 MiB      0.0 MiB         256               if current.row != neighbor.row and current.col != neighbor.col:
    68     69.6 MiB      0.0 MiB         128                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     69.6 MiB      0.0 MiB         128                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     69.6 MiB      0.0 MiB         256               if temp_g_score < g_score[neighbor]:
    73     69.6 MiB      0.0 MiB          65                   came_from[neighbor] = current
    74     69.6 MiB      0.0 MiB          65                   g_score[neighbor] = temp_g_score
    75     69.6 MiB      0.0 MiB          65                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     69.6 MiB      0.0 MiB          65                   if neighbor not in open_set_hash:
    77     69.6 MiB      0.0 MiB          65                       count += 1
    78     69.6 MiB      0.0 MiB          65                       open_set.put((f_score[neighbor], count, neighbor))
    79     69.6 MiB      0.0 MiB          65                       open_set_hash.add(neighbor)
    80                                                             
    81     69.6 MiB      0.0 MiB          32           if draw is not None:
    82                                                     draw()
    83                                         
    84     69.6 MiB      0.0 MiB          32           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     69.6 MiB     69.6 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     69.6 MiB      0.0 MiB         129       for row in grid:
    32     69.6 MiB      0.0 MiB       16512           for spot in row:
    33     69.6 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     69.6 MiB      0.0 MiB           1       count = 0
    36     69.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     69.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     69.6 MiB      0.0 MiB           1       came_from = {}
    39     69.6 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     69.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     69.6 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     69.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     69.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     69.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     69.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     69.6 MiB      0.0 MiB         567       while not open_set.empty():
    49     69.6 MiB      0.0 MiB         567           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     69.6 MiB      0.0 MiB         567           current = open_set.get()[2]
    55     69.6 MiB      0.0 MiB         567           open_set_hash.remove(current)
    56                                         
    57     69.6 MiB      0.0 MiB         567           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     69.6 MiB      0.0 MiB         567           if current == end:
    62     69.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     69.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     69.6 MiB      0.0 MiB        5094           for neighbor in current.neighbors:
    67     69.6 MiB      0.0 MiB        4528               if current.row != neighbor.row and current.col != neighbor.col:
    68     69.6 MiB      0.0 MiB        2264                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     69.6 MiB      0.0 MiB        2264                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     69.6 MiB      0.0 MiB        4528               if temp_g_score < g_score[neighbor]:
    73     69.6 MiB      0.0 MiB         727                   came_from[neighbor] = current
    74     69.6 MiB      0.0 MiB         727                   g_score[neighbor] = temp_g_score
    75     69.6 MiB      0.0 MiB         727                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     69.6 MiB      0.0 MiB         727                   if neighbor not in open_set_hash:
    77     69.6 MiB      0.0 MiB         727                       count += 1
    78     69.6 MiB      0.0 MiB         727                       open_set.put((f_score[neighbor], count, neighbor))
    79     69.6 MiB      0.0 MiB         727                       open_set_hash.add(neighbor)
    80                                                             
    81     69.6 MiB      0.0 MiB         566           if draw is not None:
    82                                                     draw()
    83                                         
    84     69.6 MiB      0.0 MiB         566           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     68.6 MiB     68.6 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     68.6 MiB      0.0 MiB         129       for row in grid:
    32     68.6 MiB      0.0 MiB       16512           for spot in row:
    33     68.6 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     68.6 MiB      0.0 MiB           1       count = 0
    36     68.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     68.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     68.6 MiB      0.0 MiB           1       came_from = {}
    39     68.6 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     68.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     68.6 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     68.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     68.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     68.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     68.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     68.6 MiB      0.0 MiB         135       while not open_set.empty():
    49     68.6 MiB      0.0 MiB         135           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     68.6 MiB      0.0 MiB         135           current = open_set.get()[2]
    55     68.6 MiB      0.0 MiB         135           open_set_hash.remove(current)
    56                                         
    57     68.6 MiB      0.0 MiB         135           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     68.6 MiB      0.0 MiB         135           if current == end:
    62     68.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     68.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     68.6 MiB      0.0 MiB        1206           for neighbor in current.neighbors:
    67     68.6 MiB      0.0 MiB        1072               if current.row != neighbor.row and current.col != neighbor.col:
    68     68.6 MiB      0.0 MiB         536                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     68.6 MiB      0.0 MiB         536                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     68.6 MiB      0.0 MiB        1072               if temp_g_score < g_score[neighbor]:
    73     68.6 MiB      0.0 MiB         207                   came_from[neighbor] = current
    74     68.6 MiB      0.0 MiB         207                   g_score[neighbor] = temp_g_score
    75     68.6 MiB      0.0 MiB         207                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     68.6 MiB      0.0 MiB         207                   if neighbor not in open_set_hash:
    77     68.6 MiB      0.0 MiB         207                       count += 1
    78     68.6 MiB      0.0 MiB         207                       open_set.put((f_score[neighbor], count, neighbor))
    79     68.6 MiB      0.0 MiB         207                       open_set_hash.add(neighbor)
    80                                                             
    81     68.6 MiB      0.0 MiB         134           if draw is not None:
    82                                                     draw()
    83                                         
    84     68.6 MiB      0.0 MiB         134           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     68.6 MiB     68.6 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     68.6 MiB      0.0 MiB         129       for row in grid:
    32     68.6 MiB      0.0 MiB       16512           for spot in row:
    33     68.6 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     68.6 MiB      0.0 MiB           1       count = 0
    36     68.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     68.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     68.6 MiB      0.0 MiB           1       came_from = {}
    39     68.6 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     68.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     69.1 MiB      0.6 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     69.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     69.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     69.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     69.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     69.1 MiB      0.0 MiB         116       while not open_set.empty():
    49     69.1 MiB      0.0 MiB         116           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     69.1 MiB      0.0 MiB         116           current = open_set.get()[2]
    55     69.1 MiB      0.0 MiB         116           open_set_hash.remove(current)
    56                                         
    57     69.1 MiB      0.0 MiB         116           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     69.1 MiB      0.0 MiB         116           if current == end:
    62     69.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     69.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     69.1 MiB      0.0 MiB        1035           for neighbor in current.neighbors:
    67     69.1 MiB      0.0 MiB         920               if current.row != neighbor.row and current.col != neighbor.col:
    68     69.1 MiB      0.0 MiB         460                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     69.1 MiB      0.0 MiB         460                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     69.1 MiB      0.0 MiB         920               if temp_g_score < g_score[neighbor]:
    73     69.1 MiB      0.0 MiB         238                   came_from[neighbor] = current
    74     69.1 MiB      0.0 MiB         238                   g_score[neighbor] = temp_g_score
    75     69.1 MiB      0.0 MiB         238                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     69.1 MiB      0.0 MiB         238                   if neighbor not in open_set_hash:
    77     69.1 MiB      0.0 MiB         238                       count += 1
    78     69.1 MiB      0.0 MiB         238                       open_set.put((f_score[neighbor], count, neighbor))
    79     69.1 MiB      0.0 MiB         238                       open_set_hash.add(neighbor)
    80                                                             
    81     69.1 MiB      0.0 MiB         115           if draw is not None:
    82                                                     draw()
    83                                         
    84     69.1 MiB      0.0 MiB         115           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     69.1 MiB     69.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     69.1 MiB      0.0 MiB         129       for row in grid:
    32     69.1 MiB      0.0 MiB       16512           for spot in row:
    33     69.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     69.1 MiB      0.0 MiB           1       count = 0
    36     69.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     69.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     69.1 MiB      0.0 MiB           1       came_from = {}
    39     69.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     69.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     69.2 MiB      0.1 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     69.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     69.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     69.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     69.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     69.2 MiB      0.0 MiB        1026       while not open_set.empty():
    49     69.2 MiB      0.0 MiB        1026           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     69.2 MiB      0.0 MiB        1026           current = open_set.get()[2]
    55     69.2 MiB      0.0 MiB        1026           open_set_hash.remove(current)
    56                                         
    57     69.2 MiB      0.0 MiB        1026           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     69.2 MiB      0.0 MiB        1026           if current == end:
    62     69.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     69.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     69.2 MiB      0.0 MiB        9222           for neighbor in current.neighbors:
    67     69.2 MiB      0.0 MiB        8197               if current.row != neighbor.row and current.col != neighbor.col:
    68     69.2 MiB      0.0 MiB        4098                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     69.2 MiB      0.0 MiB        4099                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     69.2 MiB      0.0 MiB        8197               if temp_g_score < g_score[neighbor]:
    73     69.2 MiB      0.0 MiB        1205                   came_from[neighbor] = current
    74     69.2 MiB      0.0 MiB        1205                   g_score[neighbor] = temp_g_score
    75     69.2 MiB      0.0 MiB        1205                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     69.2 MiB      0.0 MiB        1205                   if neighbor not in open_set_hash:
    77     69.2 MiB      0.0 MiB        1205                       count += 1
    78     69.2 MiB      0.0 MiB        1205                       open_set.put((f_score[neighbor], count, neighbor))
    79     69.2 MiB      0.0 MiB        1205                       open_set_hash.add(neighbor)
    80                                                             
    81     69.2 MiB      0.0 MiB        1025           if draw is not None:
    82                                                     draw()
    83                                         
    84     69.2 MiB      0.0 MiB        1025           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.1 MiB     72.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.1 MiB      0.0 MiB         129       for row in grid:
    32     72.1 MiB      0.0 MiB       16512           for spot in row:
    33     72.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.1 MiB      0.0 MiB           1       count = 0
    36     72.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.1 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.1 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB         315       while not open_set.empty():
    49     72.2 MiB      0.0 MiB         315           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB         315           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB         315           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB         315           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB         315           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB        2826           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB        2512               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB        1256                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB        1256                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB        2512               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB         419                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB         419                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB         419                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB         419                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB         419                       count += 1
    78     72.2 MiB      0.0 MiB         419                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB         419                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB         314           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB         314           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB         629       while not open_set.empty():
    49     72.2 MiB      0.0 MiB         629           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB         629           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB         629           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB         629           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB         629           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB        5652           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB        5024               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB        2512                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB        2512                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB        5024               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB         769                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB         769                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB         769                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB         769                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB         769                       count += 1
    78     72.2 MiB      0.0 MiB         769                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB         769                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB         628           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB         628           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB        1025       while not open_set.empty():
    49     72.2 MiB      0.0 MiB        1025           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB        1025           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB        1025           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB        1025           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB        1025           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB        9216           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB        8192               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB        4096                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB        4096                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB        8192               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB        1205                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB        1205                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB        1205                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB        1205                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB        1205                       count += 1
    78     72.2 MiB      0.0 MiB        1205                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB        1205                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB        1024           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB        1024           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB         693       while not open_set.empty():
    49     72.2 MiB      0.0 MiB         693           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB         693           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB         693           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB         693           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB         693           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB        6228           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB        5536               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB        2768                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB        2768                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB        5536               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB         861                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB         861                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB         861                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB         861                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB         861                       count += 1
    78     72.2 MiB      0.0 MiB         861                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB         861                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB         692           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB         692           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB        1776       while not open_set.empty():
    49     72.2 MiB      0.0 MiB        1776           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB        1776           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB        1776           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB        1776           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB        1776           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB       15975           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB       14200               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB        7100                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB        7100                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB       14200               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB        2018                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB        2018                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB        2018                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB        2018                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB        2018                       count += 1
    78     72.2 MiB      0.0 MiB        2018                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB        2018                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB        1775           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB        1775           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.2 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.2 MiB      0.0 MiB        1320       while not open_set.empty():
    49     72.2 MiB      0.0 MiB        1320           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.2 MiB      0.0 MiB        1320           current = open_set.get()[2]
    55     72.2 MiB      0.0 MiB        1320           open_set_hash.remove(current)
    56                                         
    57     72.2 MiB      0.0 MiB        1320           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.2 MiB      0.0 MiB        1320           if current == end:
    62     72.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.2 MiB      0.0 MiB       11868           for neighbor in current.neighbors:
    67     72.2 MiB      0.0 MiB       10549               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.2 MiB      0.0 MiB        5274                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.2 MiB      0.0 MiB        5275                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.2 MiB      0.0 MiB       10549               if temp_g_score < g_score[neighbor]:
    73     72.2 MiB      0.0 MiB        1583                   came_from[neighbor] = current
    74     72.2 MiB      0.0 MiB        1583                   g_score[neighbor] = temp_g_score
    75     72.2 MiB      0.0 MiB        1583                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.2 MiB      0.0 MiB        1583                   if neighbor not in open_set_hash:
    77     72.2 MiB      0.0 MiB        1583                       count += 1
    78     72.2 MiB      0.0 MiB        1583                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.2 MiB      0.0 MiB        1583                       open_set_hash.add(neighbor)
    80                                                             
    81     72.2 MiB      0.0 MiB        1319           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.2 MiB      0.0 MiB        1319           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.2 MiB     72.2 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.2 MiB      0.0 MiB         129       for row in grid:
    32     72.2 MiB      0.0 MiB       16512           for spot in row:
    33     72.2 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.2 MiB      0.0 MiB           1       count = 0
    36     72.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.2 MiB      0.0 MiB           1       came_from = {}
    39     72.2 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.3 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.3 MiB      0.0 MiB         297       while not open_set.empty():
    49     72.3 MiB      0.0 MiB         297           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.3 MiB      0.0 MiB         297           current = open_set.get()[2]
    55     72.3 MiB      0.0 MiB         297           open_set_hash.remove(current)
    56                                         
    57     72.3 MiB      0.0 MiB         297           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.3 MiB      0.0 MiB         297           if current == end:
    62     72.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.3 MiB      0.0 MiB        2664           for neighbor in current.neighbors:
    67     72.3 MiB      0.0 MiB        2368               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.3 MiB      0.0 MiB        1184                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.3 MiB      0.0 MiB        1184                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.3 MiB      0.0 MiB        2368               if temp_g_score < g_score[neighbor]:
    73     72.3 MiB      0.0 MiB         425                   came_from[neighbor] = current
    74     72.3 MiB      0.0 MiB         425                   g_score[neighbor] = temp_g_score
    75     72.3 MiB      0.0 MiB         425                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.3 MiB      0.0 MiB         425                   if neighbor not in open_set_hash:
    77     72.3 MiB      0.0 MiB         425                       count += 1
    78     72.3 MiB      0.0 MiB         425                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.3 MiB      0.0 MiB         425                       open_set_hash.add(neighbor)
    80                                                             
    81     72.3 MiB      0.0 MiB         296           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.3 MiB      0.0 MiB         296           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.3 MiB     72.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.3 MiB      0.0 MiB         129       for row in grid:
    32     72.3 MiB      0.0 MiB       16512           for spot in row:
    33     72.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.3 MiB      0.0 MiB           1       count = 0
    36     72.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.3 MiB      0.0 MiB           1       came_from = {}
    39     72.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.3 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.3 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.3 MiB      0.0 MiB         176       while not open_set.empty():
    49     72.3 MiB      0.0 MiB         176           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.3 MiB      0.0 MiB         176           current = open_set.get()[2]
    55     72.3 MiB      0.0 MiB         176           open_set_hash.remove(current)
    56                                         
    57     72.3 MiB      0.0 MiB         176           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.3 MiB      0.0 MiB         176           if current == end:
    62     72.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.3 MiB      0.0 MiB        1575           for neighbor in current.neighbors:
    67     72.3 MiB      0.0 MiB        1400               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.3 MiB      0.0 MiB         700                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.3 MiB      0.0 MiB         700                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.3 MiB      0.0 MiB        1400               if temp_g_score < g_score[neighbor]:
    73     72.3 MiB      0.0 MiB         358                   came_from[neighbor] = current
    74     72.3 MiB      0.0 MiB         358                   g_score[neighbor] = temp_g_score
    75     72.3 MiB      0.0 MiB         358                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.3 MiB      0.0 MiB         358                   if neighbor not in open_set_hash:
    77     72.3 MiB      0.0 MiB         358                       count += 1
    78     72.3 MiB      0.0 MiB         358                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.3 MiB      0.0 MiB         358                       open_set_hash.add(neighbor)
    80                                                             
    81     72.3 MiB      0.0 MiB         175           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.3 MiB      0.0 MiB         175           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.3 MiB     72.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.3 MiB      0.0 MiB         129       for row in grid:
    32     72.3 MiB      0.0 MiB       16512           for spot in row:
    33     72.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.3 MiB      0.0 MiB           1       count = 0
    36     72.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.3 MiB      0.0 MiB           1       came_from = {}
    39     72.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.3 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.3 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.3 MiB      0.0 MiB        1218       while not open_set.empty():
    49     72.3 MiB      0.0 MiB        1218           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.3 MiB      0.0 MiB        1218           current = open_set.get()[2]
    55     72.3 MiB      0.0 MiB        1218           open_set_hash.remove(current)
    56                                         
    57     72.3 MiB      0.0 MiB        1218           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.3 MiB      0.0 MiB        1218           if current == end:
    62     72.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.3 MiB      0.0 MiB       10953           for neighbor in current.neighbors:
    67     72.3 MiB      0.0 MiB        9736               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.3 MiB      0.0 MiB        4868                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.3 MiB      0.0 MiB        4868                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.3 MiB      0.0 MiB        9736               if temp_g_score < g_score[neighbor]:
    73     72.3 MiB      0.0 MiB        1416                   came_from[neighbor] = current
    74     72.3 MiB      0.0 MiB        1416                   g_score[neighbor] = temp_g_score
    75     72.3 MiB      0.0 MiB        1416                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.3 MiB      0.0 MiB        1416                   if neighbor not in open_set_hash:
    77     72.3 MiB      0.0 MiB        1416                       count += 1
    78     72.3 MiB      0.0 MiB        1416                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.3 MiB      0.0 MiB        1416                       open_set_hash.add(neighbor)
    80                                                             
    81     72.3 MiB      0.0 MiB        1217           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.3 MiB      0.0 MiB        1217           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.3 MiB     72.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.3 MiB      0.0 MiB         129       for row in grid:
    32     72.3 MiB      0.0 MiB       16512           for spot in row:
    33     72.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.3 MiB      0.0 MiB           1       count = 0
    36     72.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.3 MiB      0.0 MiB           1       came_from = {}
    39     72.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.3 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.3 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.3 MiB      0.0 MiB        1710       while not open_set.empty():
    49     72.3 MiB      0.0 MiB        1710           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.3 MiB      0.0 MiB        1710           current = open_set.get()[2]
    55     72.3 MiB      0.0 MiB        1710           open_set_hash.remove(current)
    56                                         
    57     72.3 MiB      0.0 MiB        1710           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.3 MiB      0.0 MiB        1710           if current == end:
    62     72.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.3 MiB      0.0 MiB       15381           for neighbor in current.neighbors:
    67     72.3 MiB      0.0 MiB       13672               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.3 MiB      0.0 MiB        6836                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.3 MiB      0.0 MiB        6836                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.3 MiB      0.0 MiB       13672               if temp_g_score < g_score[neighbor]:
    73     72.3 MiB      0.0 MiB        1942                   came_from[neighbor] = current
    74     72.3 MiB      0.0 MiB        1942                   g_score[neighbor] = temp_g_score
    75     72.3 MiB      0.0 MiB        1942                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.3 MiB      0.0 MiB        1942                   if neighbor not in open_set_hash:
    77     72.3 MiB      0.0 MiB        1942                       count += 1
    78     72.3 MiB      0.0 MiB        1942                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.3 MiB      0.0 MiB        1942                       open_set_hash.add(neighbor)
    80                                                             
    81     72.3 MiB      0.0 MiB        1709           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.3 MiB      0.0 MiB        1709           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.3 MiB     72.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.3 MiB      0.0 MiB         129       for row in grid:
    32     72.3 MiB      0.0 MiB       16512           for spot in row:
    33     72.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.3 MiB      0.0 MiB           1       count = 0
    36     72.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.3 MiB      0.0 MiB           1       came_from = {}
    39     72.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.3 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.8 MiB      0.6 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.8 MiB      0.0 MiB        1357       while not open_set.empty():
    49     72.8 MiB      0.0 MiB        1357           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.8 MiB      0.0 MiB        1357           current = open_set.get()[2]
    55     72.8 MiB      0.0 MiB        1357           open_set_hash.remove(current)
    56                                         
    57     72.8 MiB      0.0 MiB        1357           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.8 MiB      0.0 MiB        1357           if current == end:
    62     72.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.8 MiB      0.0 MiB       12204           for neighbor in current.neighbors:
    67     72.8 MiB      0.0 MiB       10848               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.8 MiB      0.0 MiB        5424                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.8 MiB      0.0 MiB        5424                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.8 MiB      0.0 MiB       10848               if temp_g_score < g_score[neighbor]:
    73     72.8 MiB      0.0 MiB        1565                   came_from[neighbor] = current
    74     72.8 MiB      0.0 MiB        1565                   g_score[neighbor] = temp_g_score
    75     72.8 MiB      0.0 MiB        1565                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.8 MiB      0.0 MiB        1565                   if neighbor not in open_set_hash:
    77     72.8 MiB      0.0 MiB        1565                       count += 1
    78     72.8 MiB      0.0 MiB        1565                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.8 MiB      0.0 MiB        1565                       open_set_hash.add(neighbor)
    80                                                             
    81     72.8 MiB      0.0 MiB        1356           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.8 MiB      0.0 MiB        1356           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.8 MiB     72.8 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.8 MiB      0.0 MiB         129       for row in grid:
    32     72.8 MiB      0.0 MiB       16512           for spot in row:
    33     72.8 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.8 MiB      0.0 MiB           1       count = 0
    36     72.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.8 MiB      0.0 MiB           1       came_from = {}
    39     72.8 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.8 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.8 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.8 MiB      0.0 MiB         663       while not open_set.empty():
    49     72.8 MiB      0.0 MiB         663           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.8 MiB      0.0 MiB         663           current = open_set.get()[2]
    55     72.8 MiB      0.0 MiB         663           open_set_hash.remove(current)
    56                                         
    57     72.8 MiB      0.0 MiB         663           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.8 MiB      0.0 MiB         663           if current == end:
    62     72.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.8 MiB      0.0 MiB        5958           for neighbor in current.neighbors:
    67     72.8 MiB      0.0 MiB        5296               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.8 MiB      0.0 MiB        2648                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.8 MiB      0.0 MiB        2648                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.8 MiB      0.0 MiB        5296               if temp_g_score < g_score[neighbor]:
    73     72.8 MiB      0.0 MiB         807                   came_from[neighbor] = current
    74     72.8 MiB      0.0 MiB         807                   g_score[neighbor] = temp_g_score
    75     72.8 MiB      0.0 MiB         807                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.8 MiB      0.0 MiB         807                   if neighbor not in open_set_hash:
    77     72.8 MiB      0.0 MiB         807                       count += 1
    78     72.8 MiB      0.0 MiB         807                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.8 MiB      0.0 MiB         807                       open_set_hash.add(neighbor)
    80                                                             
    81     72.8 MiB      0.0 MiB         662           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.8 MiB      0.0 MiB         662           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.8 MiB     71.8 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.8 MiB      0.0 MiB         129       for row in grid:
    32     71.8 MiB      0.0 MiB       16512           for spot in row:
    33     71.8 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.8 MiB      0.0 MiB           1       count = 0
    36     71.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.8 MiB      0.0 MiB           1       came_from = {}
    39     71.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.9 MiB      0.0 MiB         903       while not open_set.empty():
    49     71.9 MiB      0.0 MiB         903           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.9 MiB      0.0 MiB         903           current = open_set.get()[2]
    55     71.9 MiB      0.0 MiB         903           open_set_hash.remove(current)
    56                                         
    57     71.9 MiB      0.0 MiB         903           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.9 MiB      0.0 MiB         903           if current == end:
    62     71.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.9 MiB      0.0 MiB        8118           for neighbor in current.neighbors:
    67     71.9 MiB      0.0 MiB        7216               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.9 MiB      0.0 MiB        3608                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.9 MiB      0.0 MiB        3608                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.9 MiB      0.0 MiB        7216               if temp_g_score < g_score[neighbor]:
    73     71.9 MiB      0.0 MiB        1071                   came_from[neighbor] = current
    74     71.9 MiB      0.0 MiB        1071                   g_score[neighbor] = temp_g_score
    75     71.9 MiB      0.0 MiB        1071                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.9 MiB      0.0 MiB        1071                   if neighbor not in open_set_hash:
    77     71.9 MiB      0.0 MiB        1071                       count += 1
    78     71.9 MiB      0.0 MiB        1071                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.9 MiB      0.0 MiB        1071                       open_set_hash.add(neighbor)
    80                                                             
    81     71.9 MiB      0.0 MiB         902           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.9 MiB      0.0 MiB         902           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.9 MiB     71.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.9 MiB      0.0 MiB         129       for row in grid:
    32     71.9 MiB      0.0 MiB       16512           for spot in row:
    33     71.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.9 MiB      0.0 MiB           1       count = 0
    36     71.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.9 MiB      0.0 MiB           1       came_from = {}
    39     71.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.9 MiB      0.0 MiB         336       while not open_set.empty():
    49     71.9 MiB      0.0 MiB         336           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.9 MiB      0.0 MiB         336           current = open_set.get()[2]
    55     71.9 MiB      0.0 MiB         336           open_set_hash.remove(current)
    56                                         
    57     71.9 MiB      0.0 MiB         336           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.9 MiB      0.0 MiB         336           if current == end:
    62     71.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.9 MiB      0.0 MiB        3015           for neighbor in current.neighbors:
    67     71.9 MiB      0.0 MiB        2680               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.9 MiB      0.0 MiB        1340                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.9 MiB      0.0 MiB        1340                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.9 MiB      0.0 MiB        2680               if temp_g_score < g_score[neighbor]:
    73     71.9 MiB      0.0 MiB         440                   came_from[neighbor] = current
    74     71.9 MiB      0.0 MiB         440                   g_score[neighbor] = temp_g_score
    75     71.9 MiB      0.0 MiB         440                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.9 MiB      0.0 MiB         440                   if neighbor not in open_set_hash:
    77     71.9 MiB      0.0 MiB         440                       count += 1
    78     71.9 MiB      0.0 MiB         440                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.9 MiB      0.0 MiB         440                       open_set_hash.add(neighbor)
    80                                                             
    81     71.9 MiB      0.0 MiB         335           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.9 MiB      0.0 MiB         335           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.9 MiB     70.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.9 MiB      0.0 MiB         129       for row in grid:
    32     70.9 MiB      0.0 MiB       16512           for spot in row:
    33     70.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.9 MiB      0.0 MiB           1       count = 0
    36     70.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.9 MiB      0.0 MiB           1       came_from = {}
    39     70.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.9 MiB      0.0 MiB         500       while not open_set.empty():
    49     70.9 MiB      0.0 MiB         500           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.9 MiB      0.0 MiB         500           current = open_set.get()[2]
    55     70.9 MiB      0.0 MiB         500           open_set_hash.remove(current)
    56                                         
    57     70.9 MiB      0.0 MiB         500           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.9 MiB      0.0 MiB         500           if current == end:
    62     70.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.9 MiB      0.0 MiB        4491           for neighbor in current.neighbors:
    67     70.9 MiB      0.0 MiB        3992               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.9 MiB      0.0 MiB        1996                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.9 MiB      0.0 MiB        1996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.9 MiB      0.0 MiB        3992               if temp_g_score < g_score[neighbor]:
    73     70.9 MiB      0.0 MiB         628                   came_from[neighbor] = current
    74     70.9 MiB      0.0 MiB         628                   g_score[neighbor] = temp_g_score
    75     70.9 MiB      0.0 MiB         628                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.9 MiB      0.0 MiB         628                   if neighbor not in open_set_hash:
    77     70.9 MiB      0.0 MiB         628                       count += 1
    78     70.9 MiB      0.0 MiB         628                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.9 MiB      0.0 MiB         628                       open_set_hash.add(neighbor)
    80                                                             
    81     70.9 MiB      0.0 MiB         499           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.9 MiB      0.0 MiB         499           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.9 MiB     70.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.9 MiB      0.0 MiB         129       for row in grid:
    32     70.9 MiB      0.0 MiB       16512           for spot in row:
    33     70.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.9 MiB      0.0 MiB           1       count = 0
    36     70.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.9 MiB      0.0 MiB           1       came_from = {}
    39     70.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.9 MiB      0.0 MiB         912       while not open_set.empty():
    49     70.9 MiB      0.0 MiB         912           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.9 MiB      0.0 MiB         912           current = open_set.get()[2]
    55     70.9 MiB      0.0 MiB         912           open_set_hash.remove(current)
    56                                         
    57     70.9 MiB      0.0 MiB         912           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.9 MiB      0.0 MiB         912           if current == end:
    62     70.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.9 MiB      0.0 MiB        8199           for neighbor in current.neighbors:
    67     70.9 MiB      0.0 MiB        7288               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.9 MiB      0.0 MiB        3644                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.9 MiB      0.0 MiB        3644                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.9 MiB      0.0 MiB        7288               if temp_g_score < g_score[neighbor]:
    73     70.9 MiB      0.0 MiB        1110                   came_from[neighbor] = current
    74     70.9 MiB      0.0 MiB        1110                   g_score[neighbor] = temp_g_score
    75     70.9 MiB      0.0 MiB        1110                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.9 MiB      0.0 MiB        1110                   if neighbor not in open_set_hash:
    77     70.9 MiB      0.0 MiB        1110                       count += 1
    78     70.9 MiB      0.0 MiB        1110                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.9 MiB      0.0 MiB        1110                       open_set_hash.add(neighbor)
    80                                                             
    81     70.9 MiB      0.0 MiB         911           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.9 MiB      0.0 MiB         911           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.9 MiB     70.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.9 MiB      0.0 MiB         129       for row in grid:
    32     70.9 MiB      0.0 MiB       16512           for spot in row:
    33     70.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.9 MiB      0.0 MiB           1       count = 0
    36     70.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.9 MiB      0.0 MiB           1       came_from = {}
    39     70.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.9 MiB  -7649.5 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.3 MiB     -0.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.3 MiB      0.0 MiB         836       while not open_set.empty():
    49     70.3 MiB      0.0 MiB         836           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.3 MiB      0.0 MiB         836           current = open_set.get()[2]
    55     70.3 MiB      0.0 MiB         836           open_set_hash.remove(current)
    56                                         
    57     70.3 MiB      0.0 MiB         836           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.3 MiB      0.0 MiB         836           if current == end:
    62     70.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.3 MiB      0.0 MiB        7515           for neighbor in current.neighbors:
    67     70.3 MiB      0.0 MiB        6680               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.3 MiB      0.0 MiB        3340                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.3 MiB      0.0 MiB        3340                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.3 MiB      0.0 MiB        6680               if temp_g_score < g_score[neighbor]:
    73     70.3 MiB      0.0 MiB        1030                   came_from[neighbor] = current
    74     70.3 MiB      0.0 MiB        1030                   g_score[neighbor] = temp_g_score
    75     70.3 MiB      0.0 MiB        1030                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.3 MiB      0.0 MiB        1030                   if neighbor not in open_set_hash:
    77     70.3 MiB      0.0 MiB        1030                       count += 1
    78     70.3 MiB      0.0 MiB        1030                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.3 MiB      0.0 MiB        1030                       open_set_hash.add(neighbor)
    80                                                             
    81     70.3 MiB      0.0 MiB         835           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.3 MiB      0.0 MiB         835           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.3 MiB     72.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.3 MiB      0.0 MiB         129       for row in grid:
    32     72.3 MiB      0.0 MiB       16512           for spot in row:
    33     72.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.3 MiB      0.0 MiB           1       count = 0
    36     72.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.3 MiB      0.0 MiB           1       came_from = {}
    39     72.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.3 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.3 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.3 MiB      0.0 MiB         520       while not open_set.empty():
    49     72.3 MiB      0.0 MiB         520           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.3 MiB      0.0 MiB         520           current = open_set.get()[2]
    55     72.3 MiB      0.0 MiB         520           open_set_hash.remove(current)
    56                                         
    57     72.3 MiB      0.0 MiB         520           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.3 MiB      0.0 MiB         520           if current == end:
    62     72.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.3 MiB      0.0 MiB        4671           for neighbor in current.neighbors:
    67     72.3 MiB      0.0 MiB        4152               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.3 MiB      0.0 MiB        2076                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.3 MiB      0.0 MiB        2076                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.3 MiB      0.0 MiB        4152               if temp_g_score < g_score[neighbor]:
    73     72.3 MiB      0.0 MiB         650                   came_from[neighbor] = current
    74     72.3 MiB      0.0 MiB         650                   g_score[neighbor] = temp_g_score
    75     72.3 MiB      0.0 MiB         650                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.3 MiB      0.0 MiB         650                   if neighbor not in open_set_hash:
    77     72.3 MiB      0.0 MiB         650                       count += 1
    78     72.3 MiB      0.0 MiB         650                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.3 MiB      0.0 MiB         650                       open_set_hash.add(neighbor)
    80                                                             
    81     72.3 MiB      0.0 MiB         519           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.3 MiB      0.0 MiB         519           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.3 MiB     72.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.3 MiB      0.0 MiB         129       for row in grid:
    32     72.3 MiB      0.0 MiB       16512           for spot in row:
    33     72.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.3 MiB      0.0 MiB           1       count = 0
    36     72.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.3 MiB      0.0 MiB           1       came_from = {}
    39     72.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.3 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.3 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.3 MiB      0.0 MiB          18       while not open_set.empty():
    49     72.3 MiB      0.0 MiB          18           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.3 MiB      0.0 MiB          18           current = open_set.get()[2]
    55     72.3 MiB      0.0 MiB          18           open_set_hash.remove(current)
    56                                         
    57     72.3 MiB      0.0 MiB          18           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.3 MiB      0.0 MiB          18           if current == end:
    62     72.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.3 MiB      0.0 MiB         153           for neighbor in current.neighbors:
    67     72.3 MiB      0.0 MiB         136               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.3 MiB      0.0 MiB          68                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.3 MiB      0.0 MiB          68                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.3 MiB      0.0 MiB         136               if temp_g_score < g_score[neighbor]:
    73     72.3 MiB      0.0 MiB          46                   came_from[neighbor] = current
    74     72.3 MiB      0.0 MiB          46                   g_score[neighbor] = temp_g_score
    75     72.3 MiB      0.0 MiB          46                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.3 MiB      0.0 MiB          46                   if neighbor not in open_set_hash:
    77     72.3 MiB      0.0 MiB          46                       count += 1
    78     72.3 MiB      0.0 MiB          46                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.3 MiB      0.0 MiB          46                       open_set_hash.add(neighbor)
    80                                                             
    81     72.3 MiB      0.0 MiB          17           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.3 MiB      0.0 MiB          17           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.3 MiB     72.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.3 MiB      0.0 MiB         129       for row in grid:
    32     72.3 MiB      0.0 MiB       16512           for spot in row:
    33     72.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.3 MiB      0.0 MiB           1       count = 0
    36     72.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.3 MiB      0.0 MiB           1       came_from = {}
    39     72.6 MiB      0.3 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.7 MiB      0.1 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.7 MiB      0.0 MiB         135       while not open_set.empty():
    49     72.7 MiB      0.0 MiB         135           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.7 MiB      0.0 MiB         135           current = open_set.get()[2]
    55     72.7 MiB      0.0 MiB         135           open_set_hash.remove(current)
    56                                         
    57     72.7 MiB      0.0 MiB         135           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.7 MiB      0.0 MiB         135           if current == end:
    62     72.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.7 MiB      0.0 MiB        1206           for neighbor in current.neighbors:
    67     72.7 MiB      0.0 MiB        1072               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.7 MiB      0.0 MiB         536                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.7 MiB      0.0 MiB         536                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.7 MiB      0.0 MiB        1072               if temp_g_score < g_score[neighbor]:
    73     72.7 MiB      0.0 MiB         251                   came_from[neighbor] = current
    74     72.7 MiB      0.0 MiB         251                   g_score[neighbor] = temp_g_score
    75     72.7 MiB      0.0 MiB         251                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.7 MiB      0.0 MiB         251                   if neighbor not in open_set_hash:
    77     72.7 MiB      0.0 MiB         251                       count += 1
    78     72.7 MiB      0.0 MiB         251                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.7 MiB      0.0 MiB         251                       open_set_hash.add(neighbor)
    80                                                             
    81     72.7 MiB      0.0 MiB         134           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.7 MiB      0.0 MiB         134           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.7 MiB     72.7 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.7 MiB      0.0 MiB         129       for row in grid:
    32     72.7 MiB      0.0 MiB       16512           for spot in row:
    33     72.7 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.7 MiB      0.0 MiB           1       count = 0
    36     72.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.7 MiB      0.0 MiB           1       came_from = {}
    39     72.7 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.7 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.7 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.7 MiB      0.0 MiB         230       while not open_set.empty():
    49     72.7 MiB      0.0 MiB         230           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.7 MiB      0.0 MiB         230           current = open_set.get()[2]
    55     72.7 MiB      0.0 MiB         230           open_set_hash.remove(current)
    56                                         
    57     72.7 MiB      0.0 MiB         230           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.7 MiB      0.0 MiB         230           if current == end:
    62     72.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.7 MiB      0.0 MiB        2061           for neighbor in current.neighbors:
    67     72.7 MiB      0.0 MiB        1832               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.7 MiB      0.0 MiB         916                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.7 MiB      0.0 MiB         916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.7 MiB      0.0 MiB        1832               if temp_g_score < g_score[neighbor]:
    73     72.7 MiB      0.0 MiB         314                   came_from[neighbor] = current
    74     72.7 MiB      0.0 MiB         314                   g_score[neighbor] = temp_g_score
    75     72.7 MiB      0.0 MiB         314                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.7 MiB      0.0 MiB         314                   if neighbor not in open_set_hash:
    77     72.7 MiB      0.0 MiB         314                       count += 1
    78     72.7 MiB      0.0 MiB         314                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.7 MiB      0.0 MiB         314                       open_set_hash.add(neighbor)
    80                                                             
    81     72.7 MiB      0.0 MiB         229           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.7 MiB      0.0 MiB         229           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.7 MiB     72.7 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.7 MiB      0.0 MiB         129       for row in grid:
    32     72.7 MiB      0.0 MiB       16512           for spot in row:
    33     72.7 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.7 MiB      0.0 MiB           1       count = 0
    36     72.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.7 MiB      0.0 MiB           1       came_from = {}
    39     72.7 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.7 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.7 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.7 MiB      0.0 MiB         256       while not open_set.empty():
    49     72.7 MiB      0.0 MiB         256           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.7 MiB      0.0 MiB         256           current = open_set.get()[2]
    55     72.7 MiB      0.0 MiB         256           open_set_hash.remove(current)
    56                                         
    57     72.7 MiB      0.0 MiB         256           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.7 MiB      0.0 MiB         256           if current == end:
    62     72.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.7 MiB      0.0 MiB        2295           for neighbor in current.neighbors:
    67     72.7 MiB      0.0 MiB        2040               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.7 MiB      0.0 MiB        1020                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.7 MiB      0.0 MiB        1020                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.7 MiB      0.0 MiB        2040               if temp_g_score < g_score[neighbor]:
    73     72.7 MiB      0.0 MiB         398                   came_from[neighbor] = current
    74     72.7 MiB      0.0 MiB         398                   g_score[neighbor] = temp_g_score
    75     72.7 MiB      0.0 MiB         398                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.7 MiB      0.0 MiB         398                   if neighbor not in open_set_hash:
    77     72.7 MiB      0.0 MiB         398                       count += 1
    78     72.7 MiB      0.0 MiB         398                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.7 MiB      0.0 MiB         398                       open_set_hash.add(neighbor)
    80                                                             
    81     72.7 MiB      0.0 MiB         255           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.7 MiB      0.0 MiB         255           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.7 MiB     72.7 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.7 MiB      0.0 MiB         129       for row in grid:
    32     72.7 MiB      0.0 MiB       16512           for spot in row:
    33     72.7 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.7 MiB      0.0 MiB           1       count = 0
    36     72.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.7 MiB      0.0 MiB           1       came_from = {}
    39     72.7 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.7 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.7 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.7 MiB      0.0 MiB         184       while not open_set.empty():
    49     72.7 MiB      0.0 MiB         184           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.7 MiB      0.0 MiB         184           current = open_set.get()[2]
    55     72.7 MiB      0.0 MiB         184           open_set_hash.remove(current)
    56                                         
    57     72.7 MiB      0.0 MiB         184           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.7 MiB      0.0 MiB         184           if current == end:
    62     72.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.7 MiB      0.0 MiB        1647           for neighbor in current.neighbors:
    67     72.7 MiB      0.0 MiB        1464               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.7 MiB      0.0 MiB         732                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.7 MiB      0.0 MiB         732                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.7 MiB      0.0 MiB        1464               if temp_g_score < g_score[neighbor]:
    73     72.7 MiB      0.0 MiB         290                   came_from[neighbor] = current
    74     72.7 MiB      0.0 MiB         290                   g_score[neighbor] = temp_g_score
    75     72.7 MiB      0.0 MiB         290                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.7 MiB      0.0 MiB         290                   if neighbor not in open_set_hash:
    77     72.7 MiB      0.0 MiB         290                       count += 1
    78     72.7 MiB      0.0 MiB         290                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.7 MiB      0.0 MiB         290                       open_set_hash.add(neighbor)
    80                                                             
    81     72.7 MiB      0.0 MiB         183           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.7 MiB      0.0 MiB         183           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.7 MiB     72.7 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.7 MiB      0.0 MiB         129       for row in grid:
    32     72.7 MiB      0.0 MiB       16512           for spot in row:
    33     72.7 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.7 MiB      0.0 MiB           1       count = 0
    36     72.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.7 MiB      0.0 MiB           1       came_from = {}
    39     72.7 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.7 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.7 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.7 MiB      0.0 MiB         408       while not open_set.empty():
    49     72.7 MiB      0.0 MiB         408           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.7 MiB      0.0 MiB         408           current = open_set.get()[2]
    55     72.7 MiB      0.0 MiB         408           open_set_hash.remove(current)
    56                                         
    57     72.7 MiB      0.0 MiB         408           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.7 MiB      0.0 MiB         408           if current == end:
    62     72.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.7 MiB      0.0 MiB        3663           for neighbor in current.neighbors:
    67     72.7 MiB      0.0 MiB        3256               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.7 MiB      0.0 MiB        1628                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.7 MiB      0.0 MiB        1628                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.7 MiB      0.0 MiB        3256               if temp_g_score < g_score[neighbor]:
    73     72.7 MiB      0.0 MiB         690                   came_from[neighbor] = current
    74     72.7 MiB      0.0 MiB         690                   g_score[neighbor] = temp_g_score
    75     72.7 MiB      0.0 MiB         690                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.7 MiB      0.0 MiB         690                   if neighbor not in open_set_hash:
    77     72.7 MiB      0.0 MiB         690                       count += 1
    78     72.7 MiB      0.0 MiB         690                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.7 MiB      0.0 MiB         690                       open_set_hash.add(neighbor)
    80                                                             
    81     72.7 MiB      0.0 MiB         407           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.7 MiB      0.0 MiB         407           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.7 MiB     72.7 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.7 MiB      0.0 MiB         129       for row in grid:
    32     72.7 MiB      0.0 MiB       16512           for spot in row:
    33     72.7 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.7 MiB      0.0 MiB           1       count = 0
    36     72.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.7 MiB      0.0 MiB           1       came_from = {}
    39     72.7 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.7 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.7 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.7 MiB      0.0 MiB         276       while not open_set.empty():
    49     72.7 MiB      0.0 MiB         276           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.7 MiB      0.0 MiB         276           current = open_set.get()[2]
    55     72.7 MiB      0.0 MiB         276           open_set_hash.remove(current)
    56                                         
    57     72.7 MiB      0.0 MiB         276           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.7 MiB      0.0 MiB         276           if current == end:
    62     72.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.7 MiB      0.0 MiB        2475           for neighbor in current.neighbors:
    67     72.7 MiB      0.0 MiB        2200               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.7 MiB      0.0 MiB        1100                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.7 MiB      0.0 MiB        1100                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.7 MiB      0.0 MiB        2200               if temp_g_score < g_score[neighbor]:
    73     72.7 MiB      0.0 MiB         390                   came_from[neighbor] = current
    74     72.7 MiB      0.0 MiB         390                   g_score[neighbor] = temp_g_score
    75     72.7 MiB      0.0 MiB         390                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.7 MiB      0.0 MiB         390                   if neighbor not in open_set_hash:
    77     72.7 MiB      0.0 MiB         390                       count += 1
    78     72.7 MiB      0.0 MiB         390                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.7 MiB      0.0 MiB         390                       open_set_hash.add(neighbor)
    80                                                             
    81     72.7 MiB      0.0 MiB         275           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.7 MiB      0.0 MiB         275           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.7 MiB     72.7 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.7 MiB      0.0 MiB         129       for row in grid:
    32     72.7 MiB      0.0 MiB       16512           for spot in row:
    33     72.7 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.7 MiB      0.0 MiB           1       count = 0
    36     72.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.7 MiB      0.0 MiB           1       came_from = {}
    39     72.7 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.7 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.7 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.7 MiB      0.0 MiB         432       while not open_set.empty():
    49     72.7 MiB      0.0 MiB         432           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.7 MiB      0.0 MiB         432           current = open_set.get()[2]
    55     72.7 MiB      0.0 MiB         432           open_set_hash.remove(current)
    56                                         
    57     72.7 MiB      0.0 MiB         432           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.7 MiB      0.0 MiB         432           if current == end:
    62     72.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.7 MiB      0.0 MiB        3879           for neighbor in current.neighbors:
    67     72.7 MiB      0.0 MiB        3448               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.7 MiB      0.0 MiB        1724                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.7 MiB      0.0 MiB        1724                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.7 MiB      0.0 MiB        3448               if temp_g_score < g_score[neighbor]:
    73     72.7 MiB      0.0 MiB         550                   came_from[neighbor] = current
    74     72.7 MiB      0.0 MiB         550                   g_score[neighbor] = temp_g_score
    75     72.7 MiB      0.0 MiB         550                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.7 MiB      0.0 MiB         550                   if neighbor not in open_set_hash:
    77     72.7 MiB      0.0 MiB         550                       count += 1
    78     72.7 MiB      0.0 MiB         550                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.7 MiB      0.0 MiB         550                       open_set_hash.add(neighbor)
    80                                                             
    81     72.7 MiB      0.0 MiB         431           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.7 MiB      0.0 MiB         431           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.7 MiB     72.7 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.7 MiB      0.0 MiB         129       for row in grid:
    32     72.7 MiB      0.0 MiB       16512           for spot in row:
    33     72.7 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.7 MiB      0.0 MiB           1       count = 0
    36     72.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.7 MiB      0.0 MiB           1       came_from = {}
    39     72.7 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.7 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.7 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.7 MiB      0.0 MiB         648       while not open_set.empty():
    49     72.7 MiB      0.0 MiB         648           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.7 MiB      0.0 MiB         648           current = open_set.get()[2]
    55     72.7 MiB      0.0 MiB         648           open_set_hash.remove(current)
    56                                         
    57     72.7 MiB      0.0 MiB         648           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.7 MiB      0.0 MiB         648           if current == end:
    62     72.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.7 MiB      0.0 MiB        5823           for neighbor in current.neighbors:
    67     72.7 MiB      0.0 MiB        5176               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.7 MiB      0.0 MiB        2588                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.7 MiB      0.0 MiB        2588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.7 MiB      0.0 MiB        5176               if temp_g_score < g_score[neighbor]:
    73     72.7 MiB      0.0 MiB         802                   came_from[neighbor] = current
    74     72.7 MiB      0.0 MiB         802                   g_score[neighbor] = temp_g_score
    75     72.7 MiB      0.0 MiB         802                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.7 MiB      0.0 MiB         802                   if neighbor not in open_set_hash:
    77     72.7 MiB      0.0 MiB         802                       count += 1
    78     72.7 MiB      0.0 MiB         802                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.7 MiB      0.0 MiB         802                       open_set_hash.add(neighbor)
    80                                                             
    81     72.7 MiB      0.0 MiB         647           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.7 MiB      0.0 MiB         647           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.7 MiB     72.7 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.7 MiB      0.0 MiB         129       for row in grid:
    32     72.7 MiB      0.0 MiB       16512           for spot in row:
    33     72.7 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.7 MiB      0.0 MiB           1       count = 0
    36     72.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.7 MiB      0.0 MiB           1       came_from = {}
    39     72.7 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.7 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.7 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.7 MiB      0.0 MiB        1776       while not open_set.empty():
    49     72.7 MiB      0.0 MiB        1776           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.7 MiB      0.0 MiB        1776           current = open_set.get()[2]
    55     72.7 MiB      0.0 MiB        1776           open_set_hash.remove(current)
    56                                         
    57     72.7 MiB      0.0 MiB        1776           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.7 MiB      0.0 MiB        1776           if current == end:
    62     72.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.7 MiB      0.0 MiB       15975           for neighbor in current.neighbors:
    67     72.7 MiB      0.0 MiB       14200               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.7 MiB      0.0 MiB        7100                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.7 MiB      0.0 MiB        7100                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.7 MiB      0.0 MiB       14200               if temp_g_score < g_score[neighbor]:
    73     72.7 MiB      0.0 MiB        2118                   came_from[neighbor] = current
    74     72.7 MiB      0.0 MiB        2118                   g_score[neighbor] = temp_g_score
    75     72.7 MiB      0.0 MiB        2118                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.7 MiB      0.0 MiB        2118                   if neighbor not in open_set_hash:
    77     72.7 MiB      0.0 MiB        2118                       count += 1
    78     72.7 MiB      0.0 MiB        2118                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.7 MiB      0.0 MiB        2118                       open_set_hash.add(neighbor)
    80                                                             
    81     72.7 MiB      0.0 MiB        1775           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.7 MiB      0.0 MiB        1775           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.7 MiB     72.7 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.7 MiB      0.0 MiB         129       for row in grid:
    32     72.7 MiB      0.0 MiB       16512           for spot in row:
    33     72.7 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.7 MiB      0.0 MiB           1       count = 0
    36     72.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.7 MiB      0.0 MiB           1       came_from = {}
    39     72.7 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.7 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.7 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.7 MiB      0.0 MiB         246       while not open_set.empty():
    49     72.7 MiB      0.0 MiB         246           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.7 MiB      0.0 MiB         246           current = open_set.get()[2]
    55     72.7 MiB      0.0 MiB         246           open_set_hash.remove(current)
    56                                         
    57     72.7 MiB      0.0 MiB         246           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.7 MiB      0.0 MiB         246           if current == end:
    62     72.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.7 MiB      0.0 MiB        2205           for neighbor in current.neighbors:
    67     72.7 MiB      0.0 MiB        1960               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.7 MiB      0.0 MiB         980                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.7 MiB      0.0 MiB         980                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.7 MiB      0.0 MiB        1960               if temp_g_score < g_score[neighbor]:
    73     72.7 MiB      0.0 MiB         350                   came_from[neighbor] = current
    74     72.7 MiB      0.0 MiB         350                   g_score[neighbor] = temp_g_score
    75     72.7 MiB      0.0 MiB         350                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.7 MiB      0.0 MiB         350                   if neighbor not in open_set_hash:
    77     72.7 MiB      0.0 MiB         350                       count += 1
    78     72.7 MiB      0.0 MiB         350                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.7 MiB      0.0 MiB         350                       open_set_hash.add(neighbor)
    80                                                             
    81     72.7 MiB      0.0 MiB         245           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.7 MiB      0.0 MiB         245           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.7 MiB     71.7 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.7 MiB      0.0 MiB         129       for row in grid:
    32     71.7 MiB      0.0 MiB       16512           for spot in row:
    33     71.7 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.7 MiB      0.0 MiB           1       count = 0
    36     71.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.7 MiB      0.0 MiB           1       came_from = {}
    39     71.7 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.7 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.7 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.7 MiB      0.0 MiB         580       while not open_set.empty():
    49     71.7 MiB      0.0 MiB         580           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.7 MiB      0.0 MiB         580           current = open_set.get()[2]
    55     71.7 MiB      0.0 MiB         580           open_set_hash.remove(current)
    56                                         
    57     71.7 MiB      0.0 MiB         580           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.7 MiB      0.0 MiB         580           if current == end:
    62     71.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.7 MiB      0.0 MiB        5211           for neighbor in current.neighbors:
    67     71.7 MiB      0.0 MiB        4632               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.7 MiB      0.0 MiB        2316                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.7 MiB      0.0 MiB        2316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.7 MiB      0.0 MiB        4632               if temp_g_score < g_score[neighbor]:
    73     71.7 MiB      0.0 MiB         716                   came_from[neighbor] = current
    74     71.7 MiB      0.0 MiB         716                   g_score[neighbor] = temp_g_score
    75     71.7 MiB      0.0 MiB         716                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.7 MiB      0.0 MiB         716                   if neighbor not in open_set_hash:
    77     71.7 MiB      0.0 MiB         716                       count += 1
    78     71.7 MiB      0.0 MiB         716                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.7 MiB      0.0 MiB         716                       open_set_hash.add(neighbor)
    80                                                             
    81     71.7 MiB      0.0 MiB         579           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.7 MiB      0.0 MiB         579           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.7 MiB     71.7 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.7 MiB      0.0 MiB         129       for row in grid:
    32     71.7 MiB      0.0 MiB       16512           for spot in row:
    33     71.7 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.7 MiB      0.0 MiB           1       count = 0
    36     71.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.7 MiB      0.0 MiB           1       came_from = {}
    39     71.7 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.7 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.7 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.7 MiB      0.0 MiB        1368       while not open_set.empty():
    49     71.7 MiB      0.0 MiB        1368           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.7 MiB      0.0 MiB        1368           current = open_set.get()[2]
    55     71.7 MiB      0.0 MiB        1368           open_set_hash.remove(current)
    56                                         
    57     71.7 MiB      0.0 MiB        1368           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.7 MiB      0.0 MiB        1368           if current == end:
    62     71.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.7 MiB      0.0 MiB       12303           for neighbor in current.neighbors:
    67     71.7 MiB      0.0 MiB       10936               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.7 MiB      0.0 MiB        5468                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.7 MiB      0.0 MiB        5468                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.7 MiB      0.0 MiB       10936               if temp_g_score < g_score[neighbor]:
    73     71.7 MiB      0.0 MiB        1586                   came_from[neighbor] = current
    74     71.7 MiB      0.0 MiB        1586                   g_score[neighbor] = temp_g_score
    75     71.7 MiB      0.0 MiB        1586                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.7 MiB      0.0 MiB        1586                   if neighbor not in open_set_hash:
    77     71.7 MiB      0.0 MiB        1586                       count += 1
    78     71.7 MiB      0.0 MiB        1586                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.7 MiB      0.0 MiB        1586                       open_set_hash.add(neighbor)
    80                                                             
    81     71.7 MiB      0.0 MiB        1367           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.7 MiB      0.0 MiB        1367           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.7 MiB     71.7 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.7 MiB      0.0 MiB         129       for row in grid:
    32     71.7 MiB      0.0 MiB       16512           for spot in row:
    33     71.7 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.7 MiB      0.0 MiB           1       count = 0
    36     71.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.7 MiB      0.0 MiB           1       came_from = {}
    39     71.7 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.7 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.3 MiB      0.6 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.3 MiB      0.0 MiB        1620       while not open_set.empty():
    49     72.3 MiB      0.0 MiB        1620           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.3 MiB      0.0 MiB        1620           current = open_set.get()[2]
    55     72.3 MiB      0.0 MiB        1620           open_set_hash.remove(current)
    56                                         
    57     72.3 MiB      0.0 MiB        1620           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.3 MiB      0.0 MiB        1620           if current == end:
    62     72.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.3 MiB      0.0 MiB       14571           for neighbor in current.neighbors:
    67     72.3 MiB      0.0 MiB       12952               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.3 MiB      0.0 MiB        6476                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.3 MiB      0.0 MiB        6476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.3 MiB      0.0 MiB       12952               if temp_g_score < g_score[neighbor]:
    73     72.3 MiB      0.0 MiB        1870                   came_from[neighbor] = current
    74     72.3 MiB      0.0 MiB        1870                   g_score[neighbor] = temp_g_score
    75     72.3 MiB      0.0 MiB        1870                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.3 MiB      0.0 MiB        1870                   if neighbor not in open_set_hash:
    77     72.3 MiB      0.0 MiB        1870                       count += 1
    78     72.3 MiB      0.0 MiB        1870                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.3 MiB      0.0 MiB        1870                       open_set_hash.add(neighbor)
    80                                                             
    81     72.3 MiB      0.0 MiB        1619           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.3 MiB      0.0 MiB        1619           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.3 MiB     72.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.3 MiB      0.0 MiB         129       for row in grid:
    32     72.3 MiB      0.0 MiB       16512           for spot in row:
    33     72.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.3 MiB      0.0 MiB           1       count = 0
    36     72.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.3 MiB      0.0 MiB           1       came_from = {}
    39     72.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.3 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.3 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.3 MiB      0.0 MiB        1071       while not open_set.empty():
    49     72.3 MiB      0.0 MiB        1071           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.3 MiB      0.0 MiB        1071           current = open_set.get()[2]
    55     72.3 MiB      0.0 MiB        1071           open_set_hash.remove(current)
    56                                         
    57     72.3 MiB      0.0 MiB        1071           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.3 MiB      0.0 MiB        1071           if current == end:
    62     72.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.3 MiB      0.0 MiB        9630           for neighbor in current.neighbors:
    67     72.3 MiB      0.0 MiB        8560               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.3 MiB      0.0 MiB        4280                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.3 MiB      0.0 MiB        4280                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.3 MiB      0.0 MiB        8560               if temp_g_score < g_score[neighbor]:
    73     72.3 MiB      0.0 MiB        1263                   came_from[neighbor] = current
    74     72.3 MiB      0.0 MiB        1263                   g_score[neighbor] = temp_g_score
    75     72.3 MiB      0.0 MiB        1263                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.3 MiB      0.0 MiB        1263                   if neighbor not in open_set_hash:
    77     72.3 MiB      0.0 MiB        1263                       count += 1
    78     72.3 MiB      0.0 MiB        1263                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.3 MiB      0.0 MiB        1263                       open_set_hash.add(neighbor)
    80                                                             
    81     72.3 MiB      0.0 MiB        1070           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.3 MiB      0.0 MiB        1070           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.3 MiB     72.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.3 MiB      0.0 MiB         129       for row in grid:
    32     72.3 MiB      0.0 MiB       16512           for spot in row:
    33     72.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.3 MiB      0.0 MiB           1       count = 0
    36     72.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.3 MiB      0.0 MiB           1       came_from = {}
    39     72.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.3 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.3 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.3 MiB      0.0 MiB          39       while not open_set.empty():
    49     72.3 MiB      0.0 MiB          39           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.3 MiB      0.0 MiB          39           current = open_set.get()[2]
    55     72.3 MiB      0.0 MiB          39           open_set_hash.remove(current)
    56                                         
    57     72.3 MiB      0.0 MiB          39           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.3 MiB      0.0 MiB          39           if current == end:
    62     72.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.3 MiB      0.0 MiB         342           for neighbor in current.neighbors:
    67     72.3 MiB      0.0 MiB         304               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.3 MiB      0.0 MiB         152                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.3 MiB      0.0 MiB         152                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.3 MiB      0.0 MiB         304               if temp_g_score < g_score[neighbor]:
    73     72.3 MiB      0.0 MiB          95                   came_from[neighbor] = current
    74     72.3 MiB      0.0 MiB          95                   g_score[neighbor] = temp_g_score
    75     72.3 MiB      0.0 MiB          95                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.3 MiB      0.0 MiB          95                   if neighbor not in open_set_hash:
    77     72.3 MiB      0.0 MiB          95                       count += 1
    78     72.3 MiB      0.0 MiB          95                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.3 MiB      0.0 MiB          95                       open_set_hash.add(neighbor)
    80                                                             
    81     72.3 MiB      0.0 MiB          38           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.3 MiB      0.0 MiB          38           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.3 MiB     73.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.3 MiB      0.0 MiB         129       for row in grid:
    32     73.3 MiB      0.0 MiB       16512           for spot in row:
    33     73.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.3 MiB      0.0 MiB           1       count = 0
    36     73.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.3 MiB      0.0 MiB           1       came_from = {}
    39     73.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.3 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.3 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.3 MiB      0.0 MiB         153       while not open_set.empty():
    49     73.3 MiB      0.0 MiB         153           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.3 MiB      0.0 MiB         153           current = open_set.get()[2]
    55     73.3 MiB      0.0 MiB         153           open_set_hash.remove(current)
    56                                         
    57     73.3 MiB      0.0 MiB         153           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.3 MiB      0.0 MiB         153           if current == end:
    62     73.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.3 MiB      0.0 MiB        1368           for neighbor in current.neighbors:
    67     73.3 MiB      0.0 MiB        1216               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.3 MiB      0.0 MiB         608                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.3 MiB      0.0 MiB         608                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.3 MiB      0.0 MiB        1216               if temp_g_score < g_score[neighbor]:
    73     73.3 MiB      0.0 MiB         221                   came_from[neighbor] = current
    74     73.3 MiB      0.0 MiB         221                   g_score[neighbor] = temp_g_score
    75     73.3 MiB      0.0 MiB         221                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.3 MiB      0.0 MiB         221                   if neighbor not in open_set_hash:
    77     73.3 MiB      0.0 MiB         221                       count += 1
    78     73.3 MiB      0.0 MiB         221                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.3 MiB      0.0 MiB         221                       open_set_hash.add(neighbor)
    80                                                             
    81     73.3 MiB      0.0 MiB         152           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.3 MiB      0.0 MiB         152           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.3 MiB     73.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.3 MiB      0.0 MiB         129       for row in grid:
    32     73.3 MiB      0.0 MiB       16512           for spot in row:
    33     73.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.3 MiB      0.0 MiB           1       count = 0
    36     73.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.3 MiB      0.0 MiB           1       came_from = {}
    39     73.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.3 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.4 MiB      0.0 MiB         702       while not open_set.empty():
    49     73.4 MiB      0.0 MiB         702           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.4 MiB      0.0 MiB         702           current = open_set.get()[2]
    55     73.4 MiB      0.0 MiB         702           open_set_hash.remove(current)
    56                                         
    57     73.4 MiB      0.0 MiB         702           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.4 MiB      0.0 MiB         702           if current == end:
    62     73.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.4 MiB      0.0 MiB        6309           for neighbor in current.neighbors:
    67     73.4 MiB      0.0 MiB        5608               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.4 MiB      0.0 MiB        2804                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.4 MiB      0.0 MiB        2804                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.4 MiB      0.0 MiB        5608               if temp_g_score < g_score[neighbor]:
    73     73.4 MiB      0.0 MiB         858                   came_from[neighbor] = current
    74     73.4 MiB      0.0 MiB         858                   g_score[neighbor] = temp_g_score
    75     73.4 MiB      0.0 MiB         858                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.4 MiB      0.0 MiB         858                   if neighbor not in open_set_hash:
    77     73.4 MiB      0.0 MiB         858                       count += 1
    78     73.4 MiB      0.0 MiB         858                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.4 MiB      0.0 MiB         858                       open_set_hash.add(neighbor)
    80                                                             
    81     73.4 MiB      0.0 MiB         701           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.4 MiB      0.0 MiB         701           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.4 MiB     73.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.4 MiB      0.0 MiB         129       for row in grid:
    32     73.4 MiB      0.0 MiB       16512           for spot in row:
    33     73.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.4 MiB      0.0 MiB           1       count = 0
    36     73.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.4 MiB      0.0 MiB           1       came_from = {}
    39     73.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.4 MiB      0.0 MiB         540       while not open_set.empty():
    49     73.4 MiB      0.0 MiB         540           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.4 MiB      0.0 MiB         540           current = open_set.get()[2]
    55     73.4 MiB      0.0 MiB         540           open_set_hash.remove(current)
    56                                         
    57     73.4 MiB      0.0 MiB         540           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.4 MiB      0.0 MiB         540           if current == end:
    62     73.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.4 MiB      0.0 MiB        4851           for neighbor in current.neighbors:
    67     73.4 MiB      0.0 MiB        4312               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.4 MiB      0.0 MiB        2156                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.4 MiB      0.0 MiB        2156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.4 MiB      0.0 MiB        4312               if temp_g_score < g_score[neighbor]:
    73     73.4 MiB      0.0 MiB         670                   came_from[neighbor] = current
    74     73.4 MiB      0.0 MiB         670                   g_score[neighbor] = temp_g_score
    75     73.4 MiB      0.0 MiB         670                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.4 MiB      0.0 MiB         670                   if neighbor not in open_set_hash:
    77     73.4 MiB      0.0 MiB         670                       count += 1
    78     73.4 MiB      0.0 MiB         670                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.4 MiB      0.0 MiB         670                       open_set_hash.add(neighbor)
    80                                                             
    81     73.4 MiB      0.0 MiB         539           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.4 MiB      0.0 MiB         539           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.4 MiB     73.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.4 MiB      0.0 MiB         129       for row in grid:
    32     73.4 MiB      0.0 MiB       16512           for spot in row:
    33     73.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.4 MiB      0.0 MiB           1       count = 0
    36     73.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.4 MiB      0.0 MiB           1       came_from = {}
    39     73.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.4 MiB      0.0 MiB        1140       while not open_set.empty():
    49     73.4 MiB      0.0 MiB        1140           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.4 MiB      0.0 MiB        1140           current = open_set.get()[2]
    55     73.4 MiB      0.0 MiB        1140           open_set_hash.remove(current)
    56                                         
    57     73.4 MiB      0.0 MiB        1140           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.4 MiB      0.0 MiB        1140           if current == end:
    62     73.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.4 MiB      0.0 MiB       10251           for neighbor in current.neighbors:
    67     73.4 MiB      0.0 MiB        9112               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.4 MiB      0.0 MiB        4556                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.4 MiB      0.0 MiB        4556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.4 MiB      0.0 MiB        9112               if temp_g_score < g_score[neighbor]:
    73     73.4 MiB      0.0 MiB        1334                   came_from[neighbor] = current
    74     73.4 MiB      0.0 MiB        1334                   g_score[neighbor] = temp_g_score
    75     73.4 MiB      0.0 MiB        1334                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.4 MiB      0.0 MiB        1334                   if neighbor not in open_set_hash:
    77     73.4 MiB      0.0 MiB        1334                       count += 1
    78     73.4 MiB      0.0 MiB        1334                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.4 MiB      0.0 MiB        1334                       open_set_hash.add(neighbor)
    80                                                             
    81     73.4 MiB      0.0 MiB        1139           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.4 MiB      0.0 MiB        1139           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.4 MiB     73.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.4 MiB      0.0 MiB         129       for row in grid:
    32     73.4 MiB      0.0 MiB       16512           for spot in row:
    33     73.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.4 MiB      0.0 MiB           1       count = 0
    36     73.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.4 MiB      0.0 MiB           1       came_from = {}
    39     73.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.4 MiB      0.0 MiB          52       while not open_set.empty():
    49     73.4 MiB      0.0 MiB          52           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.4 MiB      0.0 MiB          52           current = open_set.get()[2]
    55     73.4 MiB      0.0 MiB          52           open_set_hash.remove(current)
    56                                         
    57     73.4 MiB      0.0 MiB          52           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.4 MiB      0.0 MiB          52           if current == end:
    62     73.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.4 MiB      0.0 MiB         459           for neighbor in current.neighbors:
    67     73.4 MiB      0.0 MiB         408               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.4 MiB      0.0 MiB         204                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.4 MiB      0.0 MiB         204                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.4 MiB      0.0 MiB         408               if temp_g_score < g_score[neighbor]:
    73     73.4 MiB      0.0 MiB         258                   came_from[neighbor] = current
    74     73.4 MiB      0.0 MiB         258                   g_score[neighbor] = temp_g_score
    75     73.4 MiB      0.0 MiB         258                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.4 MiB      0.0 MiB         258                   if neighbor not in open_set_hash:
    77     73.4 MiB      0.0 MiB         258                       count += 1
    78     73.4 MiB      0.0 MiB         258                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.4 MiB      0.0 MiB         258                       open_set_hash.add(neighbor)
    80                                                             
    81     73.4 MiB      0.0 MiB          51           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.4 MiB      0.0 MiB          51           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.4 MiB     73.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.4 MiB      0.0 MiB         129       for row in grid:
    32     73.4 MiB      0.0 MiB       16512           for spot in row:
    33     73.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.4 MiB      0.0 MiB           1       count = 0
    36     73.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.4 MiB      0.0 MiB           1       came_from = {}
    39     73.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.4 MiB      0.0 MiB         168       while not open_set.empty():
    49     73.4 MiB      0.0 MiB         168           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.4 MiB      0.0 MiB         168           current = open_set.get()[2]
    55     73.4 MiB      0.0 MiB         168           open_set_hash.remove(current)
    56                                         
    57     73.4 MiB      0.0 MiB         168           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.4 MiB      0.0 MiB         168           if current == end:
    62     73.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.4 MiB      0.0 MiB        1503           for neighbor in current.neighbors:
    67     73.4 MiB      0.0 MiB        1336               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.4 MiB      0.0 MiB         668                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.4 MiB      0.0 MiB         668                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.4 MiB      0.0 MiB        1336               if temp_g_score < g_score[neighbor]:
    73     73.4 MiB      0.0 MiB         246                   came_from[neighbor] = current
    74     73.4 MiB      0.0 MiB         246                   g_score[neighbor] = temp_g_score
    75     73.4 MiB      0.0 MiB         246                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.4 MiB      0.0 MiB         246                   if neighbor not in open_set_hash:
    77     73.4 MiB      0.0 MiB         246                       count += 1
    78     73.4 MiB      0.0 MiB         246                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.4 MiB      0.0 MiB         246                       open_set_hash.add(neighbor)
    80                                                             
    81     73.4 MiB      0.0 MiB         167           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.4 MiB      0.0 MiB         167           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.4 MiB     73.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.4 MiB      0.0 MiB         129       for row in grid:
    32     73.4 MiB      0.0 MiB       16512           for spot in row:
    33     73.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.4 MiB      0.0 MiB           1       count = 0
    36     73.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.4 MiB      0.0 MiB           1       came_from = {}
    39     73.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.4 MiB      0.0 MiB         387       while not open_set.empty():
    49     73.4 MiB      0.0 MiB         387           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.4 MiB      0.0 MiB         387           current = open_set.get()[2]
    55     73.4 MiB      0.0 MiB         387           open_set_hash.remove(current)
    56                                         
    57     73.4 MiB      0.0 MiB         387           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.4 MiB      0.0 MiB         387           if current == end:
    62     73.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.4 MiB      0.0 MiB        3474           for neighbor in current.neighbors:
    67     73.4 MiB      0.0 MiB        3088               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.4 MiB      0.0 MiB        1544                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.4 MiB      0.0 MiB        1544                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.4 MiB      0.0 MiB        3088               if temp_g_score < g_score[neighbor]:
    73     73.4 MiB      0.0 MiB         507                   came_from[neighbor] = current
    74     73.4 MiB      0.0 MiB         507                   g_score[neighbor] = temp_g_score
    75     73.4 MiB      0.0 MiB         507                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.4 MiB      0.0 MiB         507                   if neighbor not in open_set_hash:
    77     73.4 MiB      0.0 MiB         507                       count += 1
    78     73.4 MiB      0.0 MiB         507                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.4 MiB      0.0 MiB         507                       open_set_hash.add(neighbor)
    80                                                             
    81     73.4 MiB      0.0 MiB         386           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.4 MiB      0.0 MiB         386           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.4 MiB     73.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.4 MiB      0.0 MiB         129       for row in grid:
    32     73.4 MiB      0.0 MiB       16512           for spot in row:
    33     73.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.4 MiB      0.0 MiB           1       count = 0
    36     73.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.4 MiB      0.0 MiB           1       came_from = {}
    39     73.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.5 MiB      0.0 MiB        2562       while not open_set.empty():
    49     73.5 MiB      0.0 MiB        2562           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.5 MiB      0.0 MiB        2562           current = open_set.get()[2]
    55     73.5 MiB      0.0 MiB        2562           open_set_hash.remove(current)
    56                                         
    57     73.5 MiB      0.0 MiB        2562           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.5 MiB      0.0 MiB        2562           if current == end:
    62     73.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.5 MiB      0.0 MiB       23049           for neighbor in current.neighbors:
    67     73.5 MiB      0.0 MiB       20488               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.5 MiB      0.0 MiB       10244                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.5 MiB      0.0 MiB       10244                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.5 MiB      0.0 MiB       20488               if temp_g_score < g_score[neighbor]:
    73     73.5 MiB      0.0 MiB        2850                   came_from[neighbor] = current
    74     73.5 MiB      0.0 MiB        2850                   g_score[neighbor] = temp_g_score
    75     73.5 MiB      0.0 MiB        2850                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.5 MiB      0.0 MiB        2850                   if neighbor not in open_set_hash:
    77     73.5 MiB      0.0 MiB        2850                       count += 1
    78     73.5 MiB      0.0 MiB        2850                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.5 MiB      0.0 MiB        2850                       open_set_hash.add(neighbor)
    80                                                             
    81     73.5 MiB      0.0 MiB        2561           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.5 MiB      0.0 MiB        2561           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.5 MiB     73.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.5 MiB      0.0 MiB         129       for row in grid:
    32     73.5 MiB      0.0 MiB       16512           for spot in row:
    33     73.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.5 MiB      0.0 MiB           1       count = 0
    36     73.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.5 MiB      0.0 MiB           1       came_from = {}
    39     73.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.5 MiB      0.0 MiB         511       while not open_set.empty():
    49     73.5 MiB      0.0 MiB         511           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.5 MiB      0.0 MiB         511           current = open_set.get()[2]
    55     73.5 MiB      0.0 MiB         511           open_set_hash.remove(current)
    56                                         
    57     73.5 MiB      0.0 MiB         511           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.5 MiB      0.0 MiB         511           if current == end:
    62     73.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.5 MiB      0.0 MiB        4590           for neighbor in current.neighbors:
    67     73.5 MiB      0.0 MiB        4080               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.5 MiB      0.0 MiB        2040                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.5 MiB      0.0 MiB        2040                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.5 MiB      0.0 MiB        4080               if temp_g_score < g_score[neighbor]:
    73     73.5 MiB      0.0 MiB         815                   came_from[neighbor] = current
    74     73.5 MiB      0.0 MiB         815                   g_score[neighbor] = temp_g_score
    75     73.5 MiB      0.0 MiB         815                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.5 MiB      0.0 MiB         815                   if neighbor not in open_set_hash:
    77     73.5 MiB      0.0 MiB         815                       count += 1
    78     73.5 MiB      0.0 MiB         815                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.5 MiB      0.0 MiB         815                       open_set_hash.add(neighbor)
    80                                                             
    81     73.5 MiB      0.0 MiB         510           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.5 MiB      0.0 MiB         510           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.5 MiB     73.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.5 MiB      0.0 MiB         129       for row in grid:
    32     73.5 MiB      0.0 MiB       16512           for spot in row:
    33     73.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.5 MiB      0.0 MiB           1       count = 0
    36     73.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.5 MiB      0.0 MiB           1       came_from = {}
    39     73.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.5 MiB      0.0 MiB         495       while not open_set.empty():
    49     73.5 MiB      0.0 MiB         495           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.5 MiB      0.0 MiB         495           current = open_set.get()[2]
    55     73.5 MiB      0.0 MiB         495           open_set_hash.remove(current)
    56                                         
    57     73.5 MiB      0.0 MiB         495           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.5 MiB      0.0 MiB         495           if current == end:
    62     73.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.5 MiB      0.0 MiB        4446           for neighbor in current.neighbors:
    67     73.5 MiB      0.0 MiB        3952               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.5 MiB      0.0 MiB        1976                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.5 MiB      0.0 MiB        1976                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.5 MiB      0.0 MiB        3952               if temp_g_score < g_score[neighbor]:
    73     73.5 MiB      0.0 MiB         731                   came_from[neighbor] = current
    74     73.5 MiB      0.0 MiB         731                   g_score[neighbor] = temp_g_score
    75     73.5 MiB      0.0 MiB         731                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.5 MiB      0.0 MiB         731                   if neighbor not in open_set_hash:
    77     73.5 MiB      0.0 MiB         731                       count += 1
    78     73.5 MiB      0.0 MiB         731                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.5 MiB      0.0 MiB         731                       open_set_hash.add(neighbor)
    80                                                             
    81     73.5 MiB      0.0 MiB         494           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.5 MiB      0.0 MiB         494           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.5 MiB     73.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.5 MiB      0.0 MiB         129       for row in grid:
    32     73.5 MiB      0.0 MiB       16512           for spot in row:
    33     73.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.5 MiB      0.0 MiB           1       count = 0
    36     73.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.5 MiB      0.0 MiB           1       came_from = {}
    39     73.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.5 MiB      0.0 MiB        1980       while not open_set.empty():
    49     73.5 MiB      0.0 MiB        1980           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.5 MiB      0.0 MiB        1980           current = open_set.get()[2]
    55     73.5 MiB      0.0 MiB        1980           open_set_hash.remove(current)
    56                                         
    57     73.5 MiB      0.0 MiB        1980           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.5 MiB      0.0 MiB        1980           if current == end:
    62     73.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.5 MiB      0.0 MiB       17811           for neighbor in current.neighbors:
    67     73.5 MiB      0.0 MiB       15832               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.5 MiB      0.0 MiB        7916                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.5 MiB      0.0 MiB        7916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.5 MiB      0.0 MiB       15832               if temp_g_score < g_score[neighbor]:
    73     73.5 MiB      0.0 MiB        2246                   came_from[neighbor] = current
    74     73.5 MiB      0.0 MiB        2246                   g_score[neighbor] = temp_g_score
    75     73.5 MiB      0.0 MiB        2246                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.5 MiB      0.0 MiB        2246                   if neighbor not in open_set_hash:
    77     73.5 MiB      0.0 MiB        2246                       count += 1
    78     73.5 MiB      0.0 MiB        2246                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.5 MiB      0.0 MiB        2246                       open_set_hash.add(neighbor)
    80                                                             
    81     73.5 MiB      0.0 MiB        1979           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.5 MiB      0.0 MiB        1979           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.5 MiB     73.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.5 MiB      0.0 MiB         129       for row in grid:
    32     73.5 MiB      0.0 MiB       16512           for spot in row:
    33     73.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.5 MiB      0.0 MiB           1       count = 0
    36     73.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.5 MiB      0.0 MiB           1       came_from = {}
    39     73.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.5 MiB      0.0 MiB        2940       while not open_set.empty():
    49     73.5 MiB      0.0 MiB        2940           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.5 MiB      0.0 MiB        2940           current = open_set.get()[2]
    55     73.5 MiB      0.0 MiB        2940           open_set_hash.remove(current)
    56                                         
    57     73.5 MiB      0.0 MiB        2940           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.5 MiB      0.0 MiB        2940           if current == end:
    62     73.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.5 MiB      0.0 MiB       26451           for neighbor in current.neighbors:
    67     73.5 MiB      0.0 MiB       23512               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.5 MiB      0.0 MiB       11756                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.5 MiB      0.0 MiB       11756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.5 MiB      0.0 MiB       23512               if temp_g_score < g_score[neighbor]:
    73     73.5 MiB      0.0 MiB        3276                   came_from[neighbor] = current
    74     73.5 MiB      0.0 MiB        3276                   g_score[neighbor] = temp_g_score
    75     73.5 MiB      0.0 MiB        3276                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.5 MiB      0.0 MiB        3276                   if neighbor not in open_set_hash:
    77     73.5 MiB      0.0 MiB        3276                       count += 1
    78     73.5 MiB      0.0 MiB        3276                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.5 MiB      0.0 MiB        3276                       open_set_hash.add(neighbor)
    80                                                             
    81     73.5 MiB      0.0 MiB        2939           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.5 MiB      0.0 MiB        2939           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.5 MiB     72.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.5 MiB      0.0 MiB         129       for row in grid:
    32     72.5 MiB      0.0 MiB       16512           for spot in row:
    33     72.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.5 MiB      0.0 MiB           1       count = 0
    36     72.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.5 MiB      0.0 MiB           1       came_from = {}
    39     72.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.5 MiB      0.0 MiB         408       while not open_set.empty():
    49     72.5 MiB      0.0 MiB         408           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.5 MiB      0.0 MiB         408           current = open_set.get()[2]
    55     72.5 MiB      0.0 MiB         408           open_set_hash.remove(current)
    56                                         
    57     72.5 MiB      0.0 MiB         408           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.5 MiB      0.0 MiB         408           if current == end:
    62     72.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.5 MiB      0.0 MiB        3663           for neighbor in current.neighbors:
    67     72.5 MiB      0.0 MiB        3256               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.5 MiB      0.0 MiB        1628                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.5 MiB      0.0 MiB        1628                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.5 MiB      0.0 MiB        3256               if temp_g_score < g_score[neighbor]:
    73     72.5 MiB      0.0 MiB         566                   came_from[neighbor] = current
    74     72.5 MiB      0.0 MiB         566                   g_score[neighbor] = temp_g_score
    75     72.5 MiB      0.0 MiB         566                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.5 MiB      0.0 MiB         566                   if neighbor not in open_set_hash:
    77     72.5 MiB      0.0 MiB         566                       count += 1
    78     72.5 MiB      0.0 MiB         566                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.5 MiB      0.0 MiB         566                       open_set_hash.add(neighbor)
    80                                                             
    81     72.5 MiB      0.0 MiB         407           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.5 MiB      0.0 MiB         407           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.5 MiB     72.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.5 MiB      0.0 MiB         129       for row in grid:
    32     72.5 MiB      0.0 MiB       16512           for spot in row:
    33     72.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.5 MiB      0.0 MiB           1       count = 0
    36     72.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.5 MiB      0.0 MiB           1       came_from = {}
    39     72.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.5 MiB      0.0 MiB         182       while not open_set.empty():
    49     72.5 MiB      0.0 MiB         182           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.5 MiB      0.0 MiB         182           current = open_set.get()[2]
    55     72.5 MiB      0.0 MiB         182           open_set_hash.remove(current)
    56                                         
    57     72.5 MiB      0.0 MiB         182           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.5 MiB      0.0 MiB         182           if current == end:
    62     72.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.5 MiB      0.0 MiB        1629           for neighbor in current.neighbors:
    67     72.5 MiB      0.0 MiB        1448               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.5 MiB      0.0 MiB         724                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.5 MiB      0.0 MiB         724                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.5 MiB      0.0 MiB        1448               if temp_g_score < g_score[neighbor]:
    73     72.5 MiB      0.0 MiB         260                   came_from[neighbor] = current
    74     72.5 MiB      0.0 MiB         260                   g_score[neighbor] = temp_g_score
    75     72.5 MiB      0.0 MiB         260                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.5 MiB      0.0 MiB         260                   if neighbor not in open_set_hash:
    77     72.5 MiB      0.0 MiB         260                       count += 1
    78     72.5 MiB      0.0 MiB         260                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.5 MiB      0.0 MiB         260                       open_set_hash.add(neighbor)
    80                                                             
    81     72.5 MiB      0.0 MiB         181           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.5 MiB      0.0 MiB         181           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.5 MiB     71.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.5 MiB      0.0 MiB         129       for row in grid:
    32     71.5 MiB      0.0 MiB       16512           for spot in row:
    33     71.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.5 MiB      0.0 MiB           1       count = 0
    36     71.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.5 MiB      0.0 MiB           1       came_from = {}
    39     71.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.5 MiB      0.0 MiB         704       while not open_set.empty():
    49     71.5 MiB      0.0 MiB         704           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.5 MiB      0.0 MiB         704           current = open_set.get()[2]
    55     71.5 MiB      0.0 MiB         704           open_set_hash.remove(current)
    56                                         
    57     71.5 MiB      0.0 MiB         704           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.5 MiB      0.0 MiB         704           if current == end:
    62     71.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.5 MiB      0.0 MiB        6327           for neighbor in current.neighbors:
    67     71.5 MiB      0.0 MiB        5624               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.5 MiB      0.0 MiB        2812                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.5 MiB      0.0 MiB        2812                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.5 MiB      0.0 MiB        5624               if temp_g_score < g_score[neighbor]:
    73     71.5 MiB      0.0 MiB         874                   came_from[neighbor] = current
    74     71.5 MiB      0.0 MiB         874                   g_score[neighbor] = temp_g_score
    75     71.5 MiB      0.0 MiB         874                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.5 MiB      0.0 MiB         874                   if neighbor not in open_set_hash:
    77     71.5 MiB      0.0 MiB         874                       count += 1
    78     71.5 MiB      0.0 MiB         874                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.5 MiB      0.0 MiB         874                       open_set_hash.add(neighbor)
    80                                                             
    81     71.5 MiB      0.0 MiB         703           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.5 MiB      0.0 MiB         703           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.5 MiB     71.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.5 MiB      0.0 MiB         129       for row in grid:
    32     71.5 MiB      0.0 MiB       16512           for spot in row:
    33     71.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.5 MiB      0.0 MiB           1       count = 0
    36     71.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.5 MiB      0.0 MiB           1       came_from = {}
    39     71.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.5 MiB      0.0 MiB         510       while not open_set.empty():
    49     71.5 MiB      0.0 MiB         510           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.5 MiB      0.0 MiB         510           current = open_set.get()[2]
    55     71.5 MiB      0.0 MiB         510           open_set_hash.remove(current)
    56                                         
    57     71.5 MiB      0.0 MiB         510           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.5 MiB      0.0 MiB         510           if current == end:
    62     71.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.5 MiB      0.0 MiB        4581           for neighbor in current.neighbors:
    67     71.5 MiB      0.0 MiB        4072               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.5 MiB      0.0 MiB        2036                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.5 MiB      0.0 MiB        2036                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.5 MiB      0.0 MiB        4072               if temp_g_score < g_score[neighbor]:
    73     71.5 MiB      0.0 MiB         650                   came_from[neighbor] = current
    74     71.5 MiB      0.0 MiB         650                   g_score[neighbor] = temp_g_score
    75     71.5 MiB      0.0 MiB         650                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.5 MiB      0.0 MiB         650                   if neighbor not in open_set_hash:
    77     71.5 MiB      0.0 MiB         650                       count += 1
    78     71.5 MiB      0.0 MiB         650                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.5 MiB      0.0 MiB         650                       open_set_hash.add(neighbor)
    80                                                             
    81     71.5 MiB      0.0 MiB         509           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.5 MiB      0.0 MiB         509           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.5 MiB     71.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.5 MiB      0.0 MiB         129       for row in grid:
    32     71.5 MiB      0.0 MiB       16512           for spot in row:
    33     71.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.5 MiB      0.0 MiB           1       count = 0
    36     71.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.5 MiB      0.0 MiB           1       came_from = {}
    39     71.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.5 MiB      0.0 MiB        2464       while not open_set.empty():
    49     71.5 MiB      0.0 MiB        2464           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.5 MiB      0.0 MiB        2464           current = open_set.get()[2]
    55     71.5 MiB      0.0 MiB        2464           open_set_hash.remove(current)
    56                                         
    57     71.5 MiB      0.0 MiB        2464           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.5 MiB      0.0 MiB        2464           if current == end:
    62     71.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.5 MiB      0.0 MiB       22167           for neighbor in current.neighbors:
    67     71.5 MiB      0.0 MiB       19704               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.5 MiB      0.0 MiB        9852                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.5 MiB      0.0 MiB        9852                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.5 MiB      0.0 MiB       19704               if temp_g_score < g_score[neighbor]:
    73     71.5 MiB      0.0 MiB        2750                   came_from[neighbor] = current
    74     71.5 MiB      0.0 MiB        2750                   g_score[neighbor] = temp_g_score
    75     71.5 MiB      0.0 MiB        2750                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.5 MiB      0.0 MiB        2750                   if neighbor not in open_set_hash:
    77     71.5 MiB      0.0 MiB        2750                       count += 1
    78     71.5 MiB      0.0 MiB        2750                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.5 MiB      0.0 MiB        2750                       open_set_hash.add(neighbor)
    80                                                             
    81     71.5 MiB      0.0 MiB        2463           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.5 MiB      0.0 MiB        2463           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.5 MiB     71.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.5 MiB      0.0 MiB         129       for row in grid:
    32     71.5 MiB      0.0 MiB       16512           for spot in row:
    33     71.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.5 MiB      0.0 MiB           1       count = 0
    36     71.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.5 MiB      0.0 MiB           1       came_from = {}
    39     71.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.5 MiB      0.0 MiB         351       while not open_set.empty():
    49     71.5 MiB      0.0 MiB         351           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.5 MiB      0.0 MiB         351           current = open_set.get()[2]
    55     71.5 MiB      0.0 MiB         351           open_set_hash.remove(current)
    56                                         
    57     71.5 MiB      0.0 MiB         351           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.5 MiB      0.0 MiB         351           if current == end:
    62     71.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.5 MiB      0.0 MiB        3150           for neighbor in current.neighbors:
    67     71.5 MiB      0.0 MiB        2800               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.5 MiB      0.0 MiB        1400                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.5 MiB      0.0 MiB        1400                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.5 MiB      0.0 MiB        2800               if temp_g_score < g_score[neighbor]:
    73     71.5 MiB      0.0 MiB         523                   came_from[neighbor] = current
    74     71.5 MiB      0.0 MiB         523                   g_score[neighbor] = temp_g_score
    75     71.5 MiB      0.0 MiB         523                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.5 MiB      0.0 MiB         523                   if neighbor not in open_set_hash:
    77     71.5 MiB      0.0 MiB         523                       count += 1
    78     71.5 MiB      0.0 MiB         523                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.5 MiB      0.0 MiB         523                       open_set_hash.add(neighbor)
    80                                                             
    81     71.5 MiB      0.0 MiB         350           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.5 MiB      0.0 MiB         350           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.5 MiB     71.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.5 MiB      0.0 MiB         129       for row in grid:
    32     71.5 MiB      0.0 MiB       16512           for spot in row:
    33     71.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.5 MiB      0.0 MiB           1       count = 0
    36     71.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.5 MiB      0.0 MiB           1       came_from = {}
    39     71.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.5 MiB      0.0 MiB        1204       while not open_set.empty():
    49     71.5 MiB      0.0 MiB        1204           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.5 MiB      0.0 MiB        1204           current = open_set.get()[2]
    55     71.5 MiB      0.0 MiB        1204           open_set_hash.remove(current)
    56                                         
    57     71.5 MiB      0.0 MiB        1204           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.5 MiB      0.0 MiB        1204           if current == end:
    62     71.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.5 MiB      0.0 MiB       10827           for neighbor in current.neighbors:
    67     71.5 MiB      0.0 MiB        9624               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.5 MiB      0.0 MiB        4812                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.5 MiB      0.0 MiB        4812                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.5 MiB      0.0 MiB        9624               if temp_g_score < g_score[neighbor]:
    73     71.5 MiB      0.0 MiB        1400                   came_from[neighbor] = current
    74     71.5 MiB      0.0 MiB        1400                   g_score[neighbor] = temp_g_score
    75     71.5 MiB      0.0 MiB        1400                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.5 MiB      0.0 MiB        1400                   if neighbor not in open_set_hash:
    77     71.5 MiB      0.0 MiB        1400                       count += 1
    78     71.5 MiB      0.0 MiB        1400                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.5 MiB      0.0 MiB        1400                       open_set_hash.add(neighbor)
    80                                                             
    81     71.5 MiB      0.0 MiB        1203           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.5 MiB      0.0 MiB        1203           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.0 MiB     73.0 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.0 MiB      0.0 MiB         129       for row in grid:
    32     73.0 MiB      0.0 MiB       16512           for spot in row:
    33     73.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.0 MiB      0.0 MiB           1       count = 0
    36     73.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.0 MiB      0.0 MiB           1       came_from = {}
    39     73.0 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.0 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.2 MiB      0.2 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.2 MiB      0.0 MiB         700       while not open_set.empty():
    49     73.2 MiB      0.0 MiB         700           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.2 MiB      0.0 MiB         700           current = open_set.get()[2]
    55     73.2 MiB      0.0 MiB         700           open_set_hash.remove(current)
    56                                         
    57     73.2 MiB      0.0 MiB         700           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.2 MiB      0.0 MiB         700           if current == end:
    62     73.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.2 MiB      0.0 MiB        6291           for neighbor in current.neighbors:
    67     73.2 MiB      0.0 MiB        5592               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.2 MiB      0.0 MiB        2796                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.2 MiB      0.0 MiB        2796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.2 MiB      0.0 MiB        5592               if temp_g_score < g_score[neighbor]:
    73     73.2 MiB      0.0 MiB         926                   came_from[neighbor] = current
    74     73.2 MiB      0.0 MiB         926                   g_score[neighbor] = temp_g_score
    75     73.2 MiB      0.0 MiB         926                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.2 MiB      0.0 MiB         926                   if neighbor not in open_set_hash:
    77     73.2 MiB      0.0 MiB         926                       count += 1
    78     73.2 MiB      0.0 MiB         926                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.2 MiB      0.0 MiB         926                       open_set_hash.add(neighbor)
    80                                                             
    81     73.2 MiB      0.0 MiB         699           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.2 MiB      0.0 MiB         699           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.4 MiB     73.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.4 MiB      0.0 MiB         129       for row in grid:
    32     73.4 MiB      0.0 MiB       16512           for spot in row:
    33     73.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.4 MiB      0.0 MiB           1       count = 0
    36     73.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.4 MiB      0.0 MiB           1       came_from = {}
    39     73.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.4 MiB      0.0 MiB         528       while not open_set.empty():
    49     73.4 MiB      0.0 MiB         528           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.4 MiB      0.0 MiB         528           current = open_set.get()[2]
    55     73.4 MiB      0.0 MiB         528           open_set_hash.remove(current)
    56                                         
    57     73.4 MiB      0.0 MiB         528           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.4 MiB      0.0 MiB         528           if current == end:
    62     73.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.4 MiB      0.0 MiB        4743           for neighbor in current.neighbors:
    67     73.4 MiB      0.0 MiB        4216               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.4 MiB      0.0 MiB        2108                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.4 MiB      0.0 MiB        2108                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.4 MiB      0.0 MiB        4216               if temp_g_score < g_score[neighbor]:
    73     73.4 MiB      0.0 MiB         662                   came_from[neighbor] = current
    74     73.4 MiB      0.0 MiB         662                   g_score[neighbor] = temp_g_score
    75     73.4 MiB      0.0 MiB         662                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.4 MiB      0.0 MiB         662                   if neighbor not in open_set_hash:
    77     73.4 MiB      0.0 MiB         662                       count += 1
    78     73.4 MiB      0.0 MiB         662                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.4 MiB      0.0 MiB         662                       open_set_hash.add(neighbor)
    80                                                             
    81     73.4 MiB      0.0 MiB         527           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.4 MiB      0.0 MiB         527           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.4 MiB     73.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.4 MiB      0.0 MiB         129       for row in grid:
    32     73.4 MiB      0.0 MiB       16512           for spot in row:
    33     73.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.4 MiB      0.0 MiB           1       count = 0
    36     73.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.4 MiB      0.0 MiB           1       came_from = {}
    39     73.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.4 MiB      0.0 MiB          92       while not open_set.empty():
    49     73.4 MiB      0.0 MiB          92           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.4 MiB      0.0 MiB          92           current = open_set.get()[2]
    55     73.4 MiB      0.0 MiB          92           open_set_hash.remove(current)
    56                                         
    57     73.4 MiB      0.0 MiB          92           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.4 MiB      0.0 MiB          92           if current == end:
    62     73.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.4 MiB      0.0 MiB         819           for neighbor in current.neighbors:
    67     73.4 MiB      0.0 MiB         728               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.4 MiB      0.0 MiB         364                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.4 MiB      0.0 MiB         364                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.4 MiB      0.0 MiB         728               if temp_g_score < g_score[neighbor]:
    73     73.4 MiB      0.0 MiB         152                   came_from[neighbor] = current
    74     73.4 MiB      0.0 MiB         152                   g_score[neighbor] = temp_g_score
    75     73.4 MiB      0.0 MiB         152                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.4 MiB      0.0 MiB         152                   if neighbor not in open_set_hash:
    77     73.4 MiB      0.0 MiB         152                       count += 1
    78     73.4 MiB      0.0 MiB         152                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.4 MiB      0.0 MiB         152                       open_set_hash.add(neighbor)
    80                                                             
    81     73.4 MiB      0.0 MiB          91           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.4 MiB      0.0 MiB          91           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.4 MiB     73.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.4 MiB      0.0 MiB         129       for row in grid:
    32     73.4 MiB      0.0 MiB       16512           for spot in row:
    33     73.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.4 MiB      0.0 MiB           1       count = 0
    36     73.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.4 MiB      0.0 MiB           1       came_from = {}
    39     73.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.4 MiB      0.0 MiB         546       while not open_set.empty():
    49     73.4 MiB      0.0 MiB         546           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.4 MiB      0.0 MiB         546           current = open_set.get()[2]
    55     73.4 MiB      0.0 MiB         546           open_set_hash.remove(current)
    56                                         
    57     73.4 MiB      0.0 MiB         546           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.4 MiB      0.0 MiB         546           if current == end:
    62     73.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.4 MiB      0.0 MiB        4905           for neighbor in current.neighbors:
    67     73.4 MiB      0.0 MiB        4360               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.4 MiB      0.0 MiB        2180                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.4 MiB      0.0 MiB        2180                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.4 MiB      0.0 MiB        4360               if temp_g_score < g_score[neighbor]:
    73     73.4 MiB      0.0 MiB         678                   came_from[neighbor] = current
    74     73.4 MiB      0.0 MiB         678                   g_score[neighbor] = temp_g_score
    75     73.4 MiB      0.0 MiB         678                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.4 MiB      0.0 MiB         678                   if neighbor not in open_set_hash:
    77     73.4 MiB      0.0 MiB         678                       count += 1
    78     73.4 MiB      0.0 MiB         678                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.4 MiB      0.0 MiB         678                       open_set_hash.add(neighbor)
    80                                                             
    81     73.4 MiB      0.0 MiB         545           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.4 MiB      0.0 MiB         545           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.4 MiB     73.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.4 MiB      0.0 MiB         129       for row in grid:
    32     73.4 MiB      0.0 MiB       16512           for spot in row:
    33     73.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.4 MiB      0.0 MiB           1       count = 0
    36     73.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.4 MiB      0.0 MiB           1       came_from = {}
    39     73.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.4 MiB      0.0 MiB         312       while not open_set.empty():
    49     73.4 MiB      0.0 MiB         312           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.4 MiB      0.0 MiB         312           current = open_set.get()[2]
    55     73.4 MiB      0.0 MiB         312           open_set_hash.remove(current)
    56                                         
    57     73.4 MiB      0.0 MiB         312           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.4 MiB      0.0 MiB         312           if current == end:
    62     73.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.4 MiB      0.0 MiB        2799           for neighbor in current.neighbors:
    67     73.4 MiB      0.0 MiB        2488               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.4 MiB      0.0 MiB        1244                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.4 MiB      0.0 MiB        1244                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.4 MiB      0.0 MiB        2488               if temp_g_score < g_score[neighbor]:
    73     73.4 MiB      0.0 MiB         438                   came_from[neighbor] = current
    74     73.4 MiB      0.0 MiB         438                   g_score[neighbor] = temp_g_score
    75     73.4 MiB      0.0 MiB         438                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.4 MiB      0.0 MiB         438                   if neighbor not in open_set_hash:
    77     73.4 MiB      0.0 MiB         438                       count += 1
    78     73.4 MiB      0.0 MiB         438                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.4 MiB      0.0 MiB         438                       open_set_hash.add(neighbor)
    80                                                             
    81     73.4 MiB      0.0 MiB         311           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.4 MiB      0.0 MiB         311           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.4 MiB     73.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.4 MiB      0.0 MiB         129       for row in grid:
    32     73.4 MiB      0.0 MiB       16512           for spot in row:
    33     73.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.4 MiB      0.0 MiB           1       count = 0
    36     73.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.4 MiB      0.0 MiB           1       came_from = {}
    39     73.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.4 MiB      0.0 MiB        1183       while not open_set.empty():
    49     73.4 MiB      0.0 MiB        1183           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.4 MiB      0.0 MiB        1183           current = open_set.get()[2]
    55     73.4 MiB      0.0 MiB        1183           open_set_hash.remove(current)
    56                                         
    57     73.4 MiB      0.0 MiB        1183           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.4 MiB      0.0 MiB        1183           if current == end:
    62     73.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.4 MiB      0.0 MiB       10638           for neighbor in current.neighbors:
    67     73.4 MiB      0.0 MiB        9456               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.4 MiB      0.0 MiB        4728                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.4 MiB      0.0 MiB        4728                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.4 MiB      0.0 MiB        9456               if temp_g_score < g_score[neighbor]:
    73     73.4 MiB      0.0 MiB        1415                   came_from[neighbor] = current
    74     73.4 MiB      0.0 MiB        1415                   g_score[neighbor] = temp_g_score
    75     73.4 MiB      0.0 MiB        1415                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.4 MiB      0.0 MiB        1415                   if neighbor not in open_set_hash:
    77     73.4 MiB      0.0 MiB        1415                       count += 1
    78     73.4 MiB      0.0 MiB        1415                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.4 MiB      0.0 MiB        1415                       open_set_hash.add(neighbor)
    80                                                             
    81     73.4 MiB      0.0 MiB        1182           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.4 MiB      0.0 MiB        1182           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.4 MiB     73.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.4 MiB      0.0 MiB         129       for row in grid:
    32     73.4 MiB      0.0 MiB       16512           for spot in row:
    33     73.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.4 MiB      0.0 MiB           1       count = 0
    36     73.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.4 MiB      0.0 MiB           1       came_from = {}
    39     73.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.4 MiB      0.0 MiB        1080       while not open_set.empty():
    49     73.4 MiB      0.0 MiB        1080           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.4 MiB      0.0 MiB        1080           current = open_set.get()[2]
    55     73.4 MiB      0.0 MiB        1080           open_set_hash.remove(current)
    56                                         
    57     73.4 MiB      0.0 MiB        1080           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.4 MiB      0.0 MiB        1080           if current == end:
    62     73.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.4 MiB      0.0 MiB        9711           for neighbor in current.neighbors:
    67     73.4 MiB      0.0 MiB        8632               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.4 MiB      0.0 MiB        4316                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.4 MiB      0.0 MiB        4316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.4 MiB      0.0 MiB        8632               if temp_g_score < g_score[neighbor]:
    73     73.4 MiB      0.0 MiB        1354                   came_from[neighbor] = current
    74     73.4 MiB      0.0 MiB        1354                   g_score[neighbor] = temp_g_score
    75     73.4 MiB      0.0 MiB        1354                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.4 MiB      0.0 MiB        1354                   if neighbor not in open_set_hash:
    77     73.4 MiB      0.0 MiB        1354                       count += 1
    78     73.4 MiB      0.0 MiB        1354                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.4 MiB      0.0 MiB        1354                       open_set_hash.add(neighbor)
    80                                                             
    81     73.4 MiB      0.0 MiB        1079           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.4 MiB      0.0 MiB        1079           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.4 MiB     73.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.4 MiB      0.0 MiB         129       for row in grid:
    32     73.4 MiB      0.0 MiB       16512           for spot in row:
    33     73.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.4 MiB      0.0 MiB           1       count = 0
    36     73.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.4 MiB      0.0 MiB           1       came_from = {}
    39     73.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.4 MiB      0.0 MiB        1452       while not open_set.empty():
    49     73.4 MiB      0.0 MiB        1452           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.4 MiB      0.0 MiB        1452           current = open_set.get()[2]
    55     73.4 MiB      0.0 MiB        1452           open_set_hash.remove(current)
    56                                         
    57     73.4 MiB      0.0 MiB        1452           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.4 MiB      0.0 MiB        1452           if current == end:
    62     73.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.4 MiB      0.0 MiB       13059           for neighbor in current.neighbors:
    67     73.4 MiB      0.0 MiB       11608               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.4 MiB      0.0 MiB        5804                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.4 MiB      0.0 MiB        5804                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.4 MiB      0.0 MiB       11608               if temp_g_score < g_score[neighbor]:
    73     73.4 MiB      0.0 MiB        1758                   came_from[neighbor] = current
    74     73.4 MiB      0.0 MiB        1758                   g_score[neighbor] = temp_g_score
    75     73.4 MiB      0.0 MiB        1758                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.4 MiB      0.0 MiB        1758                   if neighbor not in open_set_hash:
    77     73.4 MiB      0.0 MiB        1758                       count += 1
    78     73.4 MiB      0.0 MiB        1758                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.4 MiB      0.0 MiB        1758                       open_set_hash.add(neighbor)
    80                                                             
    81     73.4 MiB      0.0 MiB        1451           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.4 MiB      0.0 MiB        1451           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.4 MiB     73.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.4 MiB      0.0 MiB         129       for row in grid:
    32     73.4 MiB      0.0 MiB       16512           for spot in row:
    33     73.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.4 MiB      0.0 MiB           1       count = 0
    36     73.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.4 MiB      0.0 MiB           1       came_from = {}
    39     73.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.4 MiB      0.0 MiB         188       while not open_set.empty():
    49     73.4 MiB      0.0 MiB         188           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.4 MiB      0.0 MiB         188           current = open_set.get()[2]
    55     73.4 MiB      0.0 MiB         188           open_set_hash.remove(current)
    56                                         
    57     73.4 MiB      0.0 MiB         188           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.4 MiB      0.0 MiB         188           if current == end:
    62     73.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.4 MiB      0.0 MiB        1683           for neighbor in current.neighbors:
    67     73.4 MiB      0.0 MiB        1496               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.4 MiB      0.0 MiB         748                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.4 MiB      0.0 MiB         748                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.4 MiB      0.0 MiB        1496               if temp_g_score < g_score[neighbor]:
    73     73.4 MiB      0.0 MiB         296                   came_from[neighbor] = current
    74     73.4 MiB      0.0 MiB         296                   g_score[neighbor] = temp_g_score
    75     73.4 MiB      0.0 MiB         296                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.4 MiB      0.0 MiB         296                   if neighbor not in open_set_hash:
    77     73.4 MiB      0.0 MiB         296                       count += 1
    78     73.4 MiB      0.0 MiB         296                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.4 MiB      0.0 MiB         296                       open_set_hash.add(neighbor)
    80                                                             
    81     73.4 MiB      0.0 MiB         187           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.4 MiB      0.0 MiB         187           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.4 MiB     73.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.4 MiB      0.0 MiB         129       for row in grid:
    32     73.4 MiB      0.0 MiB       16512           for spot in row:
    33     73.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.4 MiB      0.0 MiB           1       count = 0
    36     73.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.4 MiB      0.0 MiB           1       came_from = {}
    39     73.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.4 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.4 MiB      0.0 MiB         555       while not open_set.empty():
    49     73.4 MiB      0.0 MiB         555           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.4 MiB      0.0 MiB         555           current = open_set.get()[2]
    55     73.4 MiB      0.0 MiB         555           open_set_hash.remove(current)
    56                                         
    57     73.4 MiB      0.0 MiB         555           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.4 MiB      0.0 MiB         555           if current == end:
    62     73.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.4 MiB      0.0 MiB        4986           for neighbor in current.neighbors:
    67     73.4 MiB      0.0 MiB        4432               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.4 MiB      0.0 MiB        2216                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.4 MiB      0.0 MiB        2216                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.4 MiB      0.0 MiB        4432               if temp_g_score < g_score[neighbor]:
    73     73.4 MiB      0.0 MiB         731                   came_from[neighbor] = current
    74     73.4 MiB      0.0 MiB         731                   g_score[neighbor] = temp_g_score
    75     73.4 MiB      0.0 MiB         731                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.4 MiB      0.0 MiB         731                   if neighbor not in open_set_hash:
    77     73.4 MiB      0.0 MiB         731                       count += 1
    78     73.4 MiB      0.0 MiB         731                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.4 MiB      0.0 MiB         731                       open_set_hash.add(neighbor)
    80                                                             
    81     73.4 MiB      0.0 MiB         554           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.4 MiB      0.0 MiB         554           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.4 MiB     73.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.4 MiB      0.0 MiB         129       for row in grid:
    32     73.4 MiB      0.0 MiB       16512           for spot in row:
    33     73.4 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.4 MiB      0.0 MiB           1       count = 0
    36     73.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.4 MiB      0.0 MiB           1       came_from = {}
    39     73.4 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.4 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.5 MiB      0.0 MiB        2808       while not open_set.empty():
    49     73.5 MiB      0.0 MiB        2808           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.5 MiB      0.0 MiB        2808           current = open_set.get()[2]
    55     73.5 MiB      0.0 MiB        2808           open_set_hash.remove(current)
    56                                         
    57     73.5 MiB      0.0 MiB        2808           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.5 MiB      0.0 MiB        2808           if current == end:
    62     73.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.5 MiB      0.0 MiB       25101           for neighbor in current.neighbors:
    67     73.5 MiB      0.0 MiB       22294               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.5 MiB      0.0 MiB       11120                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.5 MiB      0.0 MiB       11174                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.5 MiB      0.0 MiB       22294               if temp_g_score < g_score[neighbor]:
    73     73.5 MiB      0.0 MiB        3066                   came_from[neighbor] = current
    74     73.5 MiB      0.0 MiB        3066                   g_score[neighbor] = temp_g_score
    75     73.5 MiB      0.0 MiB        3066                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.5 MiB      0.0 MiB        3066                   if neighbor not in open_set_hash:
    77     73.5 MiB      0.0 MiB        3066                       count += 1
    78     73.5 MiB      0.0 MiB        3066                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.5 MiB      0.0 MiB        3066                       open_set_hash.add(neighbor)
    80                                                             
    81     73.5 MiB      0.0 MiB        2807           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.5 MiB      0.0 MiB        2807           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.5 MiB     73.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.5 MiB      0.0 MiB         129       for row in grid:
    32     73.5 MiB      0.0 MiB       16512           for spot in row:
    33     73.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.5 MiB      0.0 MiB           1       count = 0
    36     73.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.5 MiB      0.0 MiB           1       came_from = {}
    39     73.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.5 MiB      0.0 MiB         279       while not open_set.empty():
    49     73.5 MiB      0.0 MiB         279           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.5 MiB      0.0 MiB         279           current = open_set.get()[2]
    55     73.5 MiB      0.0 MiB         279           open_set_hash.remove(current)
    56                                         
    57     73.5 MiB      0.0 MiB         279           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.5 MiB      0.0 MiB         279           if current == end:
    62     73.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.5 MiB      0.0 MiB        2502           for neighbor in current.neighbors:
    67     73.5 MiB      0.0 MiB        2224               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.5 MiB      0.0 MiB        1112                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.5 MiB      0.0 MiB        1112                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.5 MiB      0.0 MiB        2224               if temp_g_score < g_score[neighbor]:
    73     73.5 MiB      0.0 MiB         375                   came_from[neighbor] = current
    74     73.5 MiB      0.0 MiB         375                   g_score[neighbor] = temp_g_score
    75     73.5 MiB      0.0 MiB         375                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.5 MiB      0.0 MiB         375                   if neighbor not in open_set_hash:
    77     73.5 MiB      0.0 MiB         375                       count += 1
    78     73.5 MiB      0.0 MiB         375                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.5 MiB      0.0 MiB         375                       open_set_hash.add(neighbor)
    80                                                             
    81     73.5 MiB      0.0 MiB         278           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.5 MiB      0.0 MiB         278           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.5 MiB     73.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.5 MiB      0.0 MiB         129       for row in grid:
    32     73.5 MiB      0.0 MiB       16512           for spot in row:
    33     73.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.5 MiB      0.0 MiB           1       count = 0
    36     73.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.5 MiB      0.0 MiB           1       came_from = {}
    39     73.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.5 MiB      0.0 MiB         456       while not open_set.empty():
    49     73.5 MiB      0.0 MiB         456           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.5 MiB      0.0 MiB         456           current = open_set.get()[2]
    55     73.5 MiB      0.0 MiB         456           open_set_hash.remove(current)
    56                                         
    57     73.5 MiB      0.0 MiB         456           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.5 MiB      0.0 MiB         456           if current == end:
    62     73.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.5 MiB      0.0 MiB        4092           for neighbor in current.neighbors:
    67     73.5 MiB      0.0 MiB        3637               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.5 MiB      0.0 MiB        1818                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.5 MiB      0.0 MiB        1819                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.5 MiB      0.0 MiB        3637               if temp_g_score < g_score[neighbor]:
    73     73.5 MiB      0.0 MiB         597                   came_from[neighbor] = current
    74     73.5 MiB      0.0 MiB         597                   g_score[neighbor] = temp_g_score
    75     73.5 MiB      0.0 MiB         597                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.5 MiB      0.0 MiB         597                   if neighbor not in open_set_hash:
    77     73.5 MiB      0.0 MiB         597                       count += 1
    78     73.5 MiB      0.0 MiB         597                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.5 MiB      0.0 MiB         597                       open_set_hash.add(neighbor)
    80                                                             
    81     73.5 MiB      0.0 MiB         455           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.5 MiB      0.0 MiB         455           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.5 MiB     73.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.5 MiB      0.0 MiB         129       for row in grid:
    32     73.5 MiB      0.0 MiB       16512           for spot in row:
    33     73.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.5 MiB      0.0 MiB           1       count = 0
    36     73.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.5 MiB      0.0 MiB           1       came_from = {}
    39     73.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.5 MiB      0.0 MiB        1920       while not open_set.empty():
    49     73.5 MiB      0.0 MiB        1920           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.5 MiB      0.0 MiB        1920           current = open_set.get()[2]
    55     73.5 MiB      0.0 MiB        1920           open_set_hash.remove(current)
    56                                         
    57     73.5 MiB      0.0 MiB        1920           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.5 MiB      0.0 MiB        1920           if current == end:
    62     73.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.5 MiB      0.0 MiB       17271           for neighbor in current.neighbors:
    67     73.5 MiB      0.0 MiB       15352               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.5 MiB      0.0 MiB        7676                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.5 MiB      0.0 MiB        7676                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.5 MiB      0.0 MiB       15352               if temp_g_score < g_score[neighbor]:
    73     73.5 MiB      0.0 MiB        2234                   came_from[neighbor] = current
    74     73.5 MiB      0.0 MiB        2234                   g_score[neighbor] = temp_g_score
    75     73.5 MiB      0.0 MiB        2234                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.5 MiB      0.0 MiB        2234                   if neighbor not in open_set_hash:
    77     73.5 MiB      0.0 MiB        2234                       count += 1
    78     73.5 MiB      0.0 MiB        2234                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.5 MiB      0.0 MiB        2234                       open_set_hash.add(neighbor)
    80                                                             
    81     73.5 MiB      0.0 MiB        1919           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.5 MiB      0.0 MiB        1919           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.5 MiB     73.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.5 MiB      0.0 MiB         129       for row in grid:
    32     73.5 MiB      0.0 MiB       16512           for spot in row:
    33     73.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.5 MiB      0.0 MiB           1       count = 0
    36     73.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.5 MiB      0.0 MiB           1       came_from = {}
    39     73.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.5 MiB      0.0 MiB        1404       while not open_set.empty():
    49     73.5 MiB      0.0 MiB        1404           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.5 MiB      0.0 MiB        1404           current = open_set.get()[2]
    55     73.5 MiB      0.0 MiB        1404           open_set_hash.remove(current)
    56                                         
    57     73.5 MiB      0.0 MiB        1404           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.5 MiB      0.0 MiB        1404           if current == end:
    62     73.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.5 MiB      0.0 MiB       12627           for neighbor in current.neighbors:
    67     73.5 MiB      0.0 MiB       11224               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.5 MiB      0.0 MiB        5612                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.5 MiB      0.0 MiB        5612                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.5 MiB      0.0 MiB       11224               if temp_g_score < g_score[neighbor]:
    73     73.5 MiB      0.0 MiB        1624                   came_from[neighbor] = current
    74     73.5 MiB      0.0 MiB        1624                   g_score[neighbor] = temp_g_score
    75     73.5 MiB      0.0 MiB        1624                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.5 MiB      0.0 MiB        1624                   if neighbor not in open_set_hash:
    77     73.5 MiB      0.0 MiB        1624                       count += 1
    78     73.5 MiB      0.0 MiB        1624                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.5 MiB      0.0 MiB        1624                       open_set_hash.add(neighbor)
    80                                                             
    81     73.5 MiB      0.0 MiB        1403           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.5 MiB      0.0 MiB        1403           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.5 MiB     73.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.5 MiB      0.0 MiB         129       for row in grid:
    32     73.5 MiB      0.0 MiB       16512           for spot in row:
    33     73.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.5 MiB      0.0 MiB           1       count = 0
    36     73.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.5 MiB      0.0 MiB           1       came_from = {}
    39     73.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.5 MiB      0.0 MiB        3480       while not open_set.empty():
    49     73.5 MiB      0.0 MiB        3480           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.5 MiB      0.0 MiB        3480           current = open_set.get()[2]
    55     73.5 MiB      0.0 MiB        3480           open_set_hash.remove(current)
    56                                         
    57     73.5 MiB      0.0 MiB        3480           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.5 MiB      0.0 MiB        3480           if current == end:
    62     73.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.5 MiB      0.0 MiB       31311           for neighbor in current.neighbors:
    67     73.5 MiB      0.0 MiB       27832               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.5 MiB      0.0 MiB       13916                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.5 MiB      0.0 MiB       13916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.5 MiB      0.0 MiB       27832               if temp_g_score < g_score[neighbor]:
    73     73.5 MiB      0.0 MiB        3830                   came_from[neighbor] = current
    74     73.5 MiB      0.0 MiB        3830                   g_score[neighbor] = temp_g_score
    75     73.5 MiB      0.0 MiB        3830                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.5 MiB      0.0 MiB        3830                   if neighbor not in open_set_hash:
    77     73.5 MiB      0.0 MiB        3830                       count += 1
    78     73.5 MiB      0.0 MiB        3830                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.5 MiB      0.0 MiB        3830                       open_set_hash.add(neighbor)
    80                                                             
    81     73.5 MiB      0.0 MiB        3479           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.5 MiB      0.0 MiB        3479           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.5 MiB     73.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.5 MiB      0.0 MiB         129       for row in grid:
    32     73.5 MiB      0.0 MiB       16512           for spot in row:
    33     73.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.5 MiB      0.0 MiB           1       count = 0
    36     73.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.5 MiB      0.0 MiB           1       came_from = {}
    39     73.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.5 MiB      0.0 MiB          85       while not open_set.empty():
    49     73.5 MiB      0.0 MiB          85           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.5 MiB      0.0 MiB          85           current = open_set.get()[2]
    55     73.5 MiB      0.0 MiB          85           open_set_hash.remove(current)
    56                                         
    57     73.5 MiB      0.0 MiB          85           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.5 MiB      0.0 MiB          85           if current == end:
    62     73.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.5 MiB      0.0 MiB         756           for neighbor in current.neighbors:
    67     73.5 MiB      0.0 MiB         672               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.5 MiB      0.0 MiB         336                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.5 MiB      0.0 MiB         336                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.5 MiB      0.0 MiB         672               if temp_g_score < g_score[neighbor]:
    73     73.5 MiB      0.0 MiB         137                   came_from[neighbor] = current
    74     73.5 MiB      0.0 MiB         137                   g_score[neighbor] = temp_g_score
    75     73.5 MiB      0.0 MiB         137                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.5 MiB      0.0 MiB         137                   if neighbor not in open_set_hash:
    77     73.5 MiB      0.0 MiB         137                       count += 1
    78     73.5 MiB      0.0 MiB         137                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.5 MiB      0.0 MiB         137                       open_set_hash.add(neighbor)
    80                                                             
    81     73.5 MiB      0.0 MiB          84           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.5 MiB      0.0 MiB          84           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.5 MiB     73.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.5 MiB      0.0 MiB         129       for row in grid:
    32     73.5 MiB      0.0 MiB       16512           for spot in row:
    33     73.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.5 MiB      0.0 MiB           1       count = 0
    36     73.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.5 MiB      0.0 MiB           1       came_from = {}
    39     73.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.5 MiB      0.0 MiB         378       while not open_set.empty():
    49     73.5 MiB      0.0 MiB         378           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.5 MiB      0.0 MiB         378           current = open_set.get()[2]
    55     73.5 MiB      0.0 MiB         378           open_set_hash.remove(current)
    56                                         
    57     73.5 MiB      0.0 MiB         378           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.5 MiB      0.0 MiB         378           if current == end:
    62     73.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.5 MiB      0.0 MiB        3393           for neighbor in current.neighbors:
    67     73.5 MiB      0.0 MiB        3016               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.5 MiB      0.0 MiB        1508                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.5 MiB      0.0 MiB        1508                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.5 MiB      0.0 MiB        3016               if temp_g_score < g_score[neighbor]:
    73     73.5 MiB      0.0 MiB         512                   came_from[neighbor] = current
    74     73.5 MiB      0.0 MiB         512                   g_score[neighbor] = temp_g_score
    75     73.5 MiB      0.0 MiB         512                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.5 MiB      0.0 MiB         512                   if neighbor not in open_set_hash:
    77     73.5 MiB      0.0 MiB         512                       count += 1
    78     73.5 MiB      0.0 MiB         512                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.5 MiB      0.0 MiB         512                       open_set_hash.add(neighbor)
    80                                                             
    81     73.5 MiB      0.0 MiB         377           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.5 MiB      0.0 MiB         377           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.5 MiB     73.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.5 MiB      0.0 MiB         129       for row in grid:
    32     73.5 MiB      0.0 MiB       16512           for spot in row:
    33     73.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.5 MiB      0.0 MiB           1       count = 0
    36     73.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.5 MiB      0.0 MiB           1       came_from = {}
    39     73.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.5 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.5 MiB      0.0 MiB         252       while not open_set.empty():
    49     73.5 MiB      0.0 MiB         252           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.5 MiB      0.0 MiB         252           current = open_set.get()[2]
    55     73.5 MiB      0.0 MiB         252           open_set_hash.remove(current)
    56                                         
    57     73.5 MiB      0.0 MiB         252           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.5 MiB      0.0 MiB         252           if current == end:
    62     73.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.5 MiB      0.0 MiB        2259           for neighbor in current.neighbors:
    67     73.5 MiB      0.0 MiB        2008               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.5 MiB      0.0 MiB        1004                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.5 MiB      0.0 MiB        1004                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.5 MiB      0.0 MiB        2008               if temp_g_score < g_score[neighbor]:
    73     73.5 MiB      0.0 MiB         340                   came_from[neighbor] = current
    74     73.5 MiB      0.0 MiB         340                   g_score[neighbor] = temp_g_score
    75     73.5 MiB      0.0 MiB         340                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.5 MiB      0.0 MiB         340                   if neighbor not in open_set_hash:
    77     73.5 MiB      0.0 MiB         340                       count += 1
    78     73.5 MiB      0.0 MiB         340                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.5 MiB      0.0 MiB         340                       open_set_hash.add(neighbor)
    80                                                             
    81     73.5 MiB      0.0 MiB         251           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.5 MiB      0.0 MiB         251           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.5 MiB     73.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.5 MiB    -71.7 MiB         129       for row in grid:
    32     73.5 MiB  -9226.2 MiB       16512           for spot in row:
    33     73.5 MiB  -9154.9 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB     -0.6 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB         960       while not open_set.empty():
    49     72.9 MiB      0.0 MiB         960           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB         960           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB         960           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB         960           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB         960           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB        8631           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB        7672               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        3836                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        3836                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB        7672               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB        1230                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB        1230                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB        1230                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB        1230                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB        1230                       count += 1
    78     72.9 MiB      0.0 MiB        1230                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB        1230                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB         959           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB         959           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB          40       while not open_set.empty():
    49     72.9 MiB      0.0 MiB          40           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB          40           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB          40           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB          40           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB          40           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB         351           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB         312               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB         156                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB         156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB         312               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB          74                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB          74                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB          74                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB          74                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB          74                       count += 1
    78     72.9 MiB      0.0 MiB          74                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB          74                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB          39           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB          39           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB         990       while not open_set.empty():
    49     72.9 MiB      0.0 MiB         990           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB         990           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB         990           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB         990           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB         990           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB        8901           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB        7912               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        3956                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        3956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB        7912               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB        1244                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB        1244                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB        1244                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB        1244                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB        1244                       count += 1
    78     72.9 MiB      0.0 MiB        1244                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB        1244                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB         989           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB         989           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB        1887       while not open_set.empty():
    49     72.9 MiB      0.0 MiB        1887           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB        1887           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB        1887           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB        1887           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB        1887           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB       16974           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB       15088               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        7544                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        7544                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB       15088               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB        2163                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB        2163                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB        2163                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB        2163                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB        2163                       count += 1
    78     72.9 MiB      0.0 MiB        2163                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB        2163                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB        1886           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB        1886           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB         989       while not open_set.empty():
    49     72.9 MiB      0.0 MiB         989           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB         989           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB         989           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB         989           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB         989           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB        8892           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB        7904               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        3952                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        3952                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB        7904               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB        1205                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB        1205                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB        1205                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB        1205                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB        1205                       count += 1
    78     72.9 MiB      0.0 MiB        1205                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB        1205                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB         988           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB         988           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB         126       while not open_set.empty():
    49     72.9 MiB      0.0 MiB         126           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB         126           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB         126           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB         126           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB         126           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB        1125           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB        1000               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB         500                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB         500                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB        1000               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB         298                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB         298                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB         298                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB         298                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB         298                       count += 1
    78     72.9 MiB      0.0 MiB         298                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB         298                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB         125           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB         125           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB        2628       while not open_set.empty():
    49     72.9 MiB      0.0 MiB        2628           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB        2628           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB        2628           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB        2628           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB        2628           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB       23643           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB       21016               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB       10508                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB       10508                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB       21016               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB        2916                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB        2916                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB        2916                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB        2916                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB        2916                       count += 1
    78     72.9 MiB      0.0 MiB        2916                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB        2916                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB        2627           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB        2627           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB        1860       while not open_set.empty():
    49     72.9 MiB      0.0 MiB        1860           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB        1860           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB        1860           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB        1860           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB        1860           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB       16731           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB       14872               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        7436                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        7436                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB       14872               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB        2160                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB        2160                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB        2160                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB        2160                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB        2160                       count += 1
    78     72.9 MiB      0.0 MiB        2160                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB        2160                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB        1859           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB        1859           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB        3034       while not open_set.empty():
    49     72.9 MiB      0.0 MiB        3034           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB        3034           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB        3034           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB        3034           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB        3034           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB       27297           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB       24264               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB       12132                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB       12132                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB       24264               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB        3344                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB        3344                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB        3344                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB        3344                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB        3344                       count += 1
    78     72.9 MiB      0.0 MiB        3344                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB        3344                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB        3033           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB        3033           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB         343       while not open_set.empty():
    49     72.9 MiB      0.0 MiB         343           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB         343           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB         343           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB         343           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB         343           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB        3078           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB        2736               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        1368                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        1368                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB        2736               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB         467                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB         467                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB         467                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB         467                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB         467                       count += 1
    78     72.9 MiB      0.0 MiB         467                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB         467                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB         342           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB         342           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.9 MiB     71.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.9 MiB      0.0 MiB         129       for row in grid:
    32     71.9 MiB      0.0 MiB       16512           for spot in row:
    33     71.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.9 MiB      0.0 MiB           1       count = 0
    36     71.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.9 MiB      0.0 MiB           1       came_from = {}
    39     71.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.9 MiB      0.0 MiB         224       while not open_set.empty():
    49     71.9 MiB      0.0 MiB         224           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.9 MiB      0.0 MiB         224           current = open_set.get()[2]
    55     71.9 MiB      0.0 MiB         224           open_set_hash.remove(current)
    56                                         
    57     71.9 MiB      0.0 MiB         224           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.9 MiB      0.0 MiB         224           if current == end:
    62     71.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.9 MiB      0.0 MiB        2007           for neighbor in current.neighbors:
    67     71.9 MiB      0.0 MiB        1784               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.9 MiB      0.0 MiB         892                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.9 MiB      0.0 MiB         892                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.9 MiB      0.0 MiB        1784               if temp_g_score < g_score[neighbor]:
    73     71.9 MiB      0.0 MiB         314                   came_from[neighbor] = current
    74     71.9 MiB      0.0 MiB         314                   g_score[neighbor] = temp_g_score
    75     71.9 MiB      0.0 MiB         314                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.9 MiB      0.0 MiB         314                   if neighbor not in open_set_hash:
    77     71.9 MiB      0.0 MiB         314                       count += 1
    78     71.9 MiB      0.0 MiB         314                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.9 MiB      0.0 MiB         314                       open_set_hash.add(neighbor)
    80                                                             
    81     71.9 MiB      0.0 MiB         223           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.9 MiB      0.0 MiB         223           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.9 MiB     71.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.9 MiB      0.0 MiB         129       for row in grid:
    32     71.9 MiB      0.0 MiB       16512           for spot in row:
    33     71.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.9 MiB      0.0 MiB           1       count = 0
    36     71.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.9 MiB      0.0 MiB           1       came_from = {}
    39     71.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.9 MiB      0.0 MiB         240       while not open_set.empty():
    49     71.9 MiB      0.0 MiB         240           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.9 MiB      0.0 MiB         240           current = open_set.get()[2]
    55     71.9 MiB      0.0 MiB         240           open_set_hash.remove(current)
    56                                         
    57     71.9 MiB      0.0 MiB         240           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.9 MiB      0.0 MiB         240           if current == end:
    62     71.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.9 MiB      0.0 MiB        2151           for neighbor in current.neighbors:
    67     71.9 MiB      0.0 MiB        1912               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.9 MiB      0.0 MiB         956                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.9 MiB      0.0 MiB         956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.9 MiB      0.0 MiB        1912               if temp_g_score < g_score[neighbor]:
    73     71.9 MiB      0.0 MiB         374                   came_from[neighbor] = current
    74     71.9 MiB      0.0 MiB         374                   g_score[neighbor] = temp_g_score
    75     71.9 MiB      0.0 MiB         374                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.9 MiB      0.0 MiB         374                   if neighbor not in open_set_hash:
    77     71.9 MiB      0.0 MiB         374                       count += 1
    78     71.9 MiB      0.0 MiB         374                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.9 MiB      0.0 MiB         374                       open_set_hash.add(neighbor)
    80                                                             
    81     71.9 MiB      0.0 MiB         239           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.9 MiB      0.0 MiB         239           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     69.9 MiB     69.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     69.9 MiB      0.0 MiB         129       for row in grid:
    32     69.9 MiB      0.0 MiB       16512           for spot in row:
    33     69.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     69.9 MiB      0.0 MiB           1       count = 0
    36     69.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     69.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     69.9 MiB      0.0 MiB           1       came_from = {}
    39     69.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     69.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     69.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     69.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     69.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     69.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     69.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     69.9 MiB      0.0 MiB         160       while not open_set.empty():
    49     69.9 MiB      0.0 MiB         160           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     69.9 MiB      0.0 MiB         160           current = open_set.get()[2]
    55     69.9 MiB      0.0 MiB         160           open_set_hash.remove(current)
    56                                         
    57     69.9 MiB      0.0 MiB         160           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     69.9 MiB      0.0 MiB         160           if current == end:
    62     69.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     69.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     69.9 MiB      0.0 MiB        1431           for neighbor in current.neighbors:
    67     69.9 MiB      0.0 MiB        1272               if current.row != neighbor.row and current.col != neighbor.col:
    68     69.9 MiB      0.0 MiB         636                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     69.9 MiB      0.0 MiB         636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     69.9 MiB      0.0 MiB        1272               if temp_g_score < g_score[neighbor]:
    73     69.9 MiB      0.0 MiB         296                   came_from[neighbor] = current
    74     69.9 MiB      0.0 MiB         296                   g_score[neighbor] = temp_g_score
    75     69.9 MiB      0.0 MiB         296                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     69.9 MiB      0.0 MiB         296                   if neighbor not in open_set_hash:
    77     69.9 MiB      0.0 MiB         296                       count += 1
    78     69.9 MiB      0.0 MiB         296                       open_set.put((f_score[neighbor], count, neighbor))
    79     69.9 MiB      0.0 MiB         296                       open_set_hash.add(neighbor)
    80                                                             
    81     69.9 MiB      0.0 MiB         159           if draw is not None:
    82                                                     draw()
    83                                         
    84     69.9 MiB      0.0 MiB         159           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     69.9 MiB     69.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     69.9 MiB      0.0 MiB         129       for row in grid:
    32     69.9 MiB      0.0 MiB       16512           for spot in row:
    33     69.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     69.9 MiB      0.0 MiB           1       count = 0
    36     69.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     69.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     69.9 MiB      0.0 MiB           1       came_from = {}
    39     69.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     69.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     69.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     69.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     69.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     69.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     69.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     69.9 MiB      0.0 MiB         840       while not open_set.empty():
    49     69.9 MiB      0.0 MiB         840           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     69.9 MiB      0.0 MiB         840           current = open_set.get()[2]
    55     69.9 MiB      0.0 MiB         840           open_set_hash.remove(current)
    56                                         
    57     69.9 MiB      0.0 MiB         840           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     69.9 MiB      0.0 MiB         840           if current == end:
    62     69.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     69.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     69.9 MiB      0.0 MiB        7551           for neighbor in current.neighbors:
    67     69.9 MiB      0.0 MiB        6712               if current.row != neighbor.row and current.col != neighbor.col:
    68     69.9 MiB      0.0 MiB        3356                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     69.9 MiB      0.0 MiB        3356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     69.9 MiB      0.0 MiB        6712               if temp_g_score < g_score[neighbor]:
    73     69.9 MiB      0.0 MiB        1092                   came_from[neighbor] = current
    74     69.9 MiB      0.0 MiB        1092                   g_score[neighbor] = temp_g_score
    75     69.9 MiB      0.0 MiB        1092                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     69.9 MiB      0.0 MiB        1092                   if neighbor not in open_set_hash:
    77     69.9 MiB      0.0 MiB        1092                       count += 1
    78     69.9 MiB      0.0 MiB        1092                       open_set.put((f_score[neighbor], count, neighbor))
    79     69.9 MiB      0.0 MiB        1092                       open_set_hash.add(neighbor)
    80                                                             
    81     69.9 MiB      0.0 MiB         839           if draw is not None:
    82                                                     draw()
    83                                         
    84     69.9 MiB      0.0 MiB         839           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     69.9 MiB     69.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     69.9 MiB      0.0 MiB         129       for row in grid:
    32     69.9 MiB      0.0 MiB       16512           for spot in row:
    33     69.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     69.9 MiB      0.0 MiB           1       count = 0
    36     69.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     69.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     69.9 MiB      0.0 MiB           1       came_from = {}
    39     69.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     69.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     69.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     69.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     69.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     69.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     69.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     69.9 MiB      0.0 MiB        1300       while not open_set.empty():
    49     69.9 MiB      0.0 MiB        1300           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     69.9 MiB      0.0 MiB        1300           current = open_set.get()[2]
    55     69.9 MiB      0.0 MiB        1300           open_set_hash.remove(current)
    56                                         
    57     69.9 MiB      0.0 MiB        1300           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     69.9 MiB      0.0 MiB        1300           if current == end:
    62     69.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     69.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     69.9 MiB      0.0 MiB       11691           for neighbor in current.neighbors:
    67     69.9 MiB      0.0 MiB       10392               if current.row != neighbor.row and current.col != neighbor.col:
    68     69.9 MiB      0.0 MiB        5196                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     69.9 MiB      0.0 MiB        5196                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     69.9 MiB      0.0 MiB       10392               if temp_g_score < g_score[neighbor]:
    73     69.9 MiB      0.0 MiB        1556                   came_from[neighbor] = current
    74     69.9 MiB      0.0 MiB        1556                   g_score[neighbor] = temp_g_score
    75     69.9 MiB      0.0 MiB        1556                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     69.9 MiB      0.0 MiB        1556                   if neighbor not in open_set_hash:
    77     69.9 MiB      0.0 MiB        1556                       count += 1
    78     69.9 MiB      0.0 MiB        1556                       open_set.put((f_score[neighbor], count, neighbor))
    79     69.9 MiB      0.0 MiB        1556                       open_set_hash.add(neighbor)
    80                                                             
    81     69.9 MiB      0.0 MiB        1299           if draw is not None:
    82                                                     draw()
    83                                         
    84     69.9 MiB      0.0 MiB        1299           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.5 MiB     72.5 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.5 MiB      0.0 MiB         129       for row in grid:
    32     72.5 MiB      0.0 MiB       16512           for spot in row:
    33     72.5 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.5 MiB      0.0 MiB           1       count = 0
    36     72.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.5 MiB      0.0 MiB           1       came_from = {}
    39     72.5 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.5 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.7 MiB      0.2 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.7 MiB      0.0 MiB        1305       while not open_set.empty():
    49     72.7 MiB      0.0 MiB        1305           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.7 MiB      0.0 MiB        1305           current = open_set.get()[2]
    55     72.7 MiB      0.0 MiB        1305           open_set_hash.remove(current)
    56                                         
    57     72.7 MiB      0.0 MiB        1305           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.7 MiB      0.0 MiB        1305           if current == end:
    62     72.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.7 MiB      0.0 MiB       11736           for neighbor in current.neighbors:
    67     72.7 MiB      0.0 MiB       10432               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.7 MiB      0.0 MiB        5216                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.7 MiB      0.0 MiB        5216                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.7 MiB      0.0 MiB       10432               if temp_g_score < g_score[neighbor]:
    73     72.7 MiB      0.0 MiB        1541                   came_from[neighbor] = current
    74     72.7 MiB      0.0 MiB        1541                   g_score[neighbor] = temp_g_score
    75     72.7 MiB      0.0 MiB        1541                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.7 MiB      0.0 MiB        1541                   if neighbor not in open_set_hash:
    77     72.7 MiB      0.0 MiB        1541                       count += 1
    78     72.7 MiB      0.0 MiB        1541                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.7 MiB      0.0 MiB        1541                       open_set_hash.add(neighbor)
    80                                                             
    81     72.7 MiB      0.0 MiB        1304           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.7 MiB      0.0 MiB        1304           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB        1500       while not open_set.empty():
    49     72.9 MiB      0.0 MiB        1500           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB        1500           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB        1500           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB        1500           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB        1500           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB       13491           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB       11992               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        5996                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        5996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB       11992               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB        1718                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB        1718                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB        1718                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB        1718                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB        1718                       count += 1
    78     72.9 MiB      0.0 MiB        1718                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB        1718                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB        1499           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB        1499           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB         855       while not open_set.empty():
    49     72.9 MiB      0.0 MiB         855           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB         855           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB         855           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB         855           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB         855           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB        7686           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB        6832               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        3416                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        3416                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB        6832               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB        1079                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB        1079                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB        1079                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB        1079                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB        1079                       count += 1
    78     72.9 MiB      0.0 MiB        1079                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB        1079                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB         854           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB         854           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB         396       while not open_set.empty():
    49     72.9 MiB      0.0 MiB         396           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB         396           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB         396           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB         396           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB         396           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB        3555           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB        3160               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        1580                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        1580                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB        3160               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB         588                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB         588                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB         588                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB         588                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB         588                       count += 1
    78     72.9 MiB      0.0 MiB         588                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB         588                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB         395           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB         395           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB         567       while not open_set.empty():
    49     72.9 MiB      0.0 MiB         567           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB         567           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB         567           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB         567           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB         567           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB        5094           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB        4528               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        2264                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        2264                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB        4528               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB         755                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB         755                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB         755                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB         755                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB         755                       count += 1
    78     72.9 MiB      0.0 MiB         755                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB         755                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB         566           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB         566           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB         108       while not open_set.empty():
    49     72.9 MiB      0.0 MiB         108           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB         108           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB         108           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB         108           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB         108           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB         963           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB         856               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB         428                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB         428                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB         856               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB         172                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB         172                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB         172                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB         172                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB         172                       count += 1
    78     72.9 MiB      0.0 MiB         172                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB         172                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB         107           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB         107           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB         780       while not open_set.empty():
    49     72.9 MiB      0.0 MiB         780           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB         780           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB         780           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB         780           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB         780           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB        7011           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB        6232               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        3116                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        3116                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB        6232               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB        1062                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB        1062                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB        1062                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB        1062                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB        1062                       count += 1
    78     72.9 MiB      0.0 MiB        1062                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB        1062                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB         779           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB         779           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB         702       while not open_set.empty():
    49     72.9 MiB      0.0 MiB         702           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB         702           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB         702           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB         702           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB         702           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB        6309           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB        5608               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        2804                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        2804                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB        5608               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB         858                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB         858                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB         858                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB         858                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB         858                       count += 1
    78     72.9 MiB      0.0 MiB         858                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB         858                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB         701           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB         701           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB         273       while not open_set.empty():
    49     72.9 MiB      0.0 MiB         273           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB         273           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB         273           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB         273           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB         273           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB        2448           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB        2176               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        1088                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        1088                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB        2176               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB         381                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB         381                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB         381                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB         381                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB         381                       count += 1
    78     72.9 MiB      0.0 MiB         381                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB         381                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB         272           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB         272           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB         720       while not open_set.empty():
    49     72.9 MiB      0.0 MiB         720           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB         720           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB         720           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB         720           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB         720           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB        6471           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB        5752               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        2876                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        2876                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB        5752               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB         902                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB         902                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB         902                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB         902                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB         902                       count += 1
    78     72.9 MiB      0.0 MiB         902                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB         902                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB         719           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB         719           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB         341       while not open_set.empty():
    49     72.9 MiB      0.0 MiB         341           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB         341           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB         341           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB         341           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB         341           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB        3060           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB        2720               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        1360                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        1360                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB        2720               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB         445                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB         445                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB         445                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB         445                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB         445                       count += 1
    78     72.9 MiB      0.0 MiB         445                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB         445                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB         340           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB         340           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB        1073       while not open_set.empty():
    49     72.9 MiB      0.0 MiB        1073           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB        1073           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB        1073           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB        1073           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB        1073           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB        9537           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB        8465               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        4214                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        4251                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB        8465               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB        1222                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB        1222                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB        1222                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB        1222                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB        1222                       count += 1
    78     72.9 MiB      0.0 MiB        1222                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB        1222                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB        1072           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB        1072           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.9 MiB     70.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.9 MiB      0.0 MiB         129       for row in grid:
    32     70.9 MiB      0.0 MiB       16512           for spot in row:
    33     70.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.9 MiB      0.0 MiB           1       count = 0
    36     70.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.9 MiB      0.0 MiB           1       came_from = {}
    39     70.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.9 MiB      0.0 MiB         750       while not open_set.empty():
    49     70.9 MiB      0.0 MiB         750           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.9 MiB      0.0 MiB         750           current = open_set.get()[2]
    55     70.9 MiB      0.0 MiB         750           open_set_hash.remove(current)
    56                                         
    57     70.9 MiB      0.0 MiB         750           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.9 MiB      0.0 MiB         750           if current == end:
    62     70.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.9 MiB      0.0 MiB        6741           for neighbor in current.neighbors:
    67     70.9 MiB      0.0 MiB        5992               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.9 MiB      0.0 MiB        2996                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.9 MiB      0.0 MiB        2996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.9 MiB      0.0 MiB        5992               if temp_g_score < g_score[neighbor]:
    73     70.9 MiB      0.0 MiB         908                   came_from[neighbor] = current
    74     70.9 MiB      0.0 MiB         908                   g_score[neighbor] = temp_g_score
    75     70.9 MiB      0.0 MiB         908                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.9 MiB      0.0 MiB         908                   if neighbor not in open_set_hash:
    77     70.9 MiB      0.0 MiB         908                       count += 1
    78     70.9 MiB      0.0 MiB         908                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.9 MiB      0.0 MiB         908                       open_set_hash.add(neighbor)
    80                                                             
    81     70.9 MiB      0.0 MiB         749           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.9 MiB      0.0 MiB         749           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.9 MiB     70.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.9 MiB      0.0 MiB         129       for row in grid:
    32     70.9 MiB      0.0 MiB       16512           for spot in row:
    33     70.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.9 MiB      0.0 MiB           1       count = 0
    36     70.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.9 MiB      0.0 MiB           1       came_from = {}
    39     70.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.9 MiB      0.0 MiB         567       while not open_set.empty():
    49     70.9 MiB      0.0 MiB         567           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.9 MiB      0.0 MiB         567           current = open_set.get()[2]
    55     70.9 MiB      0.0 MiB         567           open_set_hash.remove(current)
    56                                         
    57     70.9 MiB      0.0 MiB         567           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.9 MiB      0.0 MiB         567           if current == end:
    62     70.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.9 MiB      0.0 MiB        5094           for neighbor in current.neighbors:
    67     70.9 MiB      0.0 MiB        4528               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.9 MiB      0.0 MiB        2264                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.9 MiB      0.0 MiB        2264                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.9 MiB      0.0 MiB        4528               if temp_g_score < g_score[neighbor]:
    73     70.9 MiB      0.0 MiB         755                   came_from[neighbor] = current
    74     70.9 MiB      0.0 MiB         755                   g_score[neighbor] = temp_g_score
    75     70.9 MiB      0.0 MiB         755                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.9 MiB      0.0 MiB         755                   if neighbor not in open_set_hash:
    77     70.9 MiB      0.0 MiB         755                       count += 1
    78     70.9 MiB      0.0 MiB         755                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.9 MiB      0.0 MiB         755                       open_set_hash.add(neighbor)
    80                                                             
    81     70.9 MiB      0.0 MiB         566           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.9 MiB      0.0 MiB         566           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     69.9 MiB     69.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     69.9 MiB      0.0 MiB         129       for row in grid:
    32     69.9 MiB      0.0 MiB       16512           for spot in row:
    33     69.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     69.9 MiB      0.0 MiB           1       count = 0
    36     69.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     69.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     69.9 MiB      0.0 MiB           1       came_from = {}
    39     69.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     69.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     69.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     69.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     69.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     69.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     69.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     69.9 MiB      0.0 MiB         338       while not open_set.empty():
    49     69.9 MiB      0.0 MiB         338           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     69.9 MiB      0.0 MiB         338           current = open_set.get()[2]
    55     69.9 MiB      0.0 MiB         338           open_set_hash.remove(current)
    56                                         
    57     69.9 MiB      0.0 MiB         338           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     69.9 MiB      0.0 MiB         338           if current == end:
    62     69.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     69.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     69.9 MiB      0.0 MiB        3033           for neighbor in current.neighbors:
    67     69.9 MiB      0.0 MiB        2696               if current.row != neighbor.row and current.col != neighbor.col:
    68     69.9 MiB      0.0 MiB        1348                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     69.9 MiB      0.0 MiB        1348                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     69.9 MiB      0.0 MiB        2696               if temp_g_score < g_score[neighbor]:
    73     69.9 MiB      0.0 MiB         440                   came_from[neighbor] = current
    74     69.9 MiB      0.0 MiB         440                   g_score[neighbor] = temp_g_score
    75     69.9 MiB      0.0 MiB         440                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     69.9 MiB      0.0 MiB         440                   if neighbor not in open_set_hash:
    77     69.9 MiB      0.0 MiB         440                       count += 1
    78     69.9 MiB      0.0 MiB         440                       open_set.put((f_score[neighbor], count, neighbor))
    79     69.9 MiB      0.0 MiB         440                       open_set_hash.add(neighbor)
    80                                                             
    81     69.9 MiB      0.0 MiB         337           if draw is not None:
    82                                                     draw()
    83                                         
    84     69.9 MiB      0.0 MiB         337           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     69.9 MiB     69.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     69.9 MiB      0.0 MiB         129       for row in grid:
    32     69.9 MiB      0.0 MiB       16512           for spot in row:
    33     69.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     69.9 MiB      0.0 MiB           1       count = 0
    36     69.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     69.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     69.9 MiB      0.0 MiB           1       came_from = {}
    39     69.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     69.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     69.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     69.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     69.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     69.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     69.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     69.9 MiB      0.0 MiB        2520       while not open_set.empty():
    49     69.9 MiB      0.0 MiB        2520           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     69.9 MiB      0.0 MiB        2520           current = open_set.get()[2]
    55     69.9 MiB      0.0 MiB        2520           open_set_hash.remove(current)
    56                                         
    57     69.9 MiB      0.0 MiB        2520           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     69.9 MiB      0.0 MiB        2520           if current == end:
    62     69.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     69.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     69.9 MiB      0.0 MiB       22671           for neighbor in current.neighbors:
    67     69.9 MiB      0.0 MiB       20152               if current.row != neighbor.row and current.col != neighbor.col:
    68     69.9 MiB      0.0 MiB       10076                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     69.9 MiB      0.0 MiB       10076                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     69.9 MiB      0.0 MiB       20152               if temp_g_score < g_score[neighbor]:
    73     69.9 MiB      0.0 MiB        2802                   came_from[neighbor] = current
    74     69.9 MiB      0.0 MiB        2802                   g_score[neighbor] = temp_g_score
    75     69.9 MiB      0.0 MiB        2802                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     69.9 MiB      0.0 MiB        2802                   if neighbor not in open_set_hash:
    77     69.9 MiB      0.0 MiB        2802                       count += 1
    78     69.9 MiB      0.0 MiB        2802                       open_set.put((f_score[neighbor], count, neighbor))
    79     69.9 MiB      0.0 MiB        2802                       open_set_hash.add(neighbor)
    80                                                             
    81     69.9 MiB      0.0 MiB        2519           if draw is not None:
    82                                                     draw()
    83                                         
    84     69.9 MiB      0.0 MiB        2519           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     69.9 MiB     69.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     69.9 MiB      0.0 MiB         129       for row in grid:
    32     69.9 MiB      0.0 MiB       16512           for spot in row:
    33     69.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     69.9 MiB      0.0 MiB           1       count = 0
    36     69.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     69.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     69.9 MiB      0.0 MiB           1       came_from = {}
    39     69.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     69.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     69.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     69.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     69.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     69.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     69.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     69.9 MiB      0.0 MiB         800       while not open_set.empty():
    49     69.9 MiB      0.0 MiB         800           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     69.9 MiB      0.0 MiB         800           current = open_set.get()[2]
    55     69.9 MiB      0.0 MiB         800           open_set_hash.remove(current)
    56                                         
    57     69.9 MiB      0.0 MiB         800           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     69.9 MiB      0.0 MiB         800           if current == end:
    62     69.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     69.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     69.9 MiB      0.0 MiB        7191           for neighbor in current.neighbors:
    67     69.9 MiB      0.0 MiB        6392               if current.row != neighbor.row and current.col != neighbor.col:
    68     69.9 MiB      0.0 MiB        3196                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     69.9 MiB      0.0 MiB        3196                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     69.9 MiB      0.0 MiB        6392               if temp_g_score < g_score[neighbor]:
    73     69.9 MiB      0.0 MiB         962                   came_from[neighbor] = current
    74     69.9 MiB      0.0 MiB         962                   g_score[neighbor] = temp_g_score
    75     69.9 MiB      0.0 MiB         962                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     69.9 MiB      0.0 MiB         962                   if neighbor not in open_set_hash:
    77     69.9 MiB      0.0 MiB         962                       count += 1
    78     69.9 MiB      0.0 MiB         962                       open_set.put((f_score[neighbor], count, neighbor))
    79     69.9 MiB      0.0 MiB         962                       open_set_hash.add(neighbor)
    80                                                             
    81     69.9 MiB      0.0 MiB         799           if draw is not None:
    82                                                     draw()
    83                                         
    84     69.9 MiB      0.0 MiB         799           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.6 MiB     72.6 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.6 MiB      0.0 MiB         129       for row in grid:
    32     72.6 MiB      0.0 MiB       16512           for spot in row:
    33     72.6 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.6 MiB      0.0 MiB           1       count = 0
    36     72.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.6 MiB      0.0 MiB           1       came_from = {}
    39     72.6 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.6 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.6 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.6 MiB      0.0 MiB        1786       while not open_set.empty():
    49     72.6 MiB      0.0 MiB        1786           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.6 MiB      0.0 MiB        1786           current = open_set.get()[2]
    55     72.6 MiB      0.0 MiB        1786           open_set_hash.remove(current)
    56                                         
    57     72.6 MiB      0.0 MiB        1786           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.6 MiB      0.0 MiB        1786           if current == end:
    62     72.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.6 MiB      0.0 MiB       16065           for neighbor in current.neighbors:
    67     72.6 MiB      0.0 MiB       14280               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.6 MiB      0.0 MiB        7140                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.6 MiB      0.0 MiB        7140                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.6 MiB      0.0 MiB       14280               if temp_g_score < g_score[neighbor]:
    73     72.6 MiB      0.0 MiB        2030                   came_from[neighbor] = current
    74     72.6 MiB      0.0 MiB        2030                   g_score[neighbor] = temp_g_score
    75     72.6 MiB      0.0 MiB        2030                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.6 MiB      0.0 MiB        2030                   if neighbor not in open_set_hash:
    77     72.6 MiB      0.0 MiB        2030                       count += 1
    78     72.6 MiB      0.0 MiB        2030                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.6 MiB      0.0 MiB        2030                       open_set_hash.add(neighbor)
    80                                                             
    81     72.6 MiB      0.0 MiB        1785           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.6 MiB      0.0 MiB        1785           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB         424       while not open_set.empty():
    49     72.9 MiB      0.0 MiB         424           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB         424           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB         424           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB         424           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB         424           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB        3807           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB        3384               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        1692                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        1692                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB        3384               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB         560                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB         560                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB         560                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB         560                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB         560                       count += 1
    78     72.9 MiB      0.0 MiB         560                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB         560                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB         423           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB         423           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB          64       while not open_set.empty():
    49     72.9 MiB      0.0 MiB          64           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB          64           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB          64           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB          64           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB          64           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB         567           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB         504               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB         252                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB         252                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB         504               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB         134                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB         134                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB         134                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB         134                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB         134                       count += 1
    78     72.9 MiB      0.0 MiB         134                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB         134                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB          63           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB          63           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB         403       while not open_set.empty():
    49     72.9 MiB      0.0 MiB         403           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB         403           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB         403           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB         403           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB         403           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB        3618           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB        3216               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        1608                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        1608                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB        3216               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB         515                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB         515                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB         515                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB         515                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB         515                       count += 1
    78     72.9 MiB      0.0 MiB         515                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB         515                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB         402           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB         402           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.1 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB          93       while not open_set.empty():
    49     72.9 MiB      0.0 MiB          93           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB          93           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB          93           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB          93           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB          93           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB         828           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB         736               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB         368                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB         368                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB         736               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB         165                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB         165                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB         165                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB         165                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB         165                       count += 1
    78     72.9 MiB      0.0 MiB         165                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB         165                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB          92           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB          92           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.9 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.9 MiB      0.0 MiB        1170       while not open_set.empty():
    49     72.9 MiB      0.0 MiB        1170           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.9 MiB      0.0 MiB        1170           current = open_set.get()[2]
    55     72.9 MiB      0.0 MiB        1170           open_set_hash.remove(current)
    56                                         
    57     72.9 MiB      0.0 MiB        1170           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.9 MiB      0.0 MiB        1170           if current == end:
    62     72.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.9 MiB      0.0 MiB       10521           for neighbor in current.neighbors:
    67     72.9 MiB      0.0 MiB        9352               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.9 MiB      0.0 MiB        4676                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.9 MiB      0.0 MiB        4676                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.9 MiB      0.0 MiB        9352               if temp_g_score < g_score[neighbor]:
    73     72.9 MiB      0.0 MiB        1510                   came_from[neighbor] = current
    74     72.9 MiB      0.0 MiB        1510                   g_score[neighbor] = temp_g_score
    75     72.9 MiB      0.0 MiB        1510                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.9 MiB      0.0 MiB        1510                   if neighbor not in open_set_hash:
    77     72.9 MiB      0.0 MiB        1510                       count += 1
    78     72.9 MiB      0.0 MiB        1510                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.9 MiB      0.0 MiB        1510                       open_set_hash.add(neighbor)
    80                                                             
    81     72.9 MiB      0.0 MiB        1169           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.9 MiB      0.0 MiB        1169           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     72.9 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.2 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB          84       while not open_set.empty():
    49     73.1 MiB      0.0 MiB          84           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB          84           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB          84           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB          84           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB          84           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB         747           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB         664               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB         332                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB         332                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB         664               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         150                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         150                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         150                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         150                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         150                       count += 1
    78     73.1 MiB      0.0 MiB         150                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         150                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB          83           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB          83           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB        1222       while not open_set.empty():
    49     73.1 MiB      0.0 MiB        1222           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB        1222           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB        1222           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB        1222           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB        1222           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB       10989           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        9768               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        4884                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        4884                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        9768               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB        1418                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB        1418                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB        1418                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB        1418                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB        1418                       count += 1
    78     73.1 MiB      0.0 MiB        1418                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB        1418                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB        1221           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB        1221           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         680       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         680           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         680           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         680           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         680           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         680           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        6111           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        5432               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        2716                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        2716                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        5432               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         826                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         826                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         826                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         826                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         826                       count += 1
    78     73.1 MiB      0.0 MiB         826                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         826                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         679           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         679           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB          38       while not open_set.empty():
    49     73.1 MiB      0.0 MiB          38           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB          38           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB          38           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB          38           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB          38           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB         333           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB         296               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB         148                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB         148                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB         296               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         188                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         188                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         188                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         188                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         188                       count += 1
    78     73.1 MiB      0.0 MiB         188                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         188                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB          37           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB          37           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         242       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         242           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         242           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         242           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         242           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         242           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        2169           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        1928               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB         964                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB         964                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        1928               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         350                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         350                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         350                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         350                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         350                       count += 1
    78     73.1 MiB      0.0 MiB         350                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         350                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         241           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         241           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB        1008       while not open_set.empty():
    49     73.1 MiB      0.0 MiB        1008           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB        1008           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB        1008           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB        1008           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB        1008           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        9063           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        8056               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        4028                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        4028                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        8056               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB        1196                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB        1196                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB        1196                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB        1196                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB        1196                       count += 1
    78     73.1 MiB      0.0 MiB        1196                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB        1196                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB        1007           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB        1007           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.1 MiB     72.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.1 MiB      0.0 MiB         129       for row in grid:
    32     72.1 MiB      0.0 MiB       16512           for spot in row:
    33     72.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.1 MiB      0.0 MiB           1       count = 0
    36     72.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.1 MiB      0.0 MiB           1       came_from = {}
    39     72.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.1 MiB      0.0 MiB         864       while not open_set.empty():
    49     72.1 MiB      0.0 MiB         864           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.1 MiB      0.0 MiB         864           current = open_set.get()[2]
    55     72.1 MiB      0.0 MiB         864           open_set_hash.remove(current)
    56                                         
    57     72.1 MiB      0.0 MiB         864           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.1 MiB      0.0 MiB         864           if current == end:
    62     72.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.1 MiB      0.0 MiB        7767           for neighbor in current.neighbors:
    67     72.1 MiB      0.0 MiB        6904               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.1 MiB      0.0 MiB        3452                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.1 MiB      0.0 MiB        3452                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.1 MiB      0.0 MiB        6904               if temp_g_score < g_score[neighbor]:
    73     72.1 MiB      0.0 MiB        1174                   came_from[neighbor] = current
    74     72.1 MiB      0.0 MiB        1174                   g_score[neighbor] = temp_g_score
    75     72.1 MiB      0.0 MiB        1174                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.1 MiB      0.0 MiB        1174                   if neighbor not in open_set_hash:
    77     72.1 MiB      0.0 MiB        1174                       count += 1
    78     72.1 MiB      0.0 MiB        1174                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.1 MiB      0.0 MiB        1174                       open_set_hash.add(neighbor)
    80                                                             
    81     72.1 MiB      0.0 MiB         863           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.1 MiB      0.0 MiB         863           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.1 MiB     72.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.1 MiB      0.0 MiB         129       for row in grid:
    32     72.1 MiB      0.0 MiB       16512           for spot in row:
    33     72.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.1 MiB      0.0 MiB           1       count = 0
    36     72.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.1 MiB      0.0 MiB           1       came_from = {}
    39     72.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.1 MiB      0.0 MiB         840       while not open_set.empty():
    49     72.1 MiB      0.0 MiB         840           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.1 MiB      0.0 MiB         840           current = open_set.get()[2]
    55     72.1 MiB      0.0 MiB         840           open_set_hash.remove(current)
    56                                         
    57     72.1 MiB      0.0 MiB         840           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.1 MiB      0.0 MiB         840           if current == end:
    62     72.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.1 MiB      0.0 MiB        7551           for neighbor in current.neighbors:
    67     72.1 MiB      0.0 MiB        6712               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.1 MiB      0.0 MiB        3356                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.1 MiB      0.0 MiB        3356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.1 MiB      0.0 MiB        6712               if temp_g_score < g_score[neighbor]:
    73     72.1 MiB      0.0 MiB        1026                   came_from[neighbor] = current
    74     72.1 MiB      0.0 MiB        1026                   g_score[neighbor] = temp_g_score
    75     72.1 MiB      0.0 MiB        1026                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.1 MiB      0.0 MiB        1026                   if neighbor not in open_set_hash:
    77     72.1 MiB      0.0 MiB        1026                       count += 1
    78     72.1 MiB      0.0 MiB        1026                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.1 MiB      0.0 MiB        1026                       open_set_hash.add(neighbor)
    80                                                             
    81     72.1 MiB      0.0 MiB         839           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.1 MiB      0.0 MiB         839           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.1 MiB     71.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.1 MiB      0.0 MiB         129       for row in grid:
    32     71.1 MiB      0.0 MiB       16512           for spot in row:
    33     71.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.1 MiB      0.0 MiB           1       count = 0
    36     71.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.1 MiB      0.0 MiB           1       came_from = {}
    39     71.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.1 MiB   -273.0 MiB         880       while not open_set.empty():
    49     71.1 MiB   -273.0 MiB         880           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.1 MiB   -273.0 MiB         880           current = open_set.get()[2]
    55     71.1 MiB   -273.0 MiB         880           open_set_hash.remove(current)
    56                                         
    57     71.1 MiB   -273.0 MiB         880           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.1 MiB   -273.0 MiB         880           if current == end:
    62     70.4 MiB     -0.8 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.1 MiB  -2452.9 MiB        7911           for neighbor in current.neighbors:
    67     71.1 MiB  -2180.1 MiB        7032               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.1 MiB  -1091.1 MiB        3516                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.1 MiB  -1089.1 MiB        3516                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.1 MiB  -2180.2 MiB        7032               if temp_g_score < g_score[neighbor]:
    73     71.1 MiB   -326.0 MiB        1094                   came_from[neighbor] = current
    74     71.1 MiB   -326.0 MiB        1094                   g_score[neighbor] = temp_g_score
    75     71.1 MiB   -326.2 MiB        1094                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.1 MiB   -326.3 MiB        1094                   if neighbor not in open_set_hash:
    77     71.1 MiB   -326.3 MiB        1094                       count += 1
    78     71.1 MiB   -326.3 MiB        1094                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.1 MiB   -326.3 MiB        1094                       open_set_hash.add(neighbor)
    80                                                             
    81     71.1 MiB   -273.0 MiB         879           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.1 MiB   -273.0 MiB         879           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.4 MiB     70.4 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.4 MiB     -4.9 MiB         129       for row in grid:
    32     70.4 MiB   -628.1 MiB       16512           for spot in row:
    33     70.4 MiB   -623.3 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.3 MiB     -0.1 MiB           1       count = 0
    36     70.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.3 MiB      0.0 MiB           1       came_from = {}
    39     70.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.3 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.3 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.3 MiB      0.0 MiB         624       while not open_set.empty():
    49     70.3 MiB      0.0 MiB         624           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.3 MiB      0.0 MiB         624           current = open_set.get()[2]
    55     70.3 MiB      0.0 MiB         624           open_set_hash.remove(current)
    56                                         
    57     70.3 MiB      0.0 MiB         624           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.3 MiB      0.0 MiB         624           if current == end:
    62     70.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.3 MiB      0.0 MiB        5607           for neighbor in current.neighbors:
    67     70.3 MiB      0.0 MiB        4984               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.3 MiB      0.0 MiB        2492                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.3 MiB      0.0 MiB        2492                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.3 MiB      0.0 MiB        4984               if temp_g_score < g_score[neighbor]:
    73     70.3 MiB      0.0 MiB         770                   came_from[neighbor] = current
    74     70.3 MiB      0.0 MiB         770                   g_score[neighbor] = temp_g_score
    75     70.3 MiB      0.0 MiB         770                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.3 MiB      0.0 MiB         770                   if neighbor not in open_set_hash:
    77     70.3 MiB      0.0 MiB         770                       count += 1
    78     70.3 MiB      0.0 MiB         770                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.3 MiB      0.0 MiB         770                       open_set_hash.add(neighbor)
    80                                                             
    81     70.3 MiB      0.0 MiB         623           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.3 MiB      0.0 MiB         623           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.3 MiB     70.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.3 MiB      0.0 MiB         129       for row in grid:
    32     70.3 MiB      0.0 MiB       16512           for spot in row:
    33     70.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.3 MiB      0.0 MiB           1       count = 0
    36     70.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.3 MiB      0.0 MiB           1       came_from = {}
    39     70.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.3 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.3 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.3 MiB      0.0 MiB        2280       while not open_set.empty():
    49     70.3 MiB      0.0 MiB        2280           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.3 MiB      0.0 MiB        2280           current = open_set.get()[2]
    55     70.3 MiB      0.0 MiB        2280           open_set_hash.remove(current)
    56                                         
    57     70.3 MiB      0.0 MiB        2280           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.3 MiB      0.0 MiB        2280           if current == end:
    62     70.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.3 MiB      0.0 MiB       20511           for neighbor in current.neighbors:
    67     70.3 MiB      0.0 MiB       18232               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.3 MiB      0.0 MiB        9116                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.3 MiB      0.0 MiB        9116                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.3 MiB      0.0 MiB       18232               if temp_g_score < g_score[neighbor]:
    73     70.3 MiB      0.0 MiB        2594                   came_from[neighbor] = current
    74     70.3 MiB      0.0 MiB        2594                   g_score[neighbor] = temp_g_score
    75     70.3 MiB      0.0 MiB        2594                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.3 MiB      0.0 MiB        2594                   if neighbor not in open_set_hash:
    77     70.3 MiB      0.0 MiB        2594                       count += 1
    78     70.3 MiB      0.0 MiB        2594                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.3 MiB      0.0 MiB        2594                       open_set_hash.add(neighbor)
    80                                                             
    81     70.3 MiB      0.0 MiB        2279           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.3 MiB      0.0 MiB        2279           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.1 MiB     72.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.1 MiB      0.0 MiB         129       for row in grid:
    32     72.1 MiB      0.0 MiB       16512           for spot in row:
    33     72.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.1 MiB      0.0 MiB           1       count = 0
    36     72.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.1 MiB      0.0 MiB           1       came_from = {}
    39     72.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.3 MiB      0.2 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.3 MiB      0.0 MiB         364       while not open_set.empty():
    49     72.3 MiB      0.0 MiB         364           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.3 MiB      0.0 MiB         364           current = open_set.get()[2]
    55     72.3 MiB      0.0 MiB         364           open_set_hash.remove(current)
    56                                         
    57     72.3 MiB      0.0 MiB         364           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.3 MiB      0.0 MiB         364           if current == end:
    62     72.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.3 MiB      0.0 MiB        3267           for neighbor in current.neighbors:
    67     72.3 MiB      0.0 MiB        2904               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.3 MiB      0.0 MiB        1452                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.3 MiB      0.0 MiB        1452                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.3 MiB      0.0 MiB        2904               if temp_g_score < g_score[neighbor]:
    73     72.3 MiB      0.0 MiB         494                   came_from[neighbor] = current
    74     72.3 MiB      0.0 MiB         494                   g_score[neighbor] = temp_g_score
    75     72.3 MiB      0.0 MiB         494                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.3 MiB      0.0 MiB         494                   if neighbor not in open_set_hash:
    77     72.3 MiB      0.0 MiB         494                       count += 1
    78     72.3 MiB      0.0 MiB         494                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.3 MiB      0.0 MiB         494                       open_set_hash.add(neighbor)
    80                                                             
    81     72.3 MiB      0.0 MiB         363           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.3 MiB      0.0 MiB         363           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.3 MiB     72.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.3 MiB      0.0 MiB         129       for row in grid:
    32     72.3 MiB      0.0 MiB       16512           for spot in row:
    33     72.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.3 MiB      0.0 MiB           1       count = 0
    36     72.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.3 MiB      0.0 MiB           1       came_from = {}
    39     72.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.3 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.3 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.3 MiB      0.0 MiB        2450       while not open_set.empty():
    49     72.3 MiB      0.0 MiB        2450           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.3 MiB      0.0 MiB        2450           current = open_set.get()[2]
    55     72.3 MiB      0.0 MiB        2450           open_set_hash.remove(current)
    56                                         
    57     72.3 MiB      0.0 MiB        2450           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.3 MiB      0.0 MiB        2450           if current == end:
    62     72.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.3 MiB      0.0 MiB       22041           for neighbor in current.neighbors:
    67     72.3 MiB      0.0 MiB       19592               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.3 MiB      0.0 MiB        9796                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.3 MiB      0.0 MiB        9796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.3 MiB      0.0 MiB       19592               if temp_g_score < g_score[neighbor]:
    73     72.3 MiB      0.0 MiB        2746                   came_from[neighbor] = current
    74     72.3 MiB      0.0 MiB        2746                   g_score[neighbor] = temp_g_score
    75     72.3 MiB      0.0 MiB        2746                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.3 MiB      0.0 MiB        2746                   if neighbor not in open_set_hash:
    77     72.3 MiB      0.0 MiB        2746                       count += 1
    78     72.3 MiB      0.0 MiB        2746                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.3 MiB      0.0 MiB        2746                       open_set_hash.add(neighbor)
    80                                                             
    81     72.3 MiB      0.0 MiB        2449           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.3 MiB      0.0 MiB        2449           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.3 MiB     72.3 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.3 MiB      0.0 MiB         129       for row in grid:
    32     72.3 MiB      0.0 MiB       16512           for spot in row:
    33     72.3 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.3 MiB      0.0 MiB           1       count = 0
    36     72.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.3 MiB      0.0 MiB           1       came_from = {}
    39     72.3 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.3 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.7 MiB      0.4 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.7 MiB      0.0 MiB        1245       while not open_set.empty():
    49     72.7 MiB      0.0 MiB        1245           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.7 MiB      0.0 MiB        1245           current = open_set.get()[2]
    55     72.7 MiB      0.0 MiB        1245           open_set_hash.remove(current)
    56                                         
    57     72.7 MiB      0.0 MiB        1245           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.7 MiB      0.0 MiB        1245           if current == end:
    62     72.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.7 MiB      0.0 MiB       11196           for neighbor in current.neighbors:
    67     72.7 MiB      0.0 MiB        9952               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.7 MiB      0.0 MiB        4976                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.7 MiB      0.0 MiB        4976                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.7 MiB      0.0 MiB        9952               if temp_g_score < g_score[neighbor]:
    73     72.7 MiB      0.0 MiB        1605                   came_from[neighbor] = current
    74     72.7 MiB      0.0 MiB        1605                   g_score[neighbor] = temp_g_score
    75     72.7 MiB      0.0 MiB        1605                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.7 MiB      0.0 MiB        1605                   if neighbor not in open_set_hash:
    77     72.7 MiB      0.0 MiB        1605                       count += 1
    78     72.7 MiB      0.0 MiB        1605                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.7 MiB      0.0 MiB        1605                       open_set_hash.add(neighbor)
    80                                                             
    81     72.7 MiB      0.0 MiB        1244           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.7 MiB      0.0 MiB        1244           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.7 MiB     72.7 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.7 MiB      0.0 MiB         129       for row in grid:
    32     72.7 MiB      0.0 MiB       16512           for spot in row:
    33     72.7 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.7 MiB      0.0 MiB           1       count = 0
    36     72.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.7 MiB      0.0 MiB           1       came_from = {}
    39     72.7 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.7 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.7 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.7 MiB      0.0 MiB         468       while not open_set.empty():
    49     72.7 MiB      0.0 MiB         468           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.7 MiB      0.0 MiB         468           current = open_set.get()[2]
    55     72.7 MiB      0.0 MiB         468           open_set_hash.remove(current)
    56                                         
    57     72.7 MiB      0.0 MiB         468           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.7 MiB      0.0 MiB         468           if current == end:
    62     72.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.7 MiB      0.0 MiB        4203           for neighbor in current.neighbors:
    67     72.7 MiB      0.0 MiB        3736               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.7 MiB      0.0 MiB        1868                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.7 MiB      0.0 MiB        1868                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.7 MiB      0.0 MiB        3736               if temp_g_score < g_score[neighbor]:
    73     72.7 MiB      0.0 MiB         592                   came_from[neighbor] = current
    74     72.7 MiB      0.0 MiB         592                   g_score[neighbor] = temp_g_score
    75     72.7 MiB      0.0 MiB         592                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.7 MiB      0.0 MiB         592                   if neighbor not in open_set_hash:
    77     72.7 MiB      0.0 MiB         592                       count += 1
    78     72.7 MiB      0.0 MiB         592                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.7 MiB      0.0 MiB         592                       open_set_hash.add(neighbor)
    80                                                             
    81     72.7 MiB      0.0 MiB         467           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.7 MiB      0.0 MiB         467           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.7 MiB     72.7 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.7 MiB      0.0 MiB         129       for row in grid:
    32     72.7 MiB      0.0 MiB       16512           for spot in row:
    33     72.7 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.7 MiB      0.0 MiB           1       count = 0
    36     72.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.7 MiB      0.0 MiB           1       came_from = {}
    39     72.7 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.7 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.7 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.7 MiB      0.0 MiB         539       while not open_set.empty():
    49     72.7 MiB      0.0 MiB         539           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.7 MiB      0.0 MiB         539           current = open_set.get()[2]
    55     72.7 MiB      0.0 MiB         539           open_set_hash.remove(current)
    56                                         
    57     72.7 MiB      0.0 MiB         539           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.7 MiB      0.0 MiB         539           if current == end:
    62     72.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.7 MiB      0.0 MiB        4842           for neighbor in current.neighbors:
    67     72.7 MiB      0.0 MiB        4304               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.7 MiB      0.0 MiB        2152                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.7 MiB      0.0 MiB        2152                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.7 MiB      0.0 MiB        4304               if temp_g_score < g_score[neighbor]:
    73     72.7 MiB      0.0 MiB         859                   came_from[neighbor] = current
    74     72.7 MiB      0.0 MiB         859                   g_score[neighbor] = temp_g_score
    75     72.7 MiB      0.0 MiB         859                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.7 MiB      0.0 MiB         859                   if neighbor not in open_set_hash:
    77     72.7 MiB      0.0 MiB         859                       count += 1
    78     72.7 MiB      0.0 MiB         859                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.7 MiB      0.0 MiB         859                       open_set_hash.add(neighbor)
    80                                                             
    81     72.7 MiB      0.0 MiB         538           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.7 MiB      0.0 MiB         538           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.7 MiB     72.7 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.7 MiB      0.0 MiB         129       for row in grid:
    32     72.7 MiB      0.0 MiB       16512           for spot in row:
    33     72.7 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.7 MiB      0.0 MiB           1       count = 0
    36     72.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.7 MiB      0.0 MiB           1       came_from = {}
    39     72.7 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.7 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.7 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.7 MiB      0.0 MiB         504       while not open_set.empty():
    49     72.7 MiB      0.0 MiB         504           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.7 MiB      0.0 MiB         504           current = open_set.get()[2]
    55     72.7 MiB      0.0 MiB         504           open_set_hash.remove(current)
    56                                         
    57     72.7 MiB      0.0 MiB         504           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.7 MiB      0.0 MiB         504           if current == end:
    62     72.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.7 MiB      0.0 MiB        4527           for neighbor in current.neighbors:
    67     72.7 MiB      0.0 MiB        4024               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.7 MiB      0.0 MiB        2012                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.7 MiB      0.0 MiB        2012                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.7 MiB      0.0 MiB        4024               if temp_g_score < g_score[neighbor]:
    73     72.7 MiB      0.0 MiB         660                   came_from[neighbor] = current
    74     72.7 MiB      0.0 MiB         660                   g_score[neighbor] = temp_g_score
    75     72.7 MiB      0.0 MiB         660                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.7 MiB      0.0 MiB         660                   if neighbor not in open_set_hash:
    77     72.7 MiB      0.0 MiB         660                       count += 1
    78     72.7 MiB      0.0 MiB         660                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.7 MiB      0.0 MiB         660                       open_set_hash.add(neighbor)
    80                                                             
    81     72.7 MiB      0.0 MiB         503           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.7 MiB      0.0 MiB         503           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.7 MiB     72.7 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.7 MiB      0.0 MiB         129       for row in grid:
    32     72.7 MiB      0.0 MiB       16512           for spot in row:
    33     72.7 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.7 MiB      0.0 MiB           1       count = 0
    36     72.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.7 MiB      0.0 MiB           1       came_from = {}
    39     72.7 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.7 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.8 MiB      0.1 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.8 MiB      0.0 MiB         410       while not open_set.empty():
    49     72.8 MiB      0.0 MiB         410           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.8 MiB      0.0 MiB         410           current = open_set.get()[2]
    55     72.8 MiB      0.0 MiB         410           open_set_hash.remove(current)
    56                                         
    57     72.8 MiB      0.0 MiB         410           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.8 MiB      0.0 MiB         410           if current == end:
    62     72.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.8 MiB      0.0 MiB        3681           for neighbor in current.neighbors:
    67     72.8 MiB      0.0 MiB        3272               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.8 MiB      0.0 MiB        1636                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.8 MiB      0.0 MiB        1636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.8 MiB      0.0 MiB        3272               if temp_g_score < g_score[neighbor]:
    73     72.8 MiB      0.0 MiB         592                   came_from[neighbor] = current
    74     72.8 MiB      0.0 MiB         592                   g_score[neighbor] = temp_g_score
    75     72.8 MiB      0.0 MiB         592                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.8 MiB      0.0 MiB         592                   if neighbor not in open_set_hash:
    77     72.8 MiB      0.0 MiB         592                       count += 1
    78     72.8 MiB      0.0 MiB         592                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.8 MiB      0.0 MiB         592                       open_set_hash.add(neighbor)
    80                                                             
    81     72.8 MiB      0.0 MiB         409           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.8 MiB      0.0 MiB         409           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.8 MiB     72.8 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.8 MiB      0.0 MiB         129       for row in grid:
    32     72.8 MiB      0.0 MiB       16512           for spot in row:
    33     72.8 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.8 MiB      0.0 MiB           1       count = 0
    36     72.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.8 MiB      0.0 MiB           1       came_from = {}
    39     72.8 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.8 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.8 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.8 MiB      0.0 MiB        2835       while not open_set.empty():
    49     72.8 MiB      0.0 MiB        2835           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.8 MiB      0.0 MiB        2835           current = open_set.get()[2]
    55     72.8 MiB      0.0 MiB        2835           open_set_hash.remove(current)
    56                                         
    57     72.8 MiB      0.0 MiB        2835           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.8 MiB      0.0 MiB        2835           if current == end:
    62     72.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.8 MiB      0.0 MiB       25506           for neighbor in current.neighbors:
    67     72.8 MiB      0.0 MiB       22672               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.8 MiB      0.0 MiB       11336                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.8 MiB      0.0 MiB       11336                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.8 MiB      0.0 MiB       22672               if temp_g_score < g_score[neighbor]:
    73     72.8 MiB      0.0 MiB        3175                   came_from[neighbor] = current
    74     72.8 MiB      0.0 MiB        3175                   g_score[neighbor] = temp_g_score
    75     72.8 MiB      0.0 MiB        3175                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.8 MiB      0.0 MiB        3175                   if neighbor not in open_set_hash:
    77     72.8 MiB      0.0 MiB        3175                       count += 1
    78     72.8 MiB      0.0 MiB        3175                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.8 MiB      0.0 MiB        3175                       open_set_hash.add(neighbor)
    80                                                             
    81     72.8 MiB      0.0 MiB        2834           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.8 MiB      0.0 MiB        2834           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.8 MiB     72.8 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.8 MiB      0.0 MiB         129       for row in grid:
    32     72.8 MiB      0.0 MiB       16512           for spot in row:
    33     72.8 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.8 MiB      0.0 MiB           1       count = 0
    36     72.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.8 MiB      0.0 MiB           1       came_from = {}
    39     72.8 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.8 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.8 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.8 MiB      0.0 MiB         638       while not open_set.empty():
    49     72.8 MiB      0.0 MiB         638           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.8 MiB      0.0 MiB         638           current = open_set.get()[2]
    55     72.8 MiB      0.0 MiB         638           open_set_hash.remove(current)
    56                                         
    57     72.8 MiB      0.0 MiB         638           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.8 MiB      0.0 MiB         638           if current == end:
    62     72.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.8 MiB      0.0 MiB        5703           for neighbor in current.neighbors:
    67     72.8 MiB      0.0 MiB        5066               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.8 MiB      0.0 MiB        2528                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.8 MiB      0.0 MiB        2538                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.8 MiB      0.0 MiB        5066               if temp_g_score < g_score[neighbor]:
    73     72.8 MiB      0.0 MiB         878                   came_from[neighbor] = current
    74     72.8 MiB      0.0 MiB         878                   g_score[neighbor] = temp_g_score
    75     72.8 MiB      0.0 MiB         878                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.8 MiB      0.0 MiB         878                   if neighbor not in open_set_hash:
    77     72.8 MiB      0.0 MiB         878                       count += 1
    78     72.8 MiB      0.0 MiB         878                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.8 MiB      0.0 MiB         878                       open_set_hash.add(neighbor)
    80                                                             
    81     72.8 MiB      0.0 MiB         637           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.8 MiB      0.0 MiB         637           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.8 MiB     72.8 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.8 MiB      0.0 MiB         129       for row in grid:
    32     72.8 MiB      0.0 MiB       16512           for spot in row:
    33     72.8 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.8 MiB      0.0 MiB           1       count = 0
    36     72.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.8 MiB      0.0 MiB           1       came_from = {}
    39     72.8 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.8 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.8 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.8 MiB      0.0 MiB         304       while not open_set.empty():
    49     72.8 MiB      0.0 MiB         304           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.8 MiB      0.0 MiB         304           current = open_set.get()[2]
    55     72.8 MiB      0.0 MiB         304           open_set_hash.remove(current)
    56                                         
    57     72.8 MiB      0.0 MiB         304           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.8 MiB      0.0 MiB         304           if current == end:
    62     72.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.8 MiB      0.0 MiB        2727           for neighbor in current.neighbors:
    67     72.8 MiB      0.0 MiB        2424               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.8 MiB      0.0 MiB        1212                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.8 MiB      0.0 MiB        1212                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.8 MiB      0.0 MiB        2424               if temp_g_score < g_score[neighbor]:
    73     72.8 MiB      0.0 MiB         404                   came_from[neighbor] = current
    74     72.8 MiB      0.0 MiB         404                   g_score[neighbor] = temp_g_score
    75     72.8 MiB      0.0 MiB         404                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.8 MiB      0.0 MiB         404                   if neighbor not in open_set_hash:
    77     72.8 MiB      0.0 MiB         404                       count += 1
    78     72.8 MiB      0.0 MiB         404                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.8 MiB      0.0 MiB         404                       open_set_hash.add(neighbor)
    80                                                             
    81     72.8 MiB      0.0 MiB         303           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.8 MiB      0.0 MiB         303           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.8 MiB     72.8 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.8 MiB      0.0 MiB         129       for row in grid:
    32     72.8 MiB      0.0 MiB       16512           for spot in row:
    33     72.8 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.8 MiB      0.0 MiB           1       count = 0
    36     72.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.8 MiB      0.0 MiB           1       came_from = {}
    39     72.8 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.8 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.0 MiB      0.2 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.0 MiB      0.0 MiB         455       while not open_set.empty():
    49     73.0 MiB      0.0 MiB         455           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.0 MiB      0.0 MiB         455           current = open_set.get()[2]
    55     73.0 MiB      0.0 MiB         455           open_set_hash.remove(current)
    56                                         
    57     73.0 MiB      0.0 MiB         455           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.0 MiB      0.0 MiB         455           if current == end:
    62     73.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.0 MiB      0.0 MiB        4086           for neighbor in current.neighbors:
    67     73.0 MiB      0.0 MiB        3632               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.0 MiB      0.0 MiB        1816                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.0 MiB      0.0 MiB        1816                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.0 MiB      0.0 MiB        3632               if temp_g_score < g_score[neighbor]:
    73     73.0 MiB      0.0 MiB         575                   came_from[neighbor] = current
    74     73.0 MiB      0.0 MiB         575                   g_score[neighbor] = temp_g_score
    75     73.0 MiB      0.0 MiB         575                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.0 MiB      0.0 MiB         575                   if neighbor not in open_set_hash:
    77     73.0 MiB      0.0 MiB         575                       count += 1
    78     73.0 MiB      0.0 MiB         575                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.0 MiB      0.0 MiB         575                       open_set_hash.add(neighbor)
    80                                                             
    81     73.0 MiB      0.0 MiB         454           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.0 MiB      0.0 MiB         454           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.0 MiB     73.0 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.0 MiB      0.0 MiB         129       for row in grid:
    32     73.0 MiB      0.0 MiB       16512           for spot in row:
    33     73.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.0 MiB      0.0 MiB           1       count = 0
    36     73.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.0 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.1 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB          64       while not open_set.empty():
    49     73.1 MiB      0.0 MiB          64           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB          64           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB          64           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB          64           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB          64           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB         567           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB         504               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB         252                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB         252                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB         504               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         110                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         110                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         110                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         110                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         110                       count += 1
    78     73.1 MiB      0.0 MiB         110                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         110                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB          63           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB          63           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         546       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         546           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         546           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         546           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         546           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         546           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        4905           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        4360               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        2180                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        2180                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        4360               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         728                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         728                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         728                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         728                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         728                       count += 1
    78     73.1 MiB      0.0 MiB         728                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         728                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         545           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         545           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         345       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         345           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         345           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         345           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         345           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         345           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        3096           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        2752               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        1376                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        1376                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        2752               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         501                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         501                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         501                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         501                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         501                       count += 1
    78     73.1 MiB      0.0 MiB         501                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         501                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         344           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         344           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.1 MiB     71.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.1 MiB      0.0 MiB         129       for row in grid:
    32     71.1 MiB      0.0 MiB       16512           for spot in row:
    33     71.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.1 MiB      0.0 MiB           1       count = 0
    36     71.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.1 MiB      0.0 MiB           1       came_from = {}
    39     71.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.1 MiB      0.0 MiB         858       while not open_set.empty():
    49     71.1 MiB      0.0 MiB         858           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.1 MiB      0.0 MiB         858           current = open_set.get()[2]
    55     71.1 MiB      0.0 MiB         858           open_set_hash.remove(current)
    56                                         
    57     71.1 MiB      0.0 MiB         858           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.1 MiB      0.0 MiB         858           if current == end:
    62     71.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.1 MiB      0.0 MiB        7713           for neighbor in current.neighbors:
    67     71.1 MiB      0.0 MiB        6856               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.1 MiB      0.0 MiB        3428                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.1 MiB      0.0 MiB        3428                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.1 MiB      0.0 MiB        6856               if temp_g_score < g_score[neighbor]:
    73     71.1 MiB      0.0 MiB        1022                   came_from[neighbor] = current
    74     71.1 MiB      0.0 MiB        1022                   g_score[neighbor] = temp_g_score
    75     71.1 MiB      0.0 MiB        1022                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.1 MiB      0.0 MiB        1022                   if neighbor not in open_set_hash:
    77     71.1 MiB      0.0 MiB        1022                       count += 1
    78     71.1 MiB      0.0 MiB        1022                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.1 MiB      0.0 MiB        1022                       open_set_hash.add(neighbor)
    80                                                             
    81     71.1 MiB      0.0 MiB         857           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.1 MiB      0.0 MiB         857           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.1 MiB     71.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.1 MiB      0.0 MiB         129       for row in grid:
    32     71.1 MiB      0.0 MiB       16512           for spot in row:
    33     71.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.1 MiB      0.0 MiB           1       count = 0
    36     71.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.1 MiB      0.0 MiB           1       came_from = {}
    39     71.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.1 MiB      0.0 MiB         832       while not open_set.empty():
    49     71.1 MiB      0.0 MiB         832           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.1 MiB      0.0 MiB         832           current = open_set.get()[2]
    55     71.1 MiB      0.0 MiB         832           open_set_hash.remove(current)
    56                                         
    57     71.1 MiB      0.0 MiB         832           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.1 MiB      0.0 MiB         832           if current == end:
    62     71.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.1 MiB      0.0 MiB        7479           for neighbor in current.neighbors:
    67     71.1 MiB      0.0 MiB        6648               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.1 MiB      0.0 MiB        3324                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.1 MiB      0.0 MiB        3324                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.1 MiB      0.0 MiB        6648               if temp_g_score < g_score[neighbor]:
    73     71.1 MiB      0.0 MiB         998                   came_from[neighbor] = current
    74     71.1 MiB      0.0 MiB         998                   g_score[neighbor] = temp_g_score
    75     71.1 MiB      0.0 MiB         998                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.1 MiB      0.0 MiB         998                   if neighbor not in open_set_hash:
    77     71.1 MiB      0.0 MiB         998                       count += 1
    78     71.1 MiB      0.0 MiB         998                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.1 MiB      0.0 MiB         998                       open_set_hash.add(neighbor)
    80                                                             
    81     71.1 MiB      0.0 MiB         831           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.1 MiB      0.0 MiB         831           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.1 MiB     71.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.1 MiB      0.0 MiB         129       for row in grid:
    32     71.1 MiB      0.0 MiB       16512           for spot in row:
    33     71.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.1 MiB      0.0 MiB           1       count = 0
    36     71.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.1 MiB      0.0 MiB           1       came_from = {}
    39     71.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.1 MiB      0.0 MiB        1216       while not open_set.empty():
    49     71.1 MiB      0.0 MiB        1216           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.1 MiB      0.0 MiB        1216           current = open_set.get()[2]
    55     71.1 MiB      0.0 MiB        1216           open_set_hash.remove(current)
    56                                         
    57     71.1 MiB      0.0 MiB        1216           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.1 MiB      0.0 MiB        1216           if current == end:
    62     71.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.1 MiB      0.0 MiB       10935           for neighbor in current.neighbors:
    67     71.1 MiB      0.0 MiB        9720               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.1 MiB      0.0 MiB        4860                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.1 MiB      0.0 MiB        4860                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.1 MiB      0.0 MiB        9720               if temp_g_score < g_score[neighbor]:
    73     71.1 MiB      0.0 MiB        1418                   came_from[neighbor] = current
    74     71.1 MiB      0.0 MiB        1418                   g_score[neighbor] = temp_g_score
    75     71.1 MiB      0.0 MiB        1418                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.1 MiB      0.0 MiB        1418                   if neighbor not in open_set_hash:
    77     71.1 MiB      0.0 MiB        1418                       count += 1
    78     71.1 MiB      0.0 MiB        1418                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.1 MiB      0.0 MiB        1418                       open_set_hash.add(neighbor)
    80                                                             
    81     71.1 MiB      0.0 MiB        1215           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.1 MiB      0.0 MiB        1215           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.8 MiB     72.8 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.8 MiB      0.0 MiB         129       for row in grid:
    32     72.8 MiB      0.0 MiB       16512           for spot in row:
    33     72.8 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.8 MiB      0.0 MiB           1       count = 0
    36     72.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.8 MiB      0.0 MiB           1       came_from = {}
    39     72.8 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.8 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.3 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         377       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         377           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         377           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         377           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         377           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         377           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        3384           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        3008               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        1504                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        1504                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        3008               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         517                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         517                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         517                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         517                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         517                       count += 1
    78     73.1 MiB      0.0 MiB         517                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         517                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         376           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         376           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB        1148       while not open_set.empty():
    49     73.1 MiB      0.0 MiB        1148           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB        1148           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB        1148           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB        1148           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB        1148           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB       10323           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        9176               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        4588                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        4588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        9176               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB        1502                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB        1502                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB        1502                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB        1502                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB        1502                       count += 1
    78     73.1 MiB      0.0 MiB        1502                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB        1502                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB        1147           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB        1147           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB          72       while not open_set.empty():
    49     73.1 MiB      0.0 MiB          72           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB          72           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB          72           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB          72           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB          72           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB         639           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB         568               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB         284                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB         284                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB         568               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         150                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         150                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         150                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         150                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         150                       count += 1
    78     73.1 MiB      0.0 MiB         150                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         150                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB          71           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB          71           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         405       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         405           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         405           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         405           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         405           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         405           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        3636           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        3232               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        1616                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        1616                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        3232               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         529                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         529                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         529                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         529                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         529                       count += 1
    78     73.1 MiB      0.0 MiB         529                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         529                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         404           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         404           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB        1392       while not open_set.empty():
    49     73.1 MiB      0.0 MiB        1392           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB        1392           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB        1392           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB        1392           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB        1392           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB       12519           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB       11128               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        5564                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        5564                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB       11128               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB        1602                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB        1602                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB        1602                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB        1602                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB        1602                       count += 1
    78     73.1 MiB      0.0 MiB        1602                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB        1602                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB        1391           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB        1391           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         602       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         602           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         602           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         602           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         602           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         602           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        5409           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        4808               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        2404                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        2404                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        4808               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         800                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         800                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         800                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         800                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         800                       count += 1
    78     73.1 MiB      0.0 MiB         800                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         800                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         601           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         601           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         704       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         704           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         704           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         704           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         704           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         704           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        6327           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        5624               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        2812                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        2812                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        5624               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         854                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         854                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         854                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         854                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         854                       count += 1
    78     73.1 MiB      0.0 MiB         854                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         854                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         703           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         703           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB        2581       while not open_set.empty():
    49     73.1 MiB      0.0 MiB        2581           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB        2581           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB        2581           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB        2581           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB        2581           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB       23220           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB       20640               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB       10320                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB       10320                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB       20640               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB        2993                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB        2993                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB        2993                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB        2993                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB        2993                       count += 1
    78     73.1 MiB      0.0 MiB        2993                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB        2993                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB        2580           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB        2580           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         352       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         352           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         352           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         352           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         352           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         352           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        3159           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        2808               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        1404                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        1404                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        2808               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         500                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         500                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         500                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         500                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         500                       count += 1
    78     73.1 MiB      0.0 MiB         500                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         500                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         351           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         351           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         136       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         136           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         136           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         136           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         136           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         136           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        1215           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        1080               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB         540                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB         540                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        1080               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         200                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         200                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         200                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         200                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         200                       count += 1
    78     73.1 MiB      0.0 MiB         200                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         200                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         135           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         135           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         164       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         164           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         164           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         164           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         164           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         164           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        1467           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        1304               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB         652                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB         652                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        1304               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         260                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         260                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         260                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         260                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         260                       count += 1
    78     73.1 MiB      0.0 MiB         260                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         260                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         163           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         163           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         390       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         390           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         390           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         390           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         390           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         390           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        3501           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        3112               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        1556                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        1556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        3112               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         500                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         500                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         500                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         500                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         500                       count += 1
    78     73.1 MiB      0.0 MiB         500                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         500                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         389           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         389           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.1 MiB     72.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.1 MiB      0.0 MiB         129       for row in grid:
    32     72.1 MiB      0.0 MiB       16512           for spot in row:
    33     72.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.1 MiB      0.0 MiB           1       count = 0
    36     72.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.1 MiB      0.0 MiB           1       came_from = {}
    39     72.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.1 MiB      0.0 MiB        2024       while not open_set.empty():
    49     72.1 MiB      0.0 MiB        2024           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.1 MiB      0.0 MiB        2024           current = open_set.get()[2]
    55     72.1 MiB      0.0 MiB        2024           open_set_hash.remove(current)
    56                                         
    57     72.1 MiB      0.0 MiB        2024           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.1 MiB      0.0 MiB        2024           if current == end:
    62     72.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.1 MiB      0.0 MiB       18207           for neighbor in current.neighbors:
    67     72.1 MiB      0.0 MiB       16184               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.1 MiB      0.0 MiB        8092                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.1 MiB      0.0 MiB        8092                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.1 MiB      0.0 MiB       16184               if temp_g_score < g_score[neighbor]:
    73     72.1 MiB      0.0 MiB        2420                   came_from[neighbor] = current
    74     72.1 MiB      0.0 MiB        2420                   g_score[neighbor] = temp_g_score
    75     72.1 MiB      0.0 MiB        2420                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.1 MiB      0.0 MiB        2420                   if neighbor not in open_set_hash:
    77     72.1 MiB      0.0 MiB        2420                       count += 1
    78     72.1 MiB      0.0 MiB        2420                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.1 MiB      0.0 MiB        2420                       open_set_hash.add(neighbor)
    80                                                             
    81     72.1 MiB      0.0 MiB        2023           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.1 MiB      0.0 MiB        2023           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.1 MiB     72.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.1 MiB      0.0 MiB         129       for row in grid:
    32     72.1 MiB      0.0 MiB       16512           for spot in row:
    33     72.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.1 MiB      0.0 MiB           1       count = 0
    36     72.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.1 MiB      0.0 MiB           1       came_from = {}
    39     72.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     72.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     72.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     72.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     72.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     72.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     72.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     72.1 MiB      0.0 MiB        2948       while not open_set.empty():
    49     72.1 MiB      0.0 MiB        2948           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     72.1 MiB      0.0 MiB        2948           current = open_set.get()[2]
    55     72.1 MiB      0.0 MiB        2948           open_set_hash.remove(current)
    56                                         
    57     72.1 MiB      0.0 MiB        2948           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     72.1 MiB      0.0 MiB        2948           if current == end:
    62     72.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     72.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     72.1 MiB      0.0 MiB       26523           for neighbor in current.neighbors:
    67     72.1 MiB      0.0 MiB       23576               if current.row != neighbor.row and current.col != neighbor.col:
    68     72.1 MiB      0.0 MiB       11788                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     72.1 MiB      0.0 MiB       11788                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     72.1 MiB      0.0 MiB       23576               if temp_g_score < g_score[neighbor]:
    73     72.1 MiB      0.0 MiB        3302                   came_from[neighbor] = current
    74     72.1 MiB      0.0 MiB        3302                   g_score[neighbor] = temp_g_score
    75     72.1 MiB      0.0 MiB        3302                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     72.1 MiB      0.0 MiB        3302                   if neighbor not in open_set_hash:
    77     72.1 MiB      0.0 MiB        3302                       count += 1
    78     72.1 MiB      0.0 MiB        3302                       open_set.put((f_score[neighbor], count, neighbor))
    79     72.1 MiB      0.0 MiB        3302                       open_set_hash.add(neighbor)
    80                                                             
    81     72.1 MiB      0.0 MiB        2947           if draw is not None:
    82                                                     draw()
    83                                         
    84     72.1 MiB      0.0 MiB        2947           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.1 MiB     70.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.1 MiB      0.0 MiB         129       for row in grid:
    32     70.1 MiB      0.0 MiB       16512           for spot in row:
    33     70.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.1 MiB      0.0 MiB           1       count = 0
    36     70.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.1 MiB      0.0 MiB           1       came_from = {}
    39     70.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.1 MiB      0.0 MiB        1456       while not open_set.empty():
    49     70.1 MiB      0.0 MiB        1456           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.1 MiB      0.0 MiB        1456           current = open_set.get()[2]
    55     70.1 MiB      0.0 MiB        1456           open_set_hash.remove(current)
    56                                         
    57     70.1 MiB      0.0 MiB        1456           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.1 MiB      0.0 MiB        1456           if current == end:
    62     70.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.1 MiB      0.0 MiB       13095           for neighbor in current.neighbors:
    67     70.1 MiB      0.0 MiB       11640               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.1 MiB      0.0 MiB        5820                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.1 MiB      0.0 MiB        5820                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.1 MiB      0.0 MiB       11640               if temp_g_score < g_score[neighbor]:
    73     70.1 MiB      0.0 MiB        1850                   came_from[neighbor] = current
    74     70.1 MiB      0.0 MiB        1850                   g_score[neighbor] = temp_g_score
    75     70.1 MiB      0.0 MiB        1850                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.1 MiB      0.0 MiB        1850                   if neighbor not in open_set_hash:
    77     70.1 MiB      0.0 MiB        1850                       count += 1
    78     70.1 MiB      0.0 MiB        1850                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.1 MiB      0.0 MiB        1850                       open_set_hash.add(neighbor)
    80                                                             
    81     70.1 MiB      0.0 MiB        1455           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.1 MiB      0.0 MiB        1455           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.1 MiB     70.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.1 MiB      0.0 MiB         129       for row in grid:
    32     70.1 MiB      0.0 MiB       16512           for spot in row:
    33     70.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.1 MiB      0.0 MiB           1       count = 0
    36     70.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.1 MiB      0.0 MiB           1       came_from = {}
    39     70.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.1 MiB      0.0 MiB          99       while not open_set.empty():
    49     70.1 MiB      0.0 MiB          99           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.1 MiB      0.0 MiB          99           current = open_set.get()[2]
    55     70.1 MiB      0.0 MiB          99           open_set_hash.remove(current)
    56                                         
    57     70.1 MiB      0.0 MiB          99           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.1 MiB      0.0 MiB          99           if current == end:
    62     70.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.1 MiB      0.0 MiB         882           for neighbor in current.neighbors:
    67     70.1 MiB      0.0 MiB         784               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.1 MiB      0.0 MiB         392                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.1 MiB      0.0 MiB         392                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.1 MiB      0.0 MiB         784               if temp_g_score < g_score[neighbor]:
    73     70.1 MiB      0.0 MiB         155                   came_from[neighbor] = current
    74     70.1 MiB      0.0 MiB         155                   g_score[neighbor] = temp_g_score
    75     70.1 MiB      0.0 MiB         155                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.1 MiB      0.0 MiB         155                   if neighbor not in open_set_hash:
    77     70.1 MiB      0.0 MiB         155                       count += 1
    78     70.1 MiB      0.0 MiB         155                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.1 MiB      0.0 MiB         155                       open_set_hash.add(neighbor)
    80                                                             
    81     70.1 MiB      0.0 MiB          98           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.1 MiB      0.0 MiB          98           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     70.1 MiB     70.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     70.1 MiB      0.0 MiB         129       for row in grid:
    32     70.1 MiB      0.0 MiB       16512           for spot in row:
    33     70.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     70.1 MiB      0.0 MiB           1       count = 0
    36     70.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     70.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     70.1 MiB      0.0 MiB           1       came_from = {}
    39     70.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     70.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     70.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     70.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     70.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     70.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     70.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     70.1 MiB      0.0 MiB         200       while not open_set.empty():
    49     70.1 MiB      0.0 MiB         200           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     70.1 MiB      0.0 MiB         200           current = open_set.get()[2]
    55     70.1 MiB      0.0 MiB         200           open_set_hash.remove(current)
    56                                         
    57     70.1 MiB      0.0 MiB         200           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     70.1 MiB      0.0 MiB         200           if current == end:
    62     70.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     70.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     70.1 MiB      0.0 MiB        1791           for neighbor in current.neighbors:
    67     70.1 MiB      0.0 MiB        1592               if current.row != neighbor.row and current.col != neighbor.col:
    68     70.1 MiB      0.0 MiB         796                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     70.1 MiB      0.0 MiB         796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     70.1 MiB      0.0 MiB        1592               if temp_g_score < g_score[neighbor]:
    73     70.1 MiB      0.0 MiB         298                   came_from[neighbor] = current
    74     70.1 MiB      0.0 MiB         298                   g_score[neighbor] = temp_g_score
    75     70.1 MiB      0.0 MiB         298                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     70.1 MiB      0.0 MiB         298                   if neighbor not in open_set_hash:
    77     70.1 MiB      0.0 MiB         298                       count += 1
    78     70.1 MiB      0.0 MiB         298                       open_set.put((f_score[neighbor], count, neighbor))
    79     70.1 MiB      0.0 MiB         298                       open_set_hash.add(neighbor)
    80                                                             
    81     70.1 MiB      0.0 MiB         199           if draw is not None:
    82                                                     draw()
    83                                         
    84     70.1 MiB      0.0 MiB         199           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     72.9 MiB     72.9 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     72.9 MiB      0.0 MiB         129       for row in grid:
    32     72.9 MiB      0.0 MiB       16512           for spot in row:
    33     72.9 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     72.9 MiB      0.0 MiB           1       count = 0
    36     72.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     72.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     72.9 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.2 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         572       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         572           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         572           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         572           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         572           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         572           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        5136           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        4565               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        2282                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        2283                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        4565               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         769                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         769                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         769                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         769                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         769                       count += 1
    78     73.1 MiB      0.0 MiB         769                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         769                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         571           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         571           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         435       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         435           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         435           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         435           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         435           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         435           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        3906           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        3472               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        1736                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        1736                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        3472               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         579                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         579                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         579                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         579                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         579                       count += 1
    78     73.1 MiB      0.0 MiB         579                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         579                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         434           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         434           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         240       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         240           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         240           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         240           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         240           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         240           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        2151           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        1912               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB         956                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB         956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        1912               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         374                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         374                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         374                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         374                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         374                       count += 1
    78     73.1 MiB      0.0 MiB         374                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         374                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         239           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         239           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         224       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         224           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         224           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         224           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         224           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         224           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        2007           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        1784               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB         892                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB         892                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        1784               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         350                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         350                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         350                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         350                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         350                       count += 1
    78     73.1 MiB      0.0 MiB         350                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         350                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         223           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         223           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB          13       while not open_set.empty():
    49     73.1 MiB      0.0 MiB          13           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB          13           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB          13           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB          13           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB          13           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB         108           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB          96               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB          48                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB          48                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB          96               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB          41                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB          41                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB          41                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB          41                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB          41                       count += 1
    78     73.1 MiB      0.0 MiB          41                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB          41                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB          12           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB          12           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         525       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         525           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         525           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         525           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         525           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         525           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        4716           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        4192               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        2096                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        2096                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        4192               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         693                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         693                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         693                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         693                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         693                       count += 1
    78     73.1 MiB      0.0 MiB         693                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         693                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         524           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         524           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         702       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         702           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         702           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         702           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         702           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         702           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        6309           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        5608               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        2804                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        2804                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        5608               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         860                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         860                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         860                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         860                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         860                       count += 1
    78     73.1 MiB      0.0 MiB         860                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         860                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         701           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         701           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         180       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         180           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         180           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         180           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         180           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         180           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        1611           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        1432               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB         716                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB         716                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        1432               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         284                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         284                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         284                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         284                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         284                       count += 1
    78     73.1 MiB      0.0 MiB         284                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         284                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         179           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         179           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB        1920       while not open_set.empty():
    49     73.1 MiB      0.0 MiB        1920           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB        1920           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB        1920           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB        1920           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB        1920           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB       17271           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB       15352               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        7676                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        7676                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB       15352               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB        2222                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB        2222                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB        2222                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB        2222                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB        2222                       count += 1
    78     73.1 MiB      0.0 MiB        2222                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB        2222                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB        1919           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB        1919           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB        2679       while not open_set.empty():
    49     73.1 MiB      0.0 MiB        2679           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB        2679           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB        2679           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB        2679           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB        2679           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB       24099           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB       21421               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB       10710                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB       10711                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB       21421               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB        2976                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB        2976                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB        2976                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB        2976                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB        2976                       count += 1
    78     73.1 MiB      0.0 MiB        2976                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB        2976                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB        2678           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB        2678           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB          87       while not open_set.empty():
    49     73.1 MiB      0.0 MiB          87           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB          87           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB          87           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB          87           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB          87           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB         774           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB         688               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB         344                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB         344                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB         688               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         263                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         263                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         263                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         263                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         263                       count += 1
    78     73.1 MiB      0.0 MiB         263                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         263                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB          86           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB          86           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB        2652       while not open_set.empty():
    49     73.1 MiB      0.0 MiB        2652           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB        2652           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB        2652           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB        2652           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB        2652           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB       23859           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB       21208               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB       10604                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB       10604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB       21208               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB        2960                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB        2960                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB        2960                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB        2960                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB        2960                       count += 1
    78     73.1 MiB      0.0 MiB        2960                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB        2960                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB        2651           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB        2651           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB        2046       while not open_set.empty():
    49     73.1 MiB      0.0 MiB        2046           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB        2046           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB        2046           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB        2046           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB        2046           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB       18405           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB       16360               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        8180                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        8180                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB       16360               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB        2300                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB        2300                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB        2300                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB        2300                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB        2300                       count += 1
    78     73.1 MiB      0.0 MiB        2300                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB        2300                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB        2045           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB        2045           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         150       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         150           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         150           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         150           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         150           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         150           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        1341           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        1192               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB         596                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB         596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        1192               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         222                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         222                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         222                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         222                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         222                       count += 1
    78     73.1 MiB      0.0 MiB         222                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         222                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         149           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         149           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.1 MiB     71.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.1 MiB      0.0 MiB         129       for row in grid:
    32     71.1 MiB      0.0 MiB       16512           for spot in row:
    33     71.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.1 MiB      0.0 MiB           1       count = 0
    36     71.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.1 MiB      0.0 MiB           1       came_from = {}
    39     71.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.1 MiB      0.0 MiB         146       while not open_set.empty():
    49     71.1 MiB      0.0 MiB         146           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.1 MiB      0.0 MiB         146           current = open_set.get()[2]
    55     71.1 MiB      0.0 MiB         146           open_set_hash.remove(current)
    56                                         
    57     71.1 MiB      0.0 MiB         146           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.1 MiB      0.0 MiB         146           if current == end:
    62     71.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.1 MiB      0.0 MiB        1305           for neighbor in current.neighbors:
    67     71.1 MiB      0.0 MiB        1160               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.1 MiB      0.0 MiB         580                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.1 MiB      0.0 MiB         580                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.1 MiB      0.0 MiB        1160               if temp_g_score < g_score[neighbor]:
    73     71.1 MiB      0.0 MiB         440                   came_from[neighbor] = current
    74     71.1 MiB      0.0 MiB         440                   g_score[neighbor] = temp_g_score
    75     71.1 MiB      0.0 MiB         440                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.1 MiB      0.0 MiB         440                   if neighbor not in open_set_hash:
    77     71.1 MiB      0.0 MiB         440                       count += 1
    78     71.1 MiB      0.0 MiB         440                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.1 MiB      0.0 MiB         440                       open_set_hash.add(neighbor)
    80                                                             
    81     71.1 MiB      0.0 MiB         145           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.1 MiB      0.0 MiB         145           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.1 MiB     71.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.1 MiB      0.0 MiB         129       for row in grid:
    32     71.1 MiB      0.0 MiB       16512           for spot in row:
    33     71.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.1 MiB      0.0 MiB           1       count = 0
    36     71.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.1 MiB      0.0 MiB           1       came_from = {}
    39     71.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.1 MiB      0.0 MiB          27       while not open_set.empty():
    49     71.1 MiB      0.0 MiB          27           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.1 MiB      0.0 MiB          27           current = open_set.get()[2]
    55     71.1 MiB      0.0 MiB          27           open_set_hash.remove(current)
    56                                         
    57     71.1 MiB      0.0 MiB          27           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.1 MiB      0.0 MiB          27           if current == end:
    62     71.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.1 MiB      0.0 MiB         234           for neighbor in current.neighbors:
    67     71.1 MiB      0.0 MiB         208               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.1 MiB      0.0 MiB         104                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.1 MiB      0.0 MiB         104                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.1 MiB      0.0 MiB         208               if temp_g_score < g_score[neighbor]:
    73     71.1 MiB      0.0 MiB          55                   came_from[neighbor] = current
    74     71.1 MiB      0.0 MiB          55                   g_score[neighbor] = temp_g_score
    75     71.1 MiB      0.0 MiB          55                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.1 MiB      0.0 MiB          55                   if neighbor not in open_set_hash:
    77     71.1 MiB      0.0 MiB          55                       count += 1
    78     71.1 MiB      0.0 MiB          55                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.1 MiB      0.0 MiB          55                       open_set_hash.add(neighbor)
    80                                                             
    81     71.1 MiB      0.0 MiB          26           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.1 MiB      0.0 MiB          26           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     71.1 MiB     71.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.1 MiB      0.0 MiB         129       for row in grid:
    32     71.1 MiB      0.0 MiB       16512           for spot in row:
    33     71.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     71.1 MiB      0.0 MiB           1       count = 0
    36     71.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.1 MiB      0.0 MiB           1       came_from = {}
    39     71.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     71.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     71.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     71.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     71.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     71.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     71.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     71.1 MiB      0.0 MiB         425       while not open_set.empty():
    49     71.1 MiB      0.0 MiB         425           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     71.1 MiB      0.0 MiB         425           current = open_set.get()[2]
    55     71.1 MiB      0.0 MiB         425           open_set_hash.remove(current)
    56                                         
    57     71.1 MiB      0.0 MiB         425           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     71.1 MiB      0.0 MiB         425           if current == end:
    62     71.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     71.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     71.1 MiB      0.0 MiB        3816           for neighbor in current.neighbors:
    67     71.1 MiB      0.0 MiB        3392               if current.row != neighbor.row and current.col != neighbor.col:
    68     71.1 MiB      0.0 MiB        1696                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     71.1 MiB      0.0 MiB        1696                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     71.1 MiB      0.0 MiB        3392               if temp_g_score < g_score[neighbor]:
    73     71.1 MiB      0.0 MiB         557                   came_from[neighbor] = current
    74     71.1 MiB      0.0 MiB         557                   g_score[neighbor] = temp_g_score
    75     71.1 MiB      0.0 MiB         557                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     71.1 MiB      0.0 MiB         557                   if neighbor not in open_set_hash:
    77     71.1 MiB      0.0 MiB         557                       count += 1
    78     71.1 MiB      0.0 MiB         557                       open_set.put((f_score[neighbor], count, neighbor))
    79     71.1 MiB      0.0 MiB         557                       open_set_hash.add(neighbor)
    80                                                             
    81     71.1 MiB      0.0 MiB         424           if draw is not None:
    82                                                     draw()
    83                                         
    84     71.1 MiB      0.0 MiB         424           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.0 MiB     73.0 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.0 MiB      0.0 MiB         129       for row in grid:
    32     73.0 MiB      0.0 MiB       16512           for spot in row:
    33     73.0 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.0 MiB      0.0 MiB           1       count = 0
    36     73.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.0 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.1 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.1 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         680       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         680           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         680           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         680           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         680           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         680           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        6111           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        5432               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        2716                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        2716                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        5432               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         854                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         854                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         854                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         854                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         854                       count += 1
    78     73.1 MiB      0.0 MiB         854                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         854                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         679           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         679           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         301       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         301           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         301           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         301           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         301           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         301           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        2700           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        2400               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        1200                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        1200                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        2400               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         413                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         413                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         413                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         413                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         413                       count += 1
    78     73.1 MiB      0.0 MiB         413                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         413                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         300           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         300           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         852       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         852           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         852           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         852           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         852           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         852           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        7659           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        6808               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB        3404                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB        3404                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        6808               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB        1158                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB        1158                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB        1158                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB        1158                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB        1158                       count += 1
    78     73.1 MiB      0.0 MiB        1158                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB        1158                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         851           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         851           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB          39       while not open_set.empty():
    49     73.1 MiB      0.0 MiB          39           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB          39           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB          39           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB          39           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB          39           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB         342           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB         304               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB         152                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB         152                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB         304               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB          95                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB          95                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB          95                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB          95                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB          95                       count += 1
    78     73.1 MiB      0.0 MiB          95                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB          95                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB          38           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB          38           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     73.1 MiB     73.1 MiB           1   @profile(stream=open('logs/A*/grid_size/128.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     73.1 MiB      0.0 MiB         129       for row in grid:
    32     73.1 MiB      0.0 MiB       16512           for spot in row:
    33     73.1 MiB      0.0 MiB       16384               spot.update_neighbors(grid)
    34                                             
    35     73.1 MiB      0.0 MiB           1       count = 0
    36     73.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     73.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     73.1 MiB      0.0 MiB           1       came_from = {}
    39     73.1 MiB      0.0 MiB       16515       g_score = {spot: float("inf") for row in grid for spot in row}
    40     73.1 MiB      0.0 MiB           1       g_score[start] = 0
    41     73.1 MiB      0.0 MiB       16515       f_score = {spot: float("inf") for row in grid for spot in row}
    42     73.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     73.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     73.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46     73.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     73.1 MiB      0.0 MiB         180       while not open_set.empty():
    49     73.1 MiB      0.0 MiB         180           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     73.1 MiB      0.0 MiB         180           current = open_set.get()[2]
    55     73.1 MiB      0.0 MiB         180           open_set_hash.remove(current)
    56                                         
    57     73.1 MiB      0.0 MiB         180           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     73.1 MiB      0.0 MiB         180           if current == end:
    62     73.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     73.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     73.1 MiB      0.0 MiB        1611           for neighbor in current.neighbors:
    67     73.1 MiB      0.0 MiB        1432               if current.row != neighbor.row and current.col != neighbor.col:
    68     73.1 MiB      0.0 MiB         716                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     73.1 MiB      0.0 MiB         716                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     73.1 MiB      0.0 MiB        1432               if temp_g_score < g_score[neighbor]:
    73     73.1 MiB      0.0 MiB         256                   came_from[neighbor] = current
    74     73.1 MiB      0.0 MiB         256                   g_score[neighbor] = temp_g_score
    75     73.1 MiB      0.0 MiB         256                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     73.1 MiB      0.0 MiB         256                   if neighbor not in open_set_hash:
    77     73.1 MiB      0.0 MiB         256                       count += 1
    78     73.1 MiB      0.0 MiB         256                       open_set.put((f_score[neighbor], count, neighbor))
    79     73.1 MiB      0.0 MiB         256                       open_set_hash.add(neighbor)
    80                                                             
    81     73.1 MiB      0.0 MiB         179           if draw is not None:
    82                                                     draw()
    83                                         
    84     73.1 MiB      0.0 MiB         179           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


