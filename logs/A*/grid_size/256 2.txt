Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     67.2 MiB     67.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     71.1 MiB      0.0 MiB         257       for row in grid:
    32     71.1 MiB      0.0 MiB       65792           for spot in row:
    33     71.1 MiB      3.9 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35     71.1 MiB      0.0 MiB           1       count = 0
    36     71.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     71.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     71.1 MiB      0.0 MiB           1       came_from = {}
    39     77.9 MiB      6.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40     77.9 MiB      0.0 MiB           1       g_score[start] = 0
    41     83.7 MiB      5.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42     83.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     83.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     83.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46     83.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     83.9 MiB      0.0 MiB        2940       while not open_set.empty():
    49     83.9 MiB      0.0 MiB        2940           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     83.9 MiB      0.0 MiB        2940           current = open_set.get()[2]
    55     83.9 MiB      0.0 MiB        2940           open_set_hash.remove(current)
    56                                         
    57     83.9 MiB      0.0 MiB        2940           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     83.9 MiB      0.0 MiB        2940           if current == end:
    62     83.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     83.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     83.9 MiB      0.0 MiB       26451           for neighbor in current.neighbors:
    67     83.9 MiB      0.0 MiB       23512               if current.row != neighbor.row and current.col != neighbor.col:
    68     83.9 MiB      0.0 MiB       11756                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     83.9 MiB      0.0 MiB       11756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     83.9 MiB      0.0 MiB       23512               if temp_g_score < g_score[neighbor]:
    73     83.9 MiB      0.1 MiB        3276                   came_from[neighbor] = current
    74     83.9 MiB      0.0 MiB        3276                   g_score[neighbor] = temp_g_score
    75     83.9 MiB      0.0 MiB        3276                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     83.9 MiB      0.0 MiB        3276                   if neighbor not in open_set_hash:
    77     83.9 MiB      0.0 MiB        3276                       count += 1
    78     83.9 MiB      0.0 MiB        3276                       open_set.put((f_score[neighbor], count, neighbor))
    79     83.9 MiB      0.0 MiB        3276                       open_set_hash.add(neighbor)
    80                                                             
    81     83.9 MiB      0.0 MiB        2939           if draw is not None:
    82                                                     draw()
    83                                         
    84     83.9 MiB      0.0 MiB        2939           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    100.5 MiB    100.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    104.5 MiB      0.0 MiB         257       for row in grid:
    32    104.5 MiB      0.0 MiB       65792           for spot in row:
    33    104.5 MiB      4.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    104.5 MiB      0.0 MiB           1       count = 0
    36    104.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    104.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    104.5 MiB      0.0 MiB           1       came_from = {}
    39    106.5 MiB      2.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    106.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    112.9 MiB      6.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    112.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    112.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    112.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    112.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    113.0 MiB      0.0 MiB        8715       while not open_set.empty():
    49    113.0 MiB      0.0 MiB        8715           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    113.0 MiB      0.0 MiB        8715           current = open_set.get()[2]
    55    113.0 MiB      0.0 MiB        8715           open_set_hash.remove(current)
    56                                         
    57    113.0 MiB      0.0 MiB        8715           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    113.0 MiB      0.0 MiB        8715           if current == end:
    62    113.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    113.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    113.0 MiB      0.0 MiB       78426           for neighbor in current.neighbors:
    67    113.0 MiB      0.0 MiB       69712               if current.row != neighbor.row and current.col != neighbor.col:
    68    113.0 MiB      0.0 MiB       34856                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    113.0 MiB      0.0 MiB       34856                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    113.0 MiB      0.0 MiB       69712               if temp_g_score < g_score[neighbor]:
    73    113.0 MiB      0.0 MiB        9299                   came_from[neighbor] = current
    74    113.0 MiB      0.0 MiB        9299                   g_score[neighbor] = temp_g_score
    75    113.0 MiB      0.0 MiB        9299                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    113.0 MiB      0.0 MiB        9299                   if neighbor not in open_set_hash:
    77    113.0 MiB      0.0 MiB        9299                       count += 1
    78    113.0 MiB      0.0 MiB        9299                       open_set.put((f_score[neighbor], count, neighbor))
    79    113.0 MiB      0.0 MiB        9299                       open_set_hash.add(neighbor)
    80                                                             
    81    113.0 MiB      0.0 MiB        8714           if draw is not None:
    82                                                     draw()
    83                                         
    84    113.0 MiB      0.0 MiB        8714           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    109.1 MiB    109.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    110.0 MiB      0.0 MiB         257       for row in grid:
    32    110.0 MiB      0.0 MiB       65792           for spot in row:
    33    110.0 MiB      0.9 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    110.0 MiB      0.0 MiB           1       count = 0
    36    110.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    110.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    110.0 MiB      0.0 MiB           1       came_from = {}
    39    114.6 MiB      4.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    114.6 MiB      0.0 MiB           1       g_score[start] = 0
    41    119.1 MiB      4.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    119.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    119.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    119.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    119.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    119.1 MiB      0.0 MiB        3286       while not open_set.empty():
    49    119.1 MiB      0.0 MiB        3286           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    119.1 MiB      0.0 MiB        3286           current = open_set.get()[2]
    55    119.1 MiB      0.0 MiB        3286           open_set_hash.remove(current)
    56                                         
    57    119.1 MiB      0.0 MiB        3286           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    119.1 MiB      0.0 MiB        3286           if current == end:
    62    119.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    119.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    119.1 MiB      0.0 MiB       29565           for neighbor in current.neighbors:
    67    119.1 MiB      0.0 MiB       26280               if current.row != neighbor.row and current.col != neighbor.col:
    68    119.1 MiB      0.0 MiB       13140                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    119.1 MiB      0.0 MiB       13140                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    119.1 MiB      0.0 MiB       26280               if temp_g_score < g_score[neighbor]:
    73    119.1 MiB      0.0 MiB        3620                   came_from[neighbor] = current
    74    119.1 MiB      0.0 MiB        3620                   g_score[neighbor] = temp_g_score
    75    119.1 MiB      0.0 MiB        3620                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    119.1 MiB      0.0 MiB        3620                   if neighbor not in open_set_hash:
    77    119.1 MiB      0.0 MiB        3620                       count += 1
    78    119.1 MiB      0.0 MiB        3620                       open_set.put((f_score[neighbor], count, neighbor))
    79    119.1 MiB      0.0 MiB        3620                       open_set_hash.add(neighbor)
    80                                                             
    81    119.1 MiB      0.0 MiB        3285           if draw is not None:
    82                                                     draw()
    83                                         
    84    119.1 MiB      0.0 MiB        3285           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    122.0 MiB    122.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    122.0 MiB      0.0 MiB         257       for row in grid:
    32    122.0 MiB      0.0 MiB       65792           for spot in row:
    33    122.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    122.0 MiB      0.0 MiB           1       count = 0
    36    122.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    122.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    122.0 MiB      0.0 MiB           1       came_from = {}
    39    124.6 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    124.6 MiB      0.0 MiB           1       g_score[start] = 0
    41    127.1 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    127.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    127.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    127.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    127.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    127.1 MiB      0.0 MiB        1690       while not open_set.empty():
    49    127.1 MiB      0.0 MiB        1690           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    127.1 MiB      0.0 MiB        1690           current = open_set.get()[2]
    55    127.1 MiB      0.0 MiB        1690           open_set_hash.remove(current)
    56                                         
    57    127.1 MiB      0.0 MiB        1690           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    127.1 MiB      0.0 MiB        1690           if current == end:
    62    127.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    127.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    127.1 MiB      0.0 MiB       15201           for neighbor in current.neighbors:
    67    127.1 MiB      0.0 MiB       13512               if current.row != neighbor.row and current.col != neighbor.col:
    68    127.1 MiB      0.0 MiB        6756                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    127.1 MiB      0.0 MiB        6756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    127.1 MiB      0.0 MiB       13512               if temp_g_score < g_score[neighbor]:
    73    127.1 MiB      0.0 MiB        1922                   came_from[neighbor] = current
    74    127.1 MiB      0.0 MiB        1922                   g_score[neighbor] = temp_g_score
    75    127.1 MiB      0.0 MiB        1922                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    127.1 MiB      0.0 MiB        1922                   if neighbor not in open_set_hash:
    77    127.1 MiB      0.0 MiB        1922                       count += 1
    78    127.1 MiB      0.0 MiB        1922                       open_set.put((f_score[neighbor], count, neighbor))
    79    127.1 MiB      0.0 MiB        1922                       open_set_hash.add(neighbor)
    80                                                             
    81    127.1 MiB      0.0 MiB        1689           if draw is not None:
    82                                                     draw()
    83                                         
    84    127.1 MiB      0.0 MiB        1689           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    128.1 MiB    128.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    128.1 MiB      0.0 MiB         257       for row in grid:
    32    128.1 MiB      0.0 MiB       65792           for spot in row:
    33    128.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    128.1 MiB      0.0 MiB           1       count = 0
    36    128.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    128.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    128.1 MiB      0.0 MiB           1       came_from = {}
    39    128.1 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    128.1 MiB      0.0 MiB           1       g_score[start] = 0
    41    128.1 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    128.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    128.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    128.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    128.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    128.1 MiB      0.0 MiB        4700       while not open_set.empty():
    49    128.1 MiB      0.0 MiB        4700           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    128.1 MiB      0.0 MiB        4700           current = open_set.get()[2]
    55    128.1 MiB      0.0 MiB        4700           open_set_hash.remove(current)
    56                                         
    57    128.1 MiB      0.0 MiB        4700           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    128.1 MiB      0.0 MiB        4700           if current == end:
    62    128.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    128.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    128.1 MiB      0.0 MiB       42291           for neighbor in current.neighbors:
    67    128.1 MiB      0.0 MiB       37592               if current.row != neighbor.row and current.col != neighbor.col:
    68    128.1 MiB      0.0 MiB       18796                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    128.1 MiB      0.0 MiB       18796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    128.1 MiB      0.0 MiB       37592               if temp_g_score < g_score[neighbor]:
    73    128.1 MiB      0.0 MiB        5174                   came_from[neighbor] = current
    74    128.1 MiB      0.0 MiB        5174                   g_score[neighbor] = temp_g_score
    75    128.1 MiB      0.0 MiB        5174                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    128.1 MiB      0.0 MiB        5174                   if neighbor not in open_set_hash:
    77    128.1 MiB      0.0 MiB        5174                       count += 1
    78    128.1 MiB      0.0 MiB        5174                       open_set.put((f_score[neighbor], count, neighbor))
    79    128.1 MiB      0.0 MiB        5174                       open_set_hash.add(neighbor)
    80                                                             
    81    128.1 MiB      0.0 MiB        4699           if draw is not None:
    82                                                     draw()
    83                                         
    84    128.1 MiB      0.0 MiB        4699           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    128.2 MiB    128.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    128.2 MiB      0.0 MiB         257       for row in grid:
    32    128.2 MiB      0.0 MiB       65792           for spot in row:
    33    128.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    128.2 MiB      0.0 MiB           1       count = 0
    36    128.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    128.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    128.2 MiB      0.0 MiB           1       came_from = {}
    39    130.7 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    130.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.5 MiB      3.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.5 MiB      0.0 MiB        1890       while not open_set.empty():
    49    134.5 MiB      0.0 MiB        1890           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.5 MiB      0.0 MiB        1890           current = open_set.get()[2]
    55    134.5 MiB      0.0 MiB        1890           open_set_hash.remove(current)
    56                                         
    57    134.5 MiB      0.0 MiB        1890           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.5 MiB      0.0 MiB        1890           if current == end:
    62    134.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.5 MiB      0.0 MiB       17001           for neighbor in current.neighbors:
    67    134.5 MiB      0.0 MiB       15112               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.5 MiB      0.0 MiB        7556                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.5 MiB      0.0 MiB        7556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.5 MiB      0.0 MiB       15112               if temp_g_score < g_score[neighbor]:
    73    134.5 MiB      0.0 MiB        2152                   came_from[neighbor] = current
    74    134.5 MiB      0.0 MiB        2152                   g_score[neighbor] = temp_g_score
    75    134.5 MiB      0.0 MiB        2152                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.5 MiB      0.0 MiB        2152                   if neighbor not in open_set_hash:
    77    134.5 MiB      0.0 MiB        2152                       count += 1
    78    134.5 MiB      0.0 MiB        2152                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.5 MiB      0.0 MiB        2152                       open_set_hash.add(neighbor)
    80                                                             
    81    134.5 MiB      0.0 MiB        1889           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.5 MiB      0.0 MiB        1889           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.5 MiB    134.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.5 MiB      0.0 MiB         257       for row in grid:
    32    134.5 MiB      0.0 MiB       65792           for spot in row:
    33    134.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.5 MiB      0.0 MiB           1       count = 0
    36    134.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.5 MiB      0.0 MiB           1       came_from = {}
    39    134.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.5 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.5 MiB      0.0 MiB        8184       while not open_set.empty():
    49    134.5 MiB      0.0 MiB        8184           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.5 MiB      0.0 MiB        8184           current = open_set.get()[2]
    55    134.5 MiB      0.0 MiB        8184           open_set_hash.remove(current)
    56                                         
    57    134.5 MiB      0.0 MiB        8184           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.5 MiB      0.0 MiB        8184           if current == end:
    62    134.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.5 MiB      0.0 MiB       73647           for neighbor in current.neighbors:
    67    134.5 MiB      0.0 MiB       65464               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.5 MiB      0.0 MiB       32732                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.5 MiB      0.0 MiB       32732                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.5 MiB      0.0 MiB       65464               if temp_g_score < g_score[neighbor]:
    73    134.5 MiB      0.0 MiB        8720                   came_from[neighbor] = current
    74    134.5 MiB      0.0 MiB        8720                   g_score[neighbor] = temp_g_score
    75    134.5 MiB      0.0 MiB        8720                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.5 MiB      0.0 MiB        8720                   if neighbor not in open_set_hash:
    77    134.5 MiB      0.0 MiB        8720                       count += 1
    78    134.5 MiB      0.0 MiB        8720                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.5 MiB      0.0 MiB        8720                       open_set_hash.add(neighbor)
    80                                                             
    81    134.5 MiB      0.0 MiB        8183           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.5 MiB      0.0 MiB        8183           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.5 MiB    134.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.5 MiB      0.0 MiB         257       for row in grid:
    32    134.5 MiB      0.0 MiB       65792           for spot in row:
    33    134.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.5 MiB      0.0 MiB           1       count = 0
    36    134.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.5 MiB      0.0 MiB           1       came_from = {}
    39    134.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.5 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.5 MiB      0.0 MiB        1342       while not open_set.empty():
    49    134.5 MiB      0.0 MiB        1342           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.5 MiB      0.0 MiB        1342           current = open_set.get()[2]
    55    134.5 MiB      0.0 MiB        1342           open_set_hash.remove(current)
    56                                         
    57    134.5 MiB      0.0 MiB        1342           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.5 MiB      0.0 MiB        1342           if current == end:
    62    134.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.5 MiB      0.0 MiB       12069           for neighbor in current.neighbors:
    67    134.5 MiB      0.0 MiB       10728               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.5 MiB      0.0 MiB        5364                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.5 MiB      0.0 MiB        5364                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.5 MiB      0.0 MiB       10728               if temp_g_score < g_score[neighbor]:
    73    134.5 MiB      0.0 MiB        1628                   came_from[neighbor] = current
    74    134.5 MiB      0.0 MiB        1628                   g_score[neighbor] = temp_g_score
    75    134.5 MiB      0.0 MiB        1628                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.5 MiB      0.0 MiB        1628                   if neighbor not in open_set_hash:
    77    134.5 MiB      0.0 MiB        1628                       count += 1
    78    134.5 MiB      0.0 MiB        1628                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.5 MiB      0.0 MiB        1628                       open_set_hash.add(neighbor)
    80                                                             
    81    134.5 MiB      0.0 MiB        1341           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.5 MiB      0.0 MiB        1341           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.5 MiB    134.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.5 MiB      0.0 MiB         257       for row in grid:
    32    134.5 MiB      0.0 MiB       65792           for spot in row:
    33    134.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.5 MiB      0.0 MiB           1       count = 0
    36    134.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.5 MiB      0.0 MiB           1       came_from = {}
    39    134.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.5 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.5 MiB      0.0 MiB         434       while not open_set.empty():
    49    134.5 MiB      0.0 MiB         434           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.5 MiB      0.0 MiB         434           current = open_set.get()[2]
    55    134.5 MiB      0.0 MiB         434           open_set_hash.remove(current)
    56                                         
    57    134.5 MiB      0.0 MiB         434           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.5 MiB      0.0 MiB         434           if current == end:
    62    134.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.5 MiB      0.0 MiB        3897           for neighbor in current.neighbors:
    67    134.5 MiB      0.0 MiB        3464               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.5 MiB      0.0 MiB        1732                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.5 MiB      0.0 MiB        1732                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.5 MiB      0.0 MiB        3464               if temp_g_score < g_score[neighbor]:
    73    134.5 MiB      0.0 MiB         584                   came_from[neighbor] = current
    74    134.5 MiB      0.0 MiB         584                   g_score[neighbor] = temp_g_score
    75    134.5 MiB      0.0 MiB         584                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.5 MiB      0.0 MiB         584                   if neighbor not in open_set_hash:
    77    134.5 MiB      0.0 MiB         584                       count += 1
    78    134.5 MiB      0.0 MiB         584                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.5 MiB      0.0 MiB         584                       open_set_hash.add(neighbor)
    80                                                             
    81    134.5 MiB      0.0 MiB         433           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.5 MiB      0.0 MiB         433           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.8 MiB    134.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.8 MiB      0.0 MiB         257       for row in grid:
    32    134.8 MiB      0.0 MiB       65792           for spot in row:
    33    134.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.8 MiB      0.0 MiB           1       count = 0
    36    134.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.8 MiB      0.0 MiB           1       came_from = {}
    39    134.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.8 MiB -137439.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    132.8 MiB     -2.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    132.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    132.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    132.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    132.8 MiB      0.0 MiB         826       while not open_set.empty():
    49    132.8 MiB      0.0 MiB         826           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    132.8 MiB      0.0 MiB         826           current = open_set.get()[2]
    55    132.8 MiB      0.0 MiB         826           open_set_hash.remove(current)
    56                                         
    57    132.8 MiB      0.0 MiB         826           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    132.8 MiB      0.0 MiB         826           if current == end:
    62    132.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    132.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    132.8 MiB      0.0 MiB        7425           for neighbor in current.neighbors:
    67    132.8 MiB      0.0 MiB        6600               if current.row != neighbor.row and current.col != neighbor.col:
    68    132.8 MiB      0.0 MiB        3300                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    132.8 MiB      0.0 MiB        3300                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    132.8 MiB      0.0 MiB        6600               if temp_g_score < g_score[neighbor]:
    73    132.8 MiB      0.0 MiB         998                   came_from[neighbor] = current
    74    132.8 MiB      0.0 MiB         998                   g_score[neighbor] = temp_g_score
    75    132.8 MiB      0.0 MiB         998                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    132.8 MiB      0.0 MiB         998                   if neighbor not in open_set_hash:
    77    132.8 MiB      0.0 MiB         998                       count += 1
    78    132.8 MiB      0.0 MiB         998                       open_set.put((f_score[neighbor], count, neighbor))
    79    132.8 MiB      0.0 MiB         998                       open_set_hash.add(neighbor)
    80                                                             
    81    132.8 MiB      0.0 MiB         825           if draw is not None:
    82                                                     draw()
    83                                         
    84    132.8 MiB      0.0 MiB         825           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    132.8 MiB    132.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    132.8 MiB      0.0 MiB         257       for row in grid:
    32    132.8 MiB      0.0 MiB       65792           for spot in row:
    33    132.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    132.8 MiB      0.0 MiB           1       count = 0
    36    132.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    132.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    132.8 MiB      0.0 MiB           1       came_from = {}
    39    132.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    132.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    132.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    132.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    132.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    132.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    132.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    132.8 MiB      0.0 MiB         918       while not open_set.empty():
    49    132.8 MiB      0.0 MiB         918           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    132.8 MiB      0.0 MiB         918           current = open_set.get()[2]
    55    132.8 MiB      0.0 MiB         918           open_set_hash.remove(current)
    56                                         
    57    132.8 MiB      0.0 MiB         918           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    132.8 MiB      0.0 MiB         918           if current == end:
    62    132.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    132.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    132.8 MiB      0.0 MiB        8253           for neighbor in current.neighbors:
    67    132.8 MiB      0.0 MiB        7336               if current.row != neighbor.row and current.col != neighbor.col:
    68    132.8 MiB      0.0 MiB        3668                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    132.8 MiB      0.0 MiB        3668                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    132.8 MiB      0.0 MiB        7336               if temp_g_score < g_score[neighbor]:
    73    132.8 MiB      0.0 MiB        1090                   came_from[neighbor] = current
    74    132.8 MiB      0.0 MiB        1090                   g_score[neighbor] = temp_g_score
    75    132.8 MiB      0.0 MiB        1090                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    132.8 MiB      0.0 MiB        1090                   if neighbor not in open_set_hash:
    77    132.8 MiB      0.0 MiB        1090                       count += 1
    78    132.8 MiB      0.0 MiB        1090                       open_set.put((f_score[neighbor], count, neighbor))
    79    132.8 MiB      0.0 MiB        1090                       open_set_hash.add(neighbor)
    80                                                             
    81    132.8 MiB      0.0 MiB         917           if draw is not None:
    82                                                     draw()
    83                                         
    84    132.8 MiB      0.0 MiB         917           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.8 MiB    134.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.8 MiB      0.0 MiB         257       for row in grid:
    32    134.8 MiB      0.0 MiB       65792           for spot in row:
    33    134.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.8 MiB      0.0 MiB           1       count = 0
    36    134.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.8 MiB      0.0 MiB           1       came_from = {}
    39    134.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.8 MiB      0.0 MiB         928       while not open_set.empty():
    49    134.8 MiB      0.0 MiB         928           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.8 MiB      0.0 MiB         928           current = open_set.get()[2]
    55    134.8 MiB      0.0 MiB         928           open_set_hash.remove(current)
    56                                         
    57    134.8 MiB      0.0 MiB         928           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.8 MiB      0.0 MiB         928           if current == end:
    62    134.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.8 MiB      0.0 MiB        8343           for neighbor in current.neighbors:
    67    134.8 MiB      0.0 MiB        7416               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.8 MiB      0.0 MiB        3708                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.8 MiB      0.0 MiB        3708                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.8 MiB      0.0 MiB        7416               if temp_g_score < g_score[neighbor]:
    73    134.8 MiB      0.0 MiB        1106                   came_from[neighbor] = current
    74    134.8 MiB      0.0 MiB        1106                   g_score[neighbor] = temp_g_score
    75    134.8 MiB      0.0 MiB        1106                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.8 MiB      0.0 MiB        1106                   if neighbor not in open_set_hash:
    77    134.8 MiB      0.0 MiB        1106                       count += 1
    78    134.8 MiB      0.0 MiB        1106                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.8 MiB      0.0 MiB        1106                       open_set_hash.add(neighbor)
    80                                                             
    81    134.8 MiB      0.0 MiB         927           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.8 MiB      0.0 MiB         927           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.8 MiB    134.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.8 MiB      0.0 MiB         257       for row in grid:
    32    134.8 MiB      0.0 MiB       65792           for spot in row:
    33    134.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.8 MiB      0.0 MiB           1       count = 0
    36    134.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.8 MiB      0.0 MiB           1       came_from = {}
    39    134.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.8 MiB      0.0 MiB        2904       while not open_set.empty():
    49    134.8 MiB      0.0 MiB        2904           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.8 MiB      0.0 MiB        2904           current = open_set.get()[2]
    55    134.8 MiB      0.0 MiB        2904           open_set_hash.remove(current)
    56                                         
    57    134.8 MiB      0.0 MiB        2904           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.8 MiB      0.0 MiB        2904           if current == end:
    62    134.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.8 MiB      0.0 MiB       26127           for neighbor in current.neighbors:
    67    134.8 MiB      0.0 MiB       23224               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.8 MiB      0.0 MiB       11612                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.8 MiB      0.0 MiB       11612                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.8 MiB      0.0 MiB       23224               if temp_g_score < g_score[neighbor]:
    73    134.8 MiB      0.0 MiB        3240                   came_from[neighbor] = current
    74    134.8 MiB      0.0 MiB        3240                   g_score[neighbor] = temp_g_score
    75    134.8 MiB      0.0 MiB        3240                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.8 MiB      0.0 MiB        3240                   if neighbor not in open_set_hash:
    77    134.8 MiB      0.0 MiB        3240                       count += 1
    78    134.8 MiB      0.0 MiB        3240                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.8 MiB      0.0 MiB        3240                       open_set_hash.add(neighbor)
    80                                                             
    81    134.8 MiB      0.0 MiB        2903           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.8 MiB      0.0 MiB        2903           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.8 MiB    134.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.8 MiB      0.0 MiB         257       for row in grid:
    32    134.8 MiB      0.0 MiB       65792           for spot in row:
    33    134.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.8 MiB      0.0 MiB           1       count = 0
    36    134.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.8 MiB      0.0 MiB           1       came_from = {}
    39    134.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.8 MiB      0.0 MiB        4832       while not open_set.empty():
    49    134.8 MiB      0.0 MiB        4832           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.8 MiB      0.0 MiB        4832           current = open_set.get()[2]
    55    134.8 MiB      0.0 MiB        4832           open_set_hash.remove(current)
    56                                         
    57    134.8 MiB      0.0 MiB        4832           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.8 MiB      0.0 MiB        4832           if current == end:
    62    134.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.8 MiB      0.0 MiB       43479           for neighbor in current.neighbors:
    67    134.8 MiB      0.0 MiB       38648               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.8 MiB      0.0 MiB       19324                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.8 MiB      0.0 MiB       19324                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.8 MiB      0.0 MiB       38648               if temp_g_score < g_score[neighbor]:
    73    134.8 MiB      0.0 MiB        5260                   came_from[neighbor] = current
    74    134.8 MiB      0.0 MiB        5260                   g_score[neighbor] = temp_g_score
    75    134.8 MiB      0.0 MiB        5260                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.8 MiB      0.0 MiB        5260                   if neighbor not in open_set_hash:
    77    134.8 MiB      0.0 MiB        5260                       count += 1
    78    134.8 MiB      0.0 MiB        5260                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.8 MiB      0.0 MiB        5260                       open_set_hash.add(neighbor)
    80                                                             
    81    134.8 MiB      0.0 MiB        4831           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.8 MiB      0.0 MiB        4831           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.9 MiB    134.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.9 MiB      0.0 MiB         257       for row in grid:
    32    134.9 MiB      0.0 MiB       65792           for spot in row:
    33    134.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.9 MiB      0.0 MiB           1       count = 0
    36    134.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.9 MiB      0.0 MiB           1       came_from = {}
    39    134.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.9 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.9 MiB      0.0 MiB         276       while not open_set.empty():
    49    134.9 MiB      0.0 MiB         276           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.9 MiB      0.0 MiB         276           current = open_set.get()[2]
    55    134.9 MiB      0.0 MiB         276           open_set_hash.remove(current)
    56                                         
    57    134.9 MiB      0.0 MiB         276           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.9 MiB      0.0 MiB         276           if current == end:
    62    134.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.9 MiB      0.0 MiB        2475           for neighbor in current.neighbors:
    67    134.9 MiB      0.0 MiB        2200               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.9 MiB      0.0 MiB        1100                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.9 MiB      0.0 MiB        1100                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.9 MiB      0.0 MiB        2200               if temp_g_score < g_score[neighbor]:
    73    134.9 MiB      0.0 MiB         390                   came_from[neighbor] = current
    74    134.9 MiB      0.0 MiB         390                   g_score[neighbor] = temp_g_score
    75    134.9 MiB      0.0 MiB         390                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.9 MiB      0.0 MiB         390                   if neighbor not in open_set_hash:
    77    134.9 MiB      0.0 MiB         390                       count += 1
    78    134.9 MiB      0.0 MiB         390                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.9 MiB      0.0 MiB         390                       open_set_hash.add(neighbor)
    80                                                             
    81    134.9 MiB      0.0 MiB         275           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.9 MiB      0.0 MiB         275           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.9 MiB    134.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.9 MiB      0.0 MiB         257       for row in grid:
    32    134.9 MiB      0.0 MiB       65792           for spot in row:
    33    134.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.9 MiB      0.0 MiB           1       count = 0
    36    134.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.9 MiB      0.0 MiB           1       came_from = {}
    39    134.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.9 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.9 MiB      0.0 MiB        5616       while not open_set.empty():
    49    134.9 MiB      0.0 MiB        5616           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.9 MiB      0.0 MiB        5616           current = open_set.get()[2]
    55    134.9 MiB      0.0 MiB        5616           open_set_hash.remove(current)
    56                                         
    57    134.9 MiB      0.0 MiB        5616           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.9 MiB      0.0 MiB        5616           if current == end:
    62    134.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.9 MiB      0.0 MiB       50535           for neighbor in current.neighbors:
    67    134.9 MiB      0.0 MiB       44920               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.9 MiB      0.0 MiB       22460                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.9 MiB      0.0 MiB       22460                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.9 MiB      0.0 MiB       44920               if temp_g_score < g_score[neighbor]:
    73    134.9 MiB      0.0 MiB        6040                   came_from[neighbor] = current
    74    134.9 MiB      0.0 MiB        6040                   g_score[neighbor] = temp_g_score
    75    134.9 MiB      0.0 MiB        6040                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.9 MiB      0.0 MiB        6040                   if neighbor not in open_set_hash:
    77    134.9 MiB      0.0 MiB        6040                       count += 1
    78    134.9 MiB      0.0 MiB        6040                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.9 MiB      0.0 MiB        6040                       open_set_hash.add(neighbor)
    80                                                             
    81    134.9 MiB      0.0 MiB        5615           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.9 MiB      0.0 MiB        5615           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.4 MiB    135.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.4 MiB     -2.3 MiB         257       for row in grid:
    32    135.4 MiB   -580.3 MiB       65792           for spot in row:
    33    135.4 MiB   -578.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.4 MiB     -0.0 MiB           1       count = 0
    36    135.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.4 MiB      0.0 MiB           1       came_from = {}
    39    135.4 MiB -41900.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    133.6 MiB     -1.8 MiB           1       g_score[start] = 0
    41    133.6 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    133.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    133.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    133.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    133.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    133.6 MiB      0.0 MiB         775       while not open_set.empty():
    49    133.6 MiB      0.0 MiB         775           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    133.6 MiB      0.0 MiB         775           current = open_set.get()[2]
    55    133.6 MiB      0.0 MiB         775           open_set_hash.remove(current)
    56                                         
    57    133.6 MiB      0.0 MiB         775           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    133.6 MiB      0.0 MiB         775           if current == end:
    62    133.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    133.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    133.6 MiB      0.0 MiB        6966           for neighbor in current.neighbors:
    67    133.6 MiB      0.0 MiB        6192               if current.row != neighbor.row and current.col != neighbor.col:
    68    133.6 MiB      0.0 MiB        3096                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    133.6 MiB      0.0 MiB        3096                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    133.6 MiB      0.0 MiB        6192               if temp_g_score < g_score[neighbor]:
    73    133.6 MiB      0.0 MiB        1103                   came_from[neighbor] = current
    74    133.6 MiB      0.0 MiB        1103                   g_score[neighbor] = temp_g_score
    75    133.6 MiB      0.0 MiB        1103                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    133.6 MiB      0.0 MiB        1103                   if neighbor not in open_set_hash:
    77    133.6 MiB      0.0 MiB        1103                       count += 1
    78    133.6 MiB      0.0 MiB        1103                       open_set.put((f_score[neighbor], count, neighbor))
    79    133.6 MiB      0.0 MiB        1103                       open_set_hash.add(neighbor)
    80                                                             
    81    133.6 MiB      0.0 MiB         774           if draw is not None:
    82                                                     draw()
    83                                         
    84    133.6 MiB      0.0 MiB         774           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    131.6 MiB    131.6 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    131.6 MiB      0.0 MiB         257       for row in grid:
    32    131.6 MiB      0.0 MiB       65792           for spot in row:
    33    131.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    131.6 MiB      0.0 MiB           1       count = 0
    36    131.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    131.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    131.6 MiB      0.0 MiB           1       came_from = {}
    39    131.6 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    131.6 MiB      0.0 MiB           1       g_score[start] = 0
    41    131.6 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    131.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    131.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    131.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    131.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    131.6 MiB      0.0 MiB         297       while not open_set.empty():
    49    131.6 MiB      0.0 MiB         297           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    131.6 MiB      0.0 MiB         297           current = open_set.get()[2]
    55    131.6 MiB      0.0 MiB         297           open_set_hash.remove(current)
    56                                         
    57    131.6 MiB      0.0 MiB         297           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    131.6 MiB      0.0 MiB         297           if current == end:
    62    131.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    131.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    131.6 MiB      0.0 MiB        2664           for neighbor in current.neighbors:
    67    131.6 MiB      0.0 MiB        2368               if current.row != neighbor.row and current.col != neighbor.col:
    68    131.6 MiB      0.0 MiB        1184                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    131.6 MiB      0.0 MiB        1184                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    131.6 MiB      0.0 MiB        2368               if temp_g_score < g_score[neighbor]:
    73    131.6 MiB      0.0 MiB         425                   came_from[neighbor] = current
    74    131.6 MiB      0.0 MiB         425                   g_score[neighbor] = temp_g_score
    75    131.6 MiB      0.0 MiB         425                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    131.6 MiB      0.0 MiB         425                   if neighbor not in open_set_hash:
    77    131.6 MiB      0.0 MiB         425                       count += 1
    78    131.6 MiB      0.0 MiB         425                       open_set.put((f_score[neighbor], count, neighbor))
    79    131.6 MiB      0.0 MiB         425                       open_set_hash.add(neighbor)
    80                                                             
    81    131.6 MiB      0.0 MiB         296           if draw is not None:
    82                                                     draw()
    83                                         
    84    131.6 MiB      0.0 MiB         296           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    131.6 MiB    131.6 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    131.6 MiB      0.0 MiB         257       for row in grid:
    32    131.6 MiB      0.0 MiB       65792           for spot in row:
    33    131.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    131.6 MiB      0.0 MiB           1       count = 0
    36    131.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    131.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    131.6 MiB      0.0 MiB           1       came_from = {}
    39    131.6 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    131.6 MiB      0.0 MiB           1       g_score[start] = 0
    41    131.6 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    131.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    131.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    131.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    131.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    131.6 MiB      0.0 MiB         560       while not open_set.empty():
    49    131.6 MiB      0.0 MiB         560           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    131.6 MiB      0.0 MiB         560           current = open_set.get()[2]
    55    131.6 MiB      0.0 MiB         560           open_set_hash.remove(current)
    56                                         
    57    131.6 MiB      0.0 MiB         560           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    131.6 MiB      0.0 MiB         560           if current == end:
    62    131.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    131.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    131.6 MiB      0.0 MiB        5031           for neighbor in current.neighbors:
    67    131.6 MiB      0.0 MiB        4472               if current.row != neighbor.row and current.col != neighbor.col:
    68    131.6 MiB      0.0 MiB        2236                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    131.6 MiB      0.0 MiB        2236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    131.6 MiB      0.0 MiB        4472               if temp_g_score < g_score[neighbor]:
    73    131.6 MiB      0.0 MiB         746                   came_from[neighbor] = current
    74    131.6 MiB      0.0 MiB         746                   g_score[neighbor] = temp_g_score
    75    131.6 MiB      0.0 MiB         746                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    131.6 MiB      0.0 MiB         746                   if neighbor not in open_set_hash:
    77    131.6 MiB      0.0 MiB         746                       count += 1
    78    131.6 MiB      0.0 MiB         746                       open_set.put((f_score[neighbor], count, neighbor))
    79    131.6 MiB      0.0 MiB         746                       open_set_hash.add(neighbor)
    80                                                             
    81    131.6 MiB      0.0 MiB         559           if draw is not None:
    82                                                     draw()
    83                                         
    84    131.6 MiB      0.0 MiB         559           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    131.6 MiB    131.6 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    131.6 MiB      0.0 MiB         257       for row in grid:
    32    131.6 MiB      0.0 MiB       65792           for spot in row:
    33    131.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    131.6 MiB      0.0 MiB           1       count = 0
    36    131.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    131.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    131.6 MiB      0.0 MiB           1       came_from = {}
    39    131.6 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    131.6 MiB      0.0 MiB           1       g_score[start] = 0
    41    131.6 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    131.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    131.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    131.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    131.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    131.8 MiB      0.0 MiB        3696       while not open_set.empty():
    49    131.8 MiB      0.0 MiB        3696           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    131.8 MiB      0.0 MiB        3696           current = open_set.get()[2]
    55    131.8 MiB      0.0 MiB        3696           open_set_hash.remove(current)
    56                                         
    57    131.8 MiB      0.0 MiB        3696           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    131.8 MiB      0.0 MiB        3696           if current == end:
    62    131.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    131.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    131.8 MiB      0.0 MiB       33255           for neighbor in current.neighbors:
    67    131.8 MiB      0.0 MiB       29560               if current.row != neighbor.row and current.col != neighbor.col:
    68    131.8 MiB      0.0 MiB       14780                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    131.8 MiB      0.0 MiB       14780                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    131.8 MiB      0.0 MiB       29560               if temp_g_score < g_score[neighbor]:
    73    131.8 MiB      0.2 MiB        4040                   came_from[neighbor] = current
    74    131.8 MiB      0.0 MiB        4040                   g_score[neighbor] = temp_g_score
    75    131.8 MiB      0.0 MiB        4040                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    131.8 MiB      0.0 MiB        4040                   if neighbor not in open_set_hash:
    77    131.8 MiB      0.0 MiB        4040                       count += 1
    78    131.8 MiB      0.0 MiB        4040                       open_set.put((f_score[neighbor], count, neighbor))
    79    131.8 MiB      0.0 MiB        4040                       open_set_hash.add(neighbor)
    80                                                             
    81    131.8 MiB      0.0 MiB        3695           if draw is not None:
    82                                                     draw()
    83                                         
    84    131.8 MiB      0.0 MiB        3695           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    133.8 MiB    133.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    133.8 MiB      0.0 MiB         257       for row in grid:
    32    133.8 MiB      0.0 MiB       65792           for spot in row:
    33    133.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    133.8 MiB      0.0 MiB           1       count = 0
    36    133.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    133.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    133.8 MiB      0.0 MiB           1       came_from = {}
    39    133.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    133.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    133.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    133.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    133.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    133.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    133.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    133.8 MiB      0.0 MiB        4608       while not open_set.empty():
    49    133.8 MiB      0.0 MiB        4608           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    133.8 MiB      0.0 MiB        4608           current = open_set.get()[2]
    55    133.8 MiB      0.0 MiB        4608           open_set_hash.remove(current)
    56                                         
    57    133.8 MiB      0.0 MiB        4608           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    133.8 MiB      0.0 MiB        4608           if current == end:
    62    133.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    133.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    133.8 MiB      0.0 MiB       41463           for neighbor in current.neighbors:
    67    133.8 MiB      0.0 MiB       36856               if current.row != neighbor.row and current.col != neighbor.col:
    68    133.8 MiB      0.0 MiB       18428                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    133.8 MiB      0.0 MiB       18428                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    133.8 MiB      0.0 MiB       36856               if temp_g_score < g_score[neighbor]:
    73    133.8 MiB      0.0 MiB        5190                   came_from[neighbor] = current
    74    133.8 MiB      0.0 MiB        5190                   g_score[neighbor] = temp_g_score
    75    133.8 MiB      0.0 MiB        5190                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    133.8 MiB      0.0 MiB        5190                   if neighbor not in open_set_hash:
    77    133.8 MiB      0.0 MiB        5190                       count += 1
    78    133.8 MiB      0.0 MiB        5190                       open_set.put((f_score[neighbor], count, neighbor))
    79    133.8 MiB      0.0 MiB        5190                       open_set_hash.add(neighbor)
    80                                                             
    81    133.8 MiB      0.0 MiB        4607           if draw is not None:
    82                                                     draw()
    83                                         
    84    133.8 MiB      0.0 MiB        4607           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    133.8 MiB    133.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    133.8 MiB      0.0 MiB         257       for row in grid:
    32    133.8 MiB      0.0 MiB       65792           for spot in row:
    33    133.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    133.8 MiB      0.0 MiB           1       count = 0
    36    133.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    133.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    133.8 MiB      0.0 MiB           1       came_from = {}
    39    133.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    133.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    133.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    133.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    133.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    133.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    133.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    133.8 MiB      0.0 MiB        1152       while not open_set.empty():
    49    133.8 MiB      0.0 MiB        1152           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    133.8 MiB      0.0 MiB        1152           current = open_set.get()[2]
    55    133.8 MiB      0.0 MiB        1152           open_set_hash.remove(current)
    56                                         
    57    133.8 MiB      0.0 MiB        1152           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    133.8 MiB      0.0 MiB        1152           if current == end:
    62    133.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    133.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    133.8 MiB      0.0 MiB       10359           for neighbor in current.neighbors:
    67    133.8 MiB      0.0 MiB        9208               if current.row != neighbor.row and current.col != neighbor.col:
    68    133.8 MiB      0.0 MiB        4604                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    133.8 MiB      0.0 MiB        4604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    133.8 MiB      0.0 MiB        9208               if temp_g_score < g_score[neighbor]:
    73    133.8 MiB      0.0 MiB        1442                   came_from[neighbor] = current
    74    133.8 MiB      0.0 MiB        1442                   g_score[neighbor] = temp_g_score
    75    133.8 MiB      0.0 MiB        1442                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    133.8 MiB      0.0 MiB        1442                   if neighbor not in open_set_hash:
    77    133.8 MiB      0.0 MiB        1442                       count += 1
    78    133.8 MiB      0.0 MiB        1442                       open_set.put((f_score[neighbor], count, neighbor))
    79    133.8 MiB      0.0 MiB        1442                       open_set_hash.add(neighbor)
    80                                                             
    81    133.8 MiB      0.0 MiB        1151           if draw is not None:
    82                                                     draw()
    83                                         
    84    133.8 MiB      0.0 MiB        1151           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    133.8 MiB    133.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    133.8 MiB      0.0 MiB         257       for row in grid:
    32    133.8 MiB      0.0 MiB       65792           for spot in row:
    33    133.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    133.8 MiB      0.0 MiB           1       count = 0
    36    133.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    133.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    133.8 MiB      0.0 MiB           1       came_from = {}
    39    133.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    133.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    133.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    133.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    133.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    133.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    133.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    133.8 MiB      0.0 MiB         533       while not open_set.empty():
    49    133.8 MiB      0.0 MiB         533           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    133.8 MiB      0.0 MiB         533           current = open_set.get()[2]
    55    133.8 MiB      0.0 MiB         533           open_set_hash.remove(current)
    56                                         
    57    133.8 MiB      0.0 MiB         533           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    133.8 MiB      0.0 MiB         533           if current == end:
    62    133.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    133.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    133.8 MiB      0.0 MiB        4788           for neighbor in current.neighbors:
    67    133.8 MiB      0.0 MiB        4256               if current.row != neighbor.row and current.col != neighbor.col:
    68    133.8 MiB      0.0 MiB        2128                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    133.8 MiB      0.0 MiB        2128                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    133.8 MiB      0.0 MiB        4256               if temp_g_score < g_score[neighbor]:
    73    133.8 MiB      0.0 MiB         721                   came_from[neighbor] = current
    74    133.8 MiB      0.0 MiB         721                   g_score[neighbor] = temp_g_score
    75    133.8 MiB      0.0 MiB         721                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    133.8 MiB      0.0 MiB         721                   if neighbor not in open_set_hash:
    77    133.8 MiB      0.0 MiB         721                       count += 1
    78    133.8 MiB      0.0 MiB         721                       open_set.put((f_score[neighbor], count, neighbor))
    79    133.8 MiB      0.0 MiB         721                       open_set_hash.add(neighbor)
    80                                                             
    81    133.8 MiB      0.0 MiB         532           if draw is not None:
    82                                                     draw()
    83                                         
    84    133.8 MiB      0.0 MiB         532           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    133.8 MiB    133.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    133.8 MiB      0.0 MiB         257       for row in grid:
    32    133.8 MiB      0.0 MiB       65792           for spot in row:
    33    133.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    133.8 MiB      0.0 MiB           1       count = 0
    36    133.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    133.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    133.8 MiB      0.0 MiB           1       came_from = {}
    39    133.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    133.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    133.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    133.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    133.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    133.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    133.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    133.8 MiB      0.0 MiB        3082       while not open_set.empty():
    49    133.8 MiB      0.0 MiB        3082           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    133.8 MiB      0.0 MiB        3082           current = open_set.get()[2]
    55    133.8 MiB      0.0 MiB        3082           open_set_hash.remove(current)
    56                                         
    57    133.8 MiB      0.0 MiB        3082           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    133.8 MiB      0.0 MiB        3082           if current == end:
    62    133.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    133.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    133.8 MiB      0.0 MiB       27729           for neighbor in current.neighbors:
    67    133.8 MiB      0.0 MiB       24648               if current.row != neighbor.row and current.col != neighbor.col:
    68    133.8 MiB      0.0 MiB       12324                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    133.8 MiB      0.0 MiB       12324                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    133.8 MiB      0.0 MiB       24648               if temp_g_score < g_score[neighbor]:
    73    133.8 MiB      0.0 MiB        3398                   came_from[neighbor] = current
    74    133.8 MiB      0.0 MiB        3398                   g_score[neighbor] = temp_g_score
    75    133.8 MiB      0.0 MiB        3398                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    133.8 MiB      0.0 MiB        3398                   if neighbor not in open_set_hash:
    77    133.8 MiB      0.0 MiB        3398                       count += 1
    78    133.8 MiB      0.0 MiB        3398                       open_set.put((f_score[neighbor], count, neighbor))
    79    133.8 MiB      0.0 MiB        3398                       open_set_hash.add(neighbor)
    80                                                             
    81    133.8 MiB      0.0 MiB        3081           if draw is not None:
    82                                                     draw()
    83                                         
    84    133.8 MiB      0.0 MiB        3081           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    133.8 MiB    133.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    133.8 MiB      0.0 MiB         257       for row in grid:
    32    133.8 MiB      0.0 MiB       65792           for spot in row:
    33    133.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    133.8 MiB      0.0 MiB           1       count = 0
    36    133.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    133.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    133.8 MiB      0.0 MiB           1       came_from = {}
    39    133.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    133.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.6 MiB      0.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.6 MiB      0.0 MiB        5795       while not open_set.empty():
    49    134.6 MiB      0.0 MiB        5795           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.6 MiB      0.0 MiB        5795           current = open_set.get()[2]
    55    134.6 MiB      0.0 MiB        5795           open_set_hash.remove(current)
    56                                         
    57    134.6 MiB      0.0 MiB        5795           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.6 MiB      0.0 MiB        5795           if current == end:
    62    134.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.6 MiB      0.0 MiB       52146           for neighbor in current.neighbors:
    67    134.6 MiB      0.0 MiB       46352               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.6 MiB      0.0 MiB       23176                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.6 MiB      0.0 MiB       23176                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.6 MiB      0.0 MiB       46352               if temp_g_score < g_score[neighbor]:
    73    134.6 MiB      0.0 MiB        6227                   came_from[neighbor] = current
    74    134.6 MiB      0.0 MiB        6227                   g_score[neighbor] = temp_g_score
    75    134.6 MiB      0.0 MiB        6227                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.6 MiB      0.0 MiB        6227                   if neighbor not in open_set_hash:
    77    134.6 MiB      0.0 MiB        6227                       count += 1
    78    134.6 MiB      0.0 MiB        6227                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.6 MiB      0.0 MiB        6227                       open_set_hash.add(neighbor)
    80                                                             
    81    134.6 MiB      0.0 MiB        5794           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.6 MiB      0.0 MiB        5794           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.6 MiB    134.6 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.6 MiB      0.0 MiB         257       for row in grid:
    32    134.6 MiB      0.0 MiB       65792           for spot in row:
    33    134.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.6 MiB      0.0 MiB           1       count = 0
    36    134.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.6 MiB      0.0 MiB           1       came_from = {}
    39    135.4 MiB      0.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.4 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.4 MiB      0.0 MiB        3717       while not open_set.empty():
    49    135.4 MiB      0.0 MiB        3717           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.4 MiB      0.0 MiB        3717           current = open_set.get()[2]
    55    135.4 MiB      0.0 MiB        3717           open_set_hash.remove(current)
    56                                         
    57    135.4 MiB      0.0 MiB        3717           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.4 MiB      0.0 MiB        3717           if current == end:
    62    135.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.4 MiB      0.0 MiB       33444           for neighbor in current.neighbors:
    67    135.4 MiB      0.0 MiB       29728               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.4 MiB      0.0 MiB       14864                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.4 MiB      0.0 MiB       14864                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.4 MiB      0.0 MiB       29728               if temp_g_score < g_score[neighbor]:
    73    135.4 MiB      0.0 MiB        4077                   came_from[neighbor] = current
    74    135.4 MiB      0.0 MiB        4077                   g_score[neighbor] = temp_g_score
    75    135.4 MiB      0.0 MiB        4077                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.4 MiB      0.0 MiB        4077                   if neighbor not in open_set_hash:
    77    135.4 MiB      0.0 MiB        4077                       count += 1
    78    135.4 MiB      0.0 MiB        4077                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.4 MiB      0.0 MiB        4077                       open_set_hash.add(neighbor)
    80                                                             
    81    135.4 MiB      0.0 MiB        3716           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.4 MiB      0.0 MiB        3716           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.6 MiB    135.6 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.6 MiB      0.0 MiB         257       for row in grid:
    32    135.6 MiB      0.0 MiB       65792           for spot in row:
    33    135.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.6 MiB      0.0 MiB           1       count = 0
    36    135.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.6 MiB      0.0 MiB           1       came_from = {}
    39    135.6 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.6 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.6 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.6 MiB      0.0 MiB        1408       while not open_set.empty():
    49    135.6 MiB      0.0 MiB        1408           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.6 MiB      0.0 MiB        1408           current = open_set.get()[2]
    55    135.6 MiB      0.0 MiB        1408           open_set_hash.remove(current)
    56                                         
    57    135.6 MiB      0.0 MiB        1408           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.6 MiB      0.0 MiB        1408           if current == end:
    62    135.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.6 MiB      0.0 MiB       12663           for neighbor in current.neighbors:
    67    135.6 MiB      0.0 MiB       11256               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.6 MiB      0.0 MiB        5628                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.6 MiB      0.0 MiB        5628                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.6 MiB      0.0 MiB       11256               if temp_g_score < g_score[neighbor]:
    73    135.6 MiB      0.0 MiB        1622                   came_from[neighbor] = current
    74    135.6 MiB      0.0 MiB        1622                   g_score[neighbor] = temp_g_score
    75    135.6 MiB      0.0 MiB        1622                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.6 MiB      0.0 MiB        1622                   if neighbor not in open_set_hash:
    77    135.6 MiB      0.0 MiB        1622                       count += 1
    78    135.6 MiB      0.0 MiB        1622                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.6 MiB      0.0 MiB        1622                       open_set_hash.add(neighbor)
    80                                                             
    81    135.6 MiB      0.0 MiB        1407           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.6 MiB      0.0 MiB        1407           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.6 MiB    135.6 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.6 MiB      0.0 MiB         257       for row in grid:
    32    135.6 MiB      0.0 MiB       65792           for spot in row:
    33    135.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.6 MiB      0.0 MiB           1       count = 0
    36    135.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.6 MiB      0.0 MiB           1       came_from = {}
    39    135.7 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.9 MiB      1.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.9 MiB      0.0 MiB        1040       while not open_set.empty():
    49    136.9 MiB      0.0 MiB        1040           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.9 MiB      0.0 MiB        1040           current = open_set.get()[2]
    55    136.9 MiB      0.0 MiB        1040           open_set_hash.remove(current)
    56                                         
    57    136.9 MiB      0.0 MiB        1040           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.9 MiB      0.0 MiB        1040           if current == end:
    62    136.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.9 MiB      0.0 MiB        9351           for neighbor in current.neighbors:
    67    136.9 MiB      0.0 MiB        8312               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.9 MiB      0.0 MiB        4156                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.9 MiB      0.0 MiB        4156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.9 MiB      0.0 MiB        8312               if temp_g_score < g_score[neighbor]:
    73    136.9 MiB      0.0 MiB        1232                   came_from[neighbor] = current
    74    136.9 MiB      0.0 MiB        1232                   g_score[neighbor] = temp_g_score
    75    136.9 MiB      0.0 MiB        1232                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.9 MiB      0.0 MiB        1232                   if neighbor not in open_set_hash:
    77    136.9 MiB      0.0 MiB        1232                       count += 1
    78    136.9 MiB      0.0 MiB        1232                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.9 MiB      0.0 MiB        1232                       open_set_hash.add(neighbor)
    80                                                             
    81    136.9 MiB      0.0 MiB        1039           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.9 MiB      0.0 MiB        1039           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.9 MiB    136.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.9 MiB      0.0 MiB         257       for row in grid:
    32    136.9 MiB      0.0 MiB       65792           for spot in row:
    33    136.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.9 MiB      0.0 MiB           1       count = 0
    36    136.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.9 MiB      0.0 MiB           1       came_from = {}
    39    136.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.9 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.9 MiB      0.0 MiB         156       while not open_set.empty():
    49    136.9 MiB      0.0 MiB         156           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.9 MiB      0.0 MiB         156           current = open_set.get()[2]
    55    136.9 MiB      0.0 MiB         156           open_set_hash.remove(current)
    56                                         
    57    136.9 MiB      0.0 MiB         156           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.9 MiB      0.0 MiB         156           if current == end:
    62    136.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.9 MiB      0.0 MiB        1395           for neighbor in current.neighbors:
    67    136.9 MiB      0.0 MiB        1240               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.9 MiB      0.0 MiB         620                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.9 MiB      0.0 MiB         620                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.9 MiB      0.0 MiB        1240               if temp_g_score < g_score[neighbor]:
    73    136.9 MiB      0.0 MiB         248                   came_from[neighbor] = current
    74    136.9 MiB      0.0 MiB         248                   g_score[neighbor] = temp_g_score
    75    136.9 MiB      0.0 MiB         248                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.9 MiB      0.0 MiB         248                   if neighbor not in open_set_hash:
    77    136.9 MiB      0.0 MiB         248                       count += 1
    78    136.9 MiB      0.0 MiB         248                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.9 MiB      0.0 MiB         248                       open_set_hash.add(neighbor)
    80                                                             
    81    136.9 MiB      0.0 MiB         155           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.9 MiB      0.0 MiB         155           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.9 MiB    136.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.9 MiB      0.0 MiB         257       for row in grid:
    32    136.9 MiB      0.0 MiB       65792           for spot in row:
    33    136.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.9 MiB      0.0 MiB           1       count = 0
    36    136.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.9 MiB      0.0 MiB           1       came_from = {}
    39    136.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB        4033       while not open_set.empty():
    49    137.0 MiB      0.0 MiB        4033           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB        4033           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB        4033           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB        4033           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB        4033           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB       36288           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB       32256               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB       16128                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB       16128                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB       32256               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB        4541                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB        4541                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB        4541                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB        4541                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB        4541                       count += 1
    78    137.0 MiB      0.0 MiB        4541                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB        4541                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB        4032           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB        4032           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB       14170       while not open_set.empty():
    49    137.0 MiB      0.0 MiB       14170           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB       14170           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB       14170           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB       14170           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB       14170           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB      127521           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB      113352               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB       56676                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB       56676                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB      113352               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB       14864                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB       14864                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB       14864                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB       14864                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB       14864                       count += 1
    78    137.0 MiB      0.0 MiB       14864                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB       14864                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB       14169           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB       14169           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB         570       while not open_set.empty():
    49    137.0 MiB      0.0 MiB         570           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB         570           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB         570           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB         570           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB         570           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB        5121           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB        4552               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB        2276                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB        2276                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB        4552               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB         726                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB         726                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB         726                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB         726                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB         726                       count += 1
    78    137.0 MiB      0.0 MiB         726                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB         726                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB         569           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB         569           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB        3799       while not open_set.empty():
    49    137.0 MiB      0.0 MiB        3799           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB        3799           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB        3799           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB        3799           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB        3799           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB       34182           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB       30384               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB       15192                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB       15192                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB       30384               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB        4175                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB        4175                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB        4175                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB        4175                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB        4175                       count += 1
    78    137.0 MiB      0.0 MiB        4175                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB        4175                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB        3798           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB        3798           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB         156       while not open_set.empty():
    49    137.0 MiB      0.0 MiB         156           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB         156           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB         156           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB         156           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB         156           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB        1395           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB        1240               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB         620                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB         620                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB        1240               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB         230                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB         230                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB         230                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB         230                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB         230                       count += 1
    78    137.0 MiB      0.0 MiB         230                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB         230                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB         155           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB         155           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB        2280       while not open_set.empty():
    49    137.0 MiB      0.0 MiB        2280           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB        2280           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB        2280           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB        2280           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB        2280           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB       20511           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB       18232               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB        9116                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB        9116                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB       18232               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB        2564                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB        2564                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB        2564                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB        2564                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB        2564                       count += 1
    78    137.0 MiB      0.0 MiB        2564                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB        2564                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB        2279           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB        2279           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB        1998       while not open_set.empty():
    49    137.0 MiB      0.0 MiB        1998           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB        1998           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB        1998           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB        1998           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB        1998           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB       17973           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB       15976               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB        7988                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB        7988                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB       15976               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB        2252                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB        2252                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB        2252                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB        2252                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB        2252                       count += 1
    78    137.0 MiB      0.0 MiB        2252                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB        2252                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB        1997           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB        1997           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB         840       while not open_set.empty():
    49    137.0 MiB      0.0 MiB         840           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB         840           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB         840           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB         840           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB         840           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB        7551           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB        6712               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB        3356                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB        3356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB        6712               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB        1106                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB        1106                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB        1106                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB        1106                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB        1106                       count += 1
    78    137.0 MiB      0.0 MiB        1106                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB        1106                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB         839           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB         839           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB        4648       while not open_set.empty():
    49    137.0 MiB      0.0 MiB        4648           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB        4648           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB        4648           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB        4648           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB        4648           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB       41823           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB       37176               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB       18588                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB       18588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB       37176               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB        5036                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB        5036                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB        5036                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB        5036                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB        5036                       count += 1
    78    137.0 MiB      0.0 MiB        5036                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB        5036                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB        4647           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB        4647           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB        1648       while not open_set.empty():
    49    137.0 MiB      0.0 MiB        1648           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB        1648           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB        1648           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB        1648           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB        1648           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB       14823           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB       13176               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB        6588                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB        6588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB       13176               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB        2090                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB        2090                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB        2090                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB        2090                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB        2090                       count += 1
    78    137.0 MiB      0.0 MiB        2090                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB        2090                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB        1647           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB        1647           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB        2080       while not open_set.empty():
    49    137.0 MiB      0.0 MiB        2080           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB        2080           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB        2080           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB        2080           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB        2080           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB       18711           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB       16632               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB        8316                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB        8316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB       16632               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB        2366                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB        2366                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB        2366                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB        2366                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB        2366                       count += 1
    78    137.0 MiB      0.0 MiB        2366                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB        2366                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB        2079           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB        2079           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB   -345.1 MiB         257       for row in grid:
    32    137.0 MiB -86949.0 MiB       65792           for spot in row:
    33    137.0 MiB -86609.6 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    128.8 MiB     -8.1 MiB           1       count = 0
    36    128.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    128.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    128.8 MiB      0.0 MiB           1       came_from = {}
    39    128.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    128.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    130.7 MiB      1.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    130.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    130.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    130.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46    130.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    130.7 MiB      0.0 MiB        5148       while not open_set.empty():
    49    130.7 MiB      0.0 MiB        5148           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    130.7 MiB      0.0 MiB        5148           current = open_set.get()[2]
    55    130.7 MiB      0.0 MiB        5148           open_set_hash.remove(current)
    56                                         
    57    130.7 MiB      0.0 MiB        5148           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    130.7 MiB      0.0 MiB        5148           if current == end:
    62    130.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    130.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    130.7 MiB      0.0 MiB       46323           for neighbor in current.neighbors:
    67    130.7 MiB      0.0 MiB       41176               if current.row != neighbor.row and current.col != neighbor.col:
    68    130.7 MiB      0.0 MiB       20588                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    130.7 MiB      0.0 MiB       20588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    130.7 MiB      0.0 MiB       41176               if temp_g_score < g_score[neighbor]:
    73    130.7 MiB      0.0 MiB        5590                   came_from[neighbor] = current
    74    130.7 MiB      0.0 MiB        5590                   g_score[neighbor] = temp_g_score
    75    130.7 MiB      0.0 MiB        5590                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    130.7 MiB      0.0 MiB        5590                   if neighbor not in open_set_hash:
    77    130.7 MiB      0.0 MiB        5590                       count += 1
    78    130.7 MiB      0.0 MiB        5590                       open_set.put((f_score[neighbor], count, neighbor))
    79    130.7 MiB      0.0 MiB        5590                       open_set_hash.add(neighbor)
    80                                                             
    81    130.7 MiB      0.0 MiB        5147           if draw is not None:
    82                                                     draw()
    83                                         
    84    130.7 MiB      0.0 MiB        5147           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    130.7 MiB    130.7 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    130.7 MiB      0.0 MiB         257       for row in grid:
    32    130.7 MiB      0.0 MiB       65792           for spot in row:
    33    130.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    130.7 MiB      0.0 MiB           1       count = 0
    36    130.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    130.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    130.7 MiB      0.0 MiB           1       came_from = {}
    39    130.7 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    130.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    132.6 MiB      1.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    132.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    132.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    132.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    132.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    132.6 MiB      0.0 MiB        1720       while not open_set.empty():
    49    132.6 MiB      0.0 MiB        1720           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    132.6 MiB      0.0 MiB        1720           current = open_set.get()[2]
    55    132.6 MiB      0.0 MiB        1720           open_set_hash.remove(current)
    56                                         
    57    132.6 MiB      0.0 MiB        1720           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    132.6 MiB      0.0 MiB        1720           if current == end:
    62    132.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    132.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    132.6 MiB      0.0 MiB       15471           for neighbor in current.neighbors:
    67    132.6 MiB      0.0 MiB       13752               if current.row != neighbor.row and current.col != neighbor.col:
    68    132.6 MiB      0.0 MiB        6876                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    132.6 MiB      0.0 MiB        6876                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    132.6 MiB      0.0 MiB       13752               if temp_g_score < g_score[neighbor]:
    73    132.6 MiB      0.0 MiB        2102                   came_from[neighbor] = current
    74    132.6 MiB      0.0 MiB        2102                   g_score[neighbor] = temp_g_score
    75    132.6 MiB      0.0 MiB        2102                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    132.6 MiB      0.0 MiB        2102                   if neighbor not in open_set_hash:
    77    132.6 MiB      0.0 MiB        2102                       count += 1
    78    132.6 MiB      0.0 MiB        2102                       open_set.put((f_score[neighbor], count, neighbor))
    79    132.6 MiB      0.0 MiB        2102                       open_set_hash.add(neighbor)
    80                                                             
    81    132.6 MiB      0.0 MiB        1719           if draw is not None:
    82                                                     draw()
    83                                         
    84    132.6 MiB      0.0 MiB        1719           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    132.6 MiB    132.6 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    132.6 MiB      0.0 MiB         257       for row in grid:
    32    132.6 MiB      0.0 MiB       65792           for spot in row:
    33    132.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    132.6 MiB      0.0 MiB           1       count = 0
    36    132.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    132.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    132.6 MiB      0.0 MiB           1       came_from = {}
    39    134.1 MiB      1.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.1 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.1 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.1 MiB      0.0 MiB       14847       while not open_set.empty():
    49    134.1 MiB      0.0 MiB       14847           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.1 MiB      0.0 MiB       14847           current = open_set.get()[2]
    55    134.1 MiB      0.0 MiB       14847           open_set_hash.remove(current)
    56                                         
    57    134.1 MiB      0.0 MiB       14847           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.1 MiB      0.0 MiB       14847           if current == end:
    62    134.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.1 MiB      0.0 MiB      133614           for neighbor in current.neighbors:
    67    134.1 MiB      0.0 MiB      118768               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.1 MiB      0.0 MiB       59384                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.1 MiB      0.0 MiB       59384                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.1 MiB      0.0 MiB      118768               if temp_g_score < g_score[neighbor]:
    73    134.1 MiB      0.0 MiB       15543                   came_from[neighbor] = current
    74    134.1 MiB      0.0 MiB       15543                   g_score[neighbor] = temp_g_score
    75    134.1 MiB      0.0 MiB       15543                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.1 MiB      0.0 MiB       15543                   if neighbor not in open_set_hash:
    77    134.1 MiB      0.0 MiB       15543                       count += 1
    78    134.1 MiB      0.0 MiB       15543                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.1 MiB      0.0 MiB       15543                       open_set_hash.add(neighbor)
    80                                                             
    81    134.1 MiB      0.0 MiB       14846           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.1 MiB      0.0 MiB       14846           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.1 MiB    134.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.1 MiB      0.0 MiB         257       for row in grid:
    32    134.1 MiB      0.0 MiB       65792           for spot in row:
    33    134.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.1 MiB      0.0 MiB           1       count = 0
    36    134.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.1 MiB      0.0 MiB           1       came_from = {}
    39    134.1 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.1 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.1 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.1 MiB      0.0 MiB       12932       while not open_set.empty():
    49    134.1 MiB      0.0 MiB       12932           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.1 MiB      0.0 MiB       12932           current = open_set.get()[2]
    55    134.1 MiB      0.0 MiB       12932           open_set_hash.remove(current)
    56                                         
    57    134.1 MiB      0.0 MiB       12932           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.1 MiB      0.0 MiB       12932           if current == end:
    62    134.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.1 MiB      0.0 MiB      116379           for neighbor in current.neighbors:
    67    134.1 MiB      0.0 MiB      103448               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.1 MiB      0.0 MiB       51724                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.1 MiB      0.0 MiB       51724                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.1 MiB      0.0 MiB      103448               if temp_g_score < g_score[neighbor]:
    73    134.1 MiB      0.0 MiB       13630                   came_from[neighbor] = current
    74    134.1 MiB      0.0 MiB       13630                   g_score[neighbor] = temp_g_score
    75    134.1 MiB      0.0 MiB       13630                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.1 MiB      0.0 MiB       13630                   if neighbor not in open_set_hash:
    77    134.1 MiB      0.0 MiB       13630                       count += 1
    78    134.1 MiB      0.0 MiB       13630                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.1 MiB      0.0 MiB       13630                       open_set_hash.add(neighbor)
    80                                                             
    81    134.1 MiB      0.0 MiB       12931           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.1 MiB      0.0 MiB       12931           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.1 MiB    134.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.1 MiB      0.0 MiB         257       for row in grid:
    32    134.1 MiB      0.0 MiB       65792           for spot in row:
    33    134.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.1 MiB      0.0 MiB           1       count = 0
    36    134.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.1 MiB      0.0 MiB           1       came_from = {}
    39    134.1 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.1 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.1 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.1 MiB      0.0 MiB        1358       while not open_set.empty():
    49    134.1 MiB      0.0 MiB        1358           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.1 MiB      0.0 MiB        1358           current = open_set.get()[2]
    55    134.1 MiB      0.0 MiB        1358           open_set_hash.remove(current)
    56                                         
    57    134.1 MiB      0.0 MiB        1358           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.1 MiB      0.0 MiB        1358           if current == end:
    62    134.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.1 MiB      0.0 MiB       12213           for neighbor in current.neighbors:
    67    134.1 MiB      0.0 MiB       10856               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.1 MiB      0.0 MiB        5428                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.1 MiB      0.0 MiB        5428                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.1 MiB      0.0 MiB       10856               if temp_g_score < g_score[neighbor]:
    73    134.1 MiB      0.0 MiB        1606                   came_from[neighbor] = current
    74    134.1 MiB      0.0 MiB        1606                   g_score[neighbor] = temp_g_score
    75    134.1 MiB      0.0 MiB        1606                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.1 MiB      0.0 MiB        1606                   if neighbor not in open_set_hash:
    77    134.1 MiB      0.0 MiB        1606                       count += 1
    78    134.1 MiB      0.0 MiB        1606                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.1 MiB      0.0 MiB        1606                       open_set_hash.add(neighbor)
    80                                                             
    81    134.1 MiB      0.0 MiB        1357           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.1 MiB      0.0 MiB        1357           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.1 MiB    134.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.1 MiB      0.0 MiB         257       for row in grid:
    32    134.1 MiB      0.0 MiB       65792           for spot in row:
    33    134.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.1 MiB      0.0 MiB           1       count = 0
    36    134.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.1 MiB      0.0 MiB           1       came_from = {}
    39    135.9 MiB      1.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.4 MiB      0.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.4 MiB      0.0 MiB        1080       while not open_set.empty():
    49    136.4 MiB      0.0 MiB        1080           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.4 MiB      0.0 MiB        1080           current = open_set.get()[2]
    55    136.4 MiB      0.0 MiB        1080           open_set_hash.remove(current)
    56                                         
    57    136.4 MiB      0.0 MiB        1080           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.4 MiB      0.0 MiB        1080           if current == end:
    62    136.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.4 MiB      0.0 MiB        9708           for neighbor in current.neighbors:
    67    136.4 MiB      0.0 MiB        8629               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.4 MiB      0.0 MiB        4314                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.4 MiB      0.0 MiB        4315                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.4 MiB      0.0 MiB        8629               if temp_g_score < g_score[neighbor]:
    73    136.4 MiB      0.0 MiB        1351                   came_from[neighbor] = current
    74    136.4 MiB      0.0 MiB        1351                   g_score[neighbor] = temp_g_score
    75    136.4 MiB      0.0 MiB        1351                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.4 MiB      0.0 MiB        1351                   if neighbor not in open_set_hash:
    77    136.4 MiB      0.0 MiB        1351                       count += 1
    78    136.4 MiB      0.0 MiB        1351                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.4 MiB      0.0 MiB        1351                       open_set_hash.add(neighbor)
    80                                                             
    81    136.4 MiB      0.0 MiB        1079           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.4 MiB      0.0 MiB        1079           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.4 MiB    136.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.4 MiB      0.0 MiB         257       for row in grid:
    32    136.4 MiB      0.0 MiB       65792           for spot in row:
    33    136.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.4 MiB      0.0 MiB           1       count = 0
    36    136.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.4 MiB      0.0 MiB           1       came_from = {}
    39    136.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.4 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.4 MiB      0.0 MiB        4356       while not open_set.empty():
    49    136.4 MiB      0.0 MiB        4356           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.4 MiB      0.0 MiB        4356           current = open_set.get()[2]
    55    136.4 MiB      0.0 MiB        4356           open_set_hash.remove(current)
    56                                         
    57    136.4 MiB      0.0 MiB        4356           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.4 MiB      0.0 MiB        4356           if current == end:
    62    136.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.4 MiB      0.0 MiB       39195           for neighbor in current.neighbors:
    67    136.4 MiB      0.0 MiB       34840               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.4 MiB      0.0 MiB       17420                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.4 MiB      0.0 MiB       17420                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.4 MiB      0.0 MiB       34840               if temp_g_score < g_score[neighbor]:
    73    136.4 MiB      0.0 MiB        4838                   came_from[neighbor] = current
    74    136.4 MiB      0.0 MiB        4838                   g_score[neighbor] = temp_g_score
    75    136.4 MiB      0.0 MiB        4838                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.4 MiB      0.0 MiB        4838                   if neighbor not in open_set_hash:
    77    136.4 MiB      0.0 MiB        4838                       count += 1
    78    136.4 MiB      0.0 MiB        4838                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.4 MiB      0.0 MiB        4838                       open_set_hash.add(neighbor)
    80                                                             
    81    136.4 MiB      0.0 MiB        4355           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.4 MiB      0.0 MiB        4355           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.4 MiB    136.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.4 MiB      0.0 MiB         257       for row in grid:
    32    136.4 MiB      0.0 MiB       65792           for spot in row:
    33    136.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.4 MiB      0.0 MiB           1       count = 0
    36    136.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.4 MiB      0.0 MiB           1       came_from = {}
    39    136.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.4 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.4 MiB      0.0 MiB         621       while not open_set.empty():
    49    136.4 MiB      0.0 MiB         621           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.4 MiB      0.0 MiB         621           current = open_set.get()[2]
    55    136.4 MiB      0.0 MiB         621           open_set_hash.remove(current)
    56                                         
    57    136.4 MiB      0.0 MiB         621           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.4 MiB      0.0 MiB         621           if current == end:
    62    136.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.4 MiB      0.0 MiB        5580           for neighbor in current.neighbors:
    67    136.4 MiB      0.0 MiB        4960               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.4 MiB      0.0 MiB        2480                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.4 MiB      0.0 MiB        2480                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.4 MiB      0.0 MiB        4960               if temp_g_score < g_score[neighbor]:
    73    136.4 MiB      0.0 MiB         765                   came_from[neighbor] = current
    74    136.4 MiB      0.0 MiB         765                   g_score[neighbor] = temp_g_score
    75    136.4 MiB      0.0 MiB         765                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.4 MiB      0.0 MiB         765                   if neighbor not in open_set_hash:
    77    136.4 MiB      0.0 MiB         765                       count += 1
    78    136.4 MiB      0.0 MiB         765                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.4 MiB      0.0 MiB         765                       open_set_hash.add(neighbor)
    80                                                             
    81    136.4 MiB      0.0 MiB         620           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.4 MiB      0.0 MiB         620           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.4 MiB    136.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.4 MiB      0.0 MiB         257       for row in grid:
    32    136.4 MiB      0.0 MiB       65792           for spot in row:
    33    136.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.4 MiB      0.0 MiB           1       count = 0
    36    136.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.4 MiB      0.0 MiB           1       came_from = {}
    39    136.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.4 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.4 MiB      0.0 MiB        3850       while not open_set.empty():
    49    136.4 MiB      0.0 MiB        3850           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.4 MiB      0.0 MiB        3850           current = open_set.get()[2]
    55    136.4 MiB      0.0 MiB        3850           open_set_hash.remove(current)
    56                                         
    57    136.4 MiB      0.0 MiB        3850           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.4 MiB      0.0 MiB        3850           if current == end:
    62    136.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.4 MiB      0.0 MiB       34641           for neighbor in current.neighbors:
    67    136.4 MiB      0.0 MiB       30792               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.4 MiB      0.0 MiB       15396                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.4 MiB      0.0 MiB       15396                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.4 MiB      0.0 MiB       30792               if temp_g_score < g_score[neighbor]:
    73    136.4 MiB      0.0 MiB        4208                   came_from[neighbor] = current
    74    136.4 MiB      0.0 MiB        4208                   g_score[neighbor] = temp_g_score
    75    136.4 MiB      0.0 MiB        4208                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.4 MiB      0.0 MiB        4208                   if neighbor not in open_set_hash:
    77    136.4 MiB      0.0 MiB        4208                       count += 1
    78    136.4 MiB      0.0 MiB        4208                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.4 MiB      0.0 MiB        4208                       open_set_hash.add(neighbor)
    80                                                             
    81    136.4 MiB      0.0 MiB        3849           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.4 MiB      0.0 MiB        3849           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.4 MiB    136.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.4 MiB      0.0 MiB         257       for row in grid:
    32    136.4 MiB      0.0 MiB       65792           for spot in row:
    33    136.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.4 MiB      0.0 MiB           1       count = 0
    36    136.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.4 MiB      0.0 MiB           1       came_from = {}
    39    136.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.4 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.4 MiB      0.0 MiB        1200       while not open_set.empty():
    49    136.4 MiB      0.0 MiB        1200           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.4 MiB      0.0 MiB        1200           current = open_set.get()[2]
    55    136.4 MiB      0.0 MiB        1200           open_set_hash.remove(current)
    56                                         
    57    136.4 MiB      0.0 MiB        1200           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.4 MiB      0.0 MiB        1200           if current == end:
    62    136.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.4 MiB      0.0 MiB       10791           for neighbor in current.neighbors:
    67    136.4 MiB      0.0 MiB        9592               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.4 MiB      0.0 MiB        4796                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.4 MiB      0.0 MiB        4796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.4 MiB      0.0 MiB        9592               if temp_g_score < g_score[neighbor]:
    73    136.4 MiB      0.0 MiB        1394                   came_from[neighbor] = current
    74    136.4 MiB      0.0 MiB        1394                   g_score[neighbor] = temp_g_score
    75    136.4 MiB      0.0 MiB        1394                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.4 MiB      0.0 MiB        1394                   if neighbor not in open_set_hash:
    77    136.4 MiB      0.0 MiB        1394                       count += 1
    78    136.4 MiB      0.0 MiB        1394                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.4 MiB      0.0 MiB        1394                       open_set_hash.add(neighbor)
    80                                                             
    81    136.4 MiB      0.0 MiB        1199           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.4 MiB      0.0 MiB        1199           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.4 MiB    136.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.4 MiB      0.0 MiB         257       for row in grid:
    32    136.4 MiB      0.0 MiB       65792           for spot in row:
    33    136.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.4 MiB      0.0 MiB           1       count = 0
    36    136.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.4 MiB      0.0 MiB           1       came_from = {}
    39    136.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.4 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.4 MiB      0.0 MiB        1071       while not open_set.empty():
    49    136.4 MiB      0.0 MiB        1071           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.4 MiB      0.0 MiB        1071           current = open_set.get()[2]
    55    136.4 MiB      0.0 MiB        1071           open_set_hash.remove(current)
    56                                         
    57    136.4 MiB      0.0 MiB        1071           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.4 MiB      0.0 MiB        1071           if current == end:
    62    136.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.4 MiB      0.0 MiB        9630           for neighbor in current.neighbors:
    67    136.4 MiB      0.0 MiB        8560               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.4 MiB      0.0 MiB        4280                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.4 MiB      0.0 MiB        4280                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.4 MiB      0.0 MiB        8560               if temp_g_score < g_score[neighbor]:
    73    136.4 MiB      0.0 MiB        1263                   came_from[neighbor] = current
    74    136.4 MiB      0.0 MiB        1263                   g_score[neighbor] = temp_g_score
    75    136.4 MiB      0.0 MiB        1263                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.4 MiB      0.0 MiB        1263                   if neighbor not in open_set_hash:
    77    136.4 MiB      0.0 MiB        1263                       count += 1
    78    136.4 MiB      0.0 MiB        1263                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.4 MiB      0.0 MiB        1263                       open_set_hash.add(neighbor)
    80                                                             
    81    136.4 MiB      0.0 MiB        1070           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.4 MiB      0.0 MiB        1070           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.4 MiB    136.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.4 MiB      0.0 MiB         257       for row in grid:
    32    136.4 MiB      0.0 MiB       65792           for spot in row:
    33    136.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.4 MiB      0.0 MiB           1       count = 0
    36    136.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.4 MiB      0.0 MiB           1       came_from = {}
    39    136.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.4 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.4 MiB      0.0 MiB        2074       while not open_set.empty():
    49    136.4 MiB      0.0 MiB        2074           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.4 MiB      0.0 MiB        2074           current = open_set.get()[2]
    55    136.4 MiB      0.0 MiB        2074           open_set_hash.remove(current)
    56                                         
    57    136.4 MiB      0.0 MiB        2074           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.4 MiB      0.0 MiB        2074           if current == end:
    62    136.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.4 MiB      0.0 MiB       18657           for neighbor in current.neighbors:
    67    136.4 MiB      0.0 MiB       16584               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.4 MiB      0.0 MiB        8292                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.4 MiB      0.0 MiB        8292                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.4 MiB      0.0 MiB       16584               if temp_g_score < g_score[neighbor]:
    73    136.4 MiB      0.0 MiB        2330                   came_from[neighbor] = current
    74    136.4 MiB      0.0 MiB        2330                   g_score[neighbor] = temp_g_score
    75    136.4 MiB      0.0 MiB        2330                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.4 MiB      0.0 MiB        2330                   if neighbor not in open_set_hash:
    77    136.4 MiB      0.0 MiB        2330                       count += 1
    78    136.4 MiB      0.0 MiB        2330                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.4 MiB      0.0 MiB        2330                       open_set_hash.add(neighbor)
    80                                                             
    81    136.4 MiB      0.0 MiB        2073           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.4 MiB      0.0 MiB        2073           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.4 MiB    136.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.4 MiB      0.0 MiB         257       for row in grid:
    32    136.4 MiB      0.0 MiB       65792           for spot in row:
    33    136.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.4 MiB      0.0 MiB           1       count = 0
    36    136.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.4 MiB      0.0 MiB           1       came_from = {}
    39    136.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.4 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.4 MiB      0.0 MiB        1656       while not open_set.empty():
    49    136.4 MiB      0.0 MiB        1656           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.4 MiB      0.0 MiB        1656           current = open_set.get()[2]
    55    136.4 MiB      0.0 MiB        1656           open_set_hash.remove(current)
    56                                         
    57    136.4 MiB      0.0 MiB        1656           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.4 MiB      0.0 MiB        1656           if current == end:
    62    136.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.4 MiB      0.0 MiB       14895           for neighbor in current.neighbors:
    67    136.4 MiB      0.0 MiB       13240               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.4 MiB      0.0 MiB        6620                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.4 MiB      0.0 MiB        6620                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.4 MiB      0.0 MiB       13240               if temp_g_score < g_score[neighbor]:
    73    136.4 MiB      0.0 MiB        1978                   came_from[neighbor] = current
    74    136.4 MiB      0.0 MiB        1978                   g_score[neighbor] = temp_g_score
    75    136.4 MiB      0.0 MiB        1978                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.4 MiB      0.0 MiB        1978                   if neighbor not in open_set_hash:
    77    136.4 MiB      0.0 MiB        1978                       count += 1
    78    136.4 MiB      0.0 MiB        1978                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.4 MiB      0.0 MiB        1978                       open_set_hash.add(neighbor)
    80                                                             
    81    136.4 MiB      0.0 MiB        1655           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.4 MiB      0.0 MiB        1655           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.4 MiB    136.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.4 MiB      0.0 MiB         257       for row in grid:
    32    136.4 MiB      0.0 MiB       65792           for spot in row:
    33    136.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.4 MiB      0.0 MiB           1       count = 0
    36    136.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.4 MiB      0.0 MiB           1       came_from = {}
    39    136.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.4 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.4 MiB -19561.1 MiB        4437       while not open_set.empty():
    49    136.4 MiB -19561.3 MiB        4437           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.4 MiB -19561.7 MiB        4437           current = open_set.get()[2]
    55    136.4 MiB -19562.0 MiB        4437           open_set_hash.remove(current)
    56                                         
    57    136.4 MiB -19562.2 MiB        4437           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.4 MiB -19562.4 MiB        4437           if current == end:
    62    127.2 MiB     -9.2 MiB           1               if draw:
    63                                                         end.make_end()
    64    127.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.4 MiB -176006.9 MiB       39924           for neighbor in current.neighbors:
    67    136.4 MiB -156448.1 MiB       35488               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.4 MiB -78231.7 MiB       17744                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.4 MiB -78218.0 MiB       17744                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.4 MiB -156450.9 MiB       35488               if temp_g_score < g_score[neighbor]:
    73    136.4 MiB -21137.0 MiB        4857                   came_from[neighbor] = current
    74    136.4 MiB -21137.0 MiB        4857                   g_score[neighbor] = temp_g_score
    75    136.4 MiB -21137.2 MiB        4857                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.4 MiB -21137.5 MiB        4857                   if neighbor not in open_set_hash:
    77    136.4 MiB -21137.7 MiB        4857                       count += 1
    78    136.4 MiB -21138.0 MiB        4857                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.4 MiB -21138.2 MiB        4857                       open_set_hash.add(neighbor)
    80                                                             
    81    136.4 MiB -19560.7 MiB        4436           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.4 MiB -19560.9 MiB        4436           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    127.2 MiB    127.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    127.2 MiB   -646.8 MiB         257       for row in grid:
    32    127.2 MiB -164640.6 MiB       65792           for spot in row:
    33    127.2 MiB -163998.5 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    120.4 MiB     -6.8 MiB           1       count = 0
    36    120.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    120.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    120.4 MiB      0.0 MiB           1       came_from = {}
    39    120.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    120.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    120.6 MiB      0.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    120.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    120.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    120.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    120.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    120.6 MiB      0.0 MiB         649       while not open_set.empty():
    49    120.6 MiB      0.0 MiB         649           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    120.6 MiB      0.0 MiB         649           current = open_set.get()[2]
    55    120.6 MiB      0.0 MiB         649           open_set_hash.remove(current)
    56                                         
    57    120.6 MiB      0.0 MiB         649           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    120.6 MiB      0.0 MiB         649           if current == end:
    62    120.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    120.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    120.6 MiB      0.0 MiB        5832           for neighbor in current.neighbors:
    67    120.6 MiB      0.0 MiB        5184               if current.row != neighbor.row and current.col != neighbor.col:
    68    120.6 MiB      0.0 MiB        2592                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    120.6 MiB      0.0 MiB        2592                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    120.6 MiB      0.0 MiB        5184               if temp_g_score < g_score[neighbor]:
    73    120.6 MiB      0.0 MiB         905                   came_from[neighbor] = current
    74    120.6 MiB      0.0 MiB         905                   g_score[neighbor] = temp_g_score
    75    120.6 MiB      0.0 MiB         905                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    120.6 MiB      0.0 MiB         905                   if neighbor not in open_set_hash:
    77    120.6 MiB      0.0 MiB         905                       count += 1
    78    120.6 MiB      0.0 MiB         905                       open_set.put((f_score[neighbor], count, neighbor))
    79    120.6 MiB      0.0 MiB         905                       open_set_hash.add(neighbor)
    80                                                             
    81    120.6 MiB      0.0 MiB         648           if draw is not None:
    82                                                     draw()
    83                                         
    84    120.6 MiB      0.0 MiB         648           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    120.6 MiB    120.6 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    120.6 MiB      0.0 MiB         257       for row in grid:
    32    120.6 MiB      0.0 MiB       65792           for spot in row:
    33    120.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    120.6 MiB      0.0 MiB           1       count = 0
    36    120.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    120.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    120.6 MiB      0.0 MiB           1       came_from = {}
    39    121.1 MiB      0.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    121.1 MiB      0.0 MiB           1       g_score[start] = 0
    41    121.1 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    121.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    121.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    121.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    121.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    121.1 MiB      0.0 MiB        3053       while not open_set.empty():
    49    121.1 MiB      0.0 MiB        3053           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    121.1 MiB      0.0 MiB        3053           current = open_set.get()[2]
    55    121.1 MiB      0.0 MiB        3053           open_set_hash.remove(current)
    56                                         
    57    121.1 MiB      0.0 MiB        3053           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    121.1 MiB      0.0 MiB        3053           if current == end:
    62    121.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    121.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    121.1 MiB      0.0 MiB       27468           for neighbor in current.neighbors:
    67    121.1 MiB      0.0 MiB       24416               if current.row != neighbor.row and current.col != neighbor.col:
    68    121.1 MiB      0.0 MiB       12208                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    121.1 MiB      0.0 MiB       12208                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    121.1 MiB      0.0 MiB       24416               if temp_g_score < g_score[neighbor]:
    73    121.1 MiB      0.0 MiB        3421                   came_from[neighbor] = current
    74    121.1 MiB      0.0 MiB        3421                   g_score[neighbor] = temp_g_score
    75    121.1 MiB      0.0 MiB        3421                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    121.1 MiB      0.0 MiB        3421                   if neighbor not in open_set_hash:
    77    121.1 MiB      0.0 MiB        3421                       count += 1
    78    121.1 MiB      0.0 MiB        3421                       open_set.put((f_score[neighbor], count, neighbor))
    79    121.1 MiB      0.0 MiB        3421                       open_set_hash.add(neighbor)
    80                                                             
    81    121.1 MiB      0.0 MiB        3052           if draw is not None:
    82                                                     draw()
    83                                         
    84    121.1 MiB      0.0 MiB        3052           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    121.1 MiB    121.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    121.1 MiB      0.0 MiB         257       for row in grid:
    32    121.1 MiB      0.0 MiB       65792           for spot in row:
    33    121.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    121.1 MiB      0.0 MiB           1       count = 0
    36    121.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    121.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    121.1 MiB      0.0 MiB           1       came_from = {}
    39    121.1 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    121.1 MiB      0.0 MiB           1       g_score[start] = 0
    41    122.6 MiB      1.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    122.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    122.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    122.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    122.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    122.6 MiB      0.0 MiB        2450       while not open_set.empty():
    49    122.6 MiB      0.0 MiB        2450           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    122.6 MiB      0.0 MiB        2450           current = open_set.get()[2]
    55    122.6 MiB      0.0 MiB        2450           open_set_hash.remove(current)
    56                                         
    57    122.6 MiB      0.0 MiB        2450           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    122.6 MiB      0.0 MiB        2450           if current == end:
    62    122.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    122.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    122.6 MiB      0.0 MiB       22041           for neighbor in current.neighbors:
    67    122.6 MiB      0.0 MiB       19592               if current.row != neighbor.row and current.col != neighbor.col:
    68    122.6 MiB      0.0 MiB        9796                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    122.6 MiB      0.0 MiB        9796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    122.6 MiB      0.0 MiB       19592               if temp_g_score < g_score[neighbor]:
    73    122.6 MiB      0.0 MiB        2746                   came_from[neighbor] = current
    74    122.6 MiB      0.0 MiB        2746                   g_score[neighbor] = temp_g_score
    75    122.6 MiB      0.0 MiB        2746                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    122.6 MiB      0.0 MiB        2746                   if neighbor not in open_set_hash:
    77    122.6 MiB      0.0 MiB        2746                       count += 1
    78    122.6 MiB      0.0 MiB        2746                       open_set.put((f_score[neighbor], count, neighbor))
    79    122.6 MiB      0.0 MiB        2746                       open_set_hash.add(neighbor)
    80                                                             
    81    122.6 MiB      0.0 MiB        2449           if draw is not None:
    82                                                     draw()
    83                                         
    84    122.6 MiB      0.0 MiB        2449           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    122.7 MiB    122.7 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    122.7 MiB      0.0 MiB         257       for row in grid:
    32    122.7 MiB      0.0 MiB       65792           for spot in row:
    33    122.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    122.7 MiB      0.0 MiB           1       count = 0
    36    122.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    122.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    122.7 MiB      0.0 MiB           1       came_from = {}
    39    123.5 MiB      0.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    123.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    126.0 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    126.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    126.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    126.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    126.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    126.5 MiB      0.0 MiB       12580       while not open_set.empty():
    49    126.5 MiB      0.0 MiB       12580           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    126.5 MiB      0.0 MiB       12580           current = open_set.get()[2]
    55    126.5 MiB      0.0 MiB       12580           open_set_hash.remove(current)
    56                                         
    57    126.5 MiB      0.0 MiB       12580           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    126.5 MiB      0.0 MiB       12580           if current == end:
    62    126.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    126.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    126.5 MiB      0.0 MiB      113211           for neighbor in current.neighbors:
    67    126.5 MiB      0.0 MiB      100632               if current.row != neighbor.row and current.col != neighbor.col:
    68    126.5 MiB      0.0 MiB       50316                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    126.5 MiB      0.0 MiB       50316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    126.5 MiB      0.0 MiB      100632               if temp_g_score < g_score[neighbor]:
    73    126.5 MiB      0.5 MiB       13214                   came_from[neighbor] = current
    74    126.5 MiB      0.0 MiB       13214                   g_score[neighbor] = temp_g_score
    75    126.5 MiB      0.0 MiB       13214                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    126.5 MiB      0.0 MiB       13214                   if neighbor not in open_set_hash:
    77    126.5 MiB      0.0 MiB       13214                       count += 1
    78    126.5 MiB      0.0 MiB       13214                       open_set.put((f_score[neighbor], count, neighbor))
    79    126.5 MiB      0.0 MiB       13214                       open_set_hash.add(neighbor)
    80                                                             
    81    126.5 MiB      0.0 MiB       12579           if draw is not None:
    82                                                     draw()
    83                                         
    84    126.5 MiB      0.0 MiB       12579           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    126.6 MiB    126.6 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    126.6 MiB      0.0 MiB         257       for row in grid:
    32    126.6 MiB      0.0 MiB       65792           for spot in row:
    33    126.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    126.6 MiB      0.0 MiB           1       count = 0
    36    126.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    126.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    126.6 MiB      0.0 MiB           1       came_from = {}
    39    126.6 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    126.6 MiB      0.0 MiB           1       g_score[start] = 0
    41    129.1 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    129.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    129.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    129.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    129.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    129.1 MiB      0.0 MiB         376       while not open_set.empty():
    49    129.1 MiB      0.0 MiB         376           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    129.1 MiB      0.0 MiB         376           current = open_set.get()[2]
    55    129.1 MiB      0.0 MiB         376           open_set_hash.remove(current)
    56                                         
    57    129.1 MiB      0.0 MiB         376           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    129.1 MiB      0.0 MiB         376           if current == end:
    62    129.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    129.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    129.1 MiB      0.0 MiB        3375           for neighbor in current.neighbors:
    67    129.1 MiB      0.0 MiB        3000               if current.row != neighbor.row and current.col != neighbor.col:
    68    129.1 MiB      0.0 MiB        1500                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    129.1 MiB      0.0 MiB        1500                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    129.1 MiB      0.0 MiB        3000               if temp_g_score < g_score[neighbor]:
    73    129.1 MiB      0.0 MiB         758                   came_from[neighbor] = current
    74    129.1 MiB      0.0 MiB         758                   g_score[neighbor] = temp_g_score
    75    129.1 MiB      0.0 MiB         758                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    129.1 MiB      0.0 MiB         758                   if neighbor not in open_set_hash:
    77    129.1 MiB      0.0 MiB         758                       count += 1
    78    129.1 MiB      0.0 MiB         758                       open_set.put((f_score[neighbor], count, neighbor))
    79    129.1 MiB      0.0 MiB         758                       open_set_hash.add(neighbor)
    80                                                             
    81    129.1 MiB      0.0 MiB         375           if draw is not None:
    82                                                     draw()
    83                                         
    84    129.1 MiB      0.0 MiB         375           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    129.1 MiB    129.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    129.1 MiB      0.0 MiB         257       for row in grid:
    32    129.1 MiB      0.0 MiB       65792           for spot in row:
    33    129.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    129.1 MiB      0.0 MiB           1       count = 0
    36    129.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    129.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    129.1 MiB      0.0 MiB           1       came_from = {}
    39    130.2 MiB      1.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    130.2 MiB      0.0 MiB           1       g_score[start] = 0
    41    130.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    130.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    130.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    130.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46    130.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    130.2 MiB      0.0 MiB         304       while not open_set.empty():
    49    130.2 MiB      0.0 MiB         304           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    130.2 MiB      0.0 MiB         304           current = open_set.get()[2]
    55    130.2 MiB      0.0 MiB         304           open_set_hash.remove(current)
    56                                         
    57    130.2 MiB      0.0 MiB         304           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    130.2 MiB      0.0 MiB         304           if current == end:
    62    130.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    130.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    130.2 MiB      0.0 MiB        2727           for neighbor in current.neighbors:
    67    130.2 MiB      0.0 MiB        2424               if current.row != neighbor.row and current.col != neighbor.col:
    68    130.2 MiB      0.0 MiB        1212                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    130.2 MiB      0.0 MiB        1212                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    130.2 MiB      0.0 MiB        2424               if temp_g_score < g_score[neighbor]:
    73    130.2 MiB      0.0 MiB         410                   came_from[neighbor] = current
    74    130.2 MiB      0.0 MiB         410                   g_score[neighbor] = temp_g_score
    75    130.2 MiB      0.0 MiB         410                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    130.2 MiB      0.0 MiB         410                   if neighbor not in open_set_hash:
    77    130.2 MiB      0.0 MiB         410                       count += 1
    78    130.2 MiB      0.0 MiB         410                       open_set.put((f_score[neighbor], count, neighbor))
    79    130.2 MiB      0.0 MiB         410                       open_set_hash.add(neighbor)
    80                                                             
    81    130.2 MiB      0.0 MiB         303           if draw is not None:
    82                                                     draw()
    83                                         
    84    130.2 MiB      0.0 MiB         303           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    130.2 MiB    130.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    130.2 MiB      0.0 MiB         257       for row in grid:
    32    130.2 MiB      0.0 MiB       65792           for spot in row:
    33    130.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    130.2 MiB      0.0 MiB           1       count = 0
    36    130.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    130.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    130.2 MiB      0.0 MiB           1       came_from = {}
    39    131.3 MiB      1.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    131.3 MiB      0.0 MiB           1       g_score[start] = 0
    41    131.3 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    131.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    131.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    131.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46    131.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    131.3 MiB      0.0 MiB         576       while not open_set.empty():
    49    131.3 MiB      0.0 MiB         576           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    131.3 MiB      0.0 MiB         576           current = open_set.get()[2]
    55    131.3 MiB      0.0 MiB         576           open_set_hash.remove(current)
    56                                         
    57    131.3 MiB      0.0 MiB         576           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    131.3 MiB      0.0 MiB         576           if current == end:
    62    131.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    131.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    131.3 MiB      0.0 MiB        5175           for neighbor in current.neighbors:
    67    131.3 MiB      0.0 MiB        4600               if current.row != neighbor.row and current.col != neighbor.col:
    68    131.3 MiB      0.0 MiB        2300                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    131.3 MiB      0.0 MiB        2300                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    131.3 MiB      0.0 MiB        4600               if temp_g_score < g_score[neighbor]:
    73    131.3 MiB      0.0 MiB        1158                   came_from[neighbor] = current
    74    131.3 MiB      0.0 MiB        1158                   g_score[neighbor] = temp_g_score
    75    131.3 MiB      0.0 MiB        1158                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    131.3 MiB      0.0 MiB        1158                   if neighbor not in open_set_hash:
    77    131.3 MiB      0.0 MiB        1158                       count += 1
    78    131.3 MiB      0.0 MiB        1158                       open_set.put((f_score[neighbor], count, neighbor))
    79    131.3 MiB      0.0 MiB        1158                       open_set_hash.add(neighbor)
    80                                                             
    81    131.3 MiB      0.0 MiB         575           if draw is not None:
    82                                                     draw()
    83                                         
    84    131.3 MiB      0.0 MiB         575           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    131.3 MiB    131.3 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    131.3 MiB      0.0 MiB         257       for row in grid:
    32    131.3 MiB      0.0 MiB       65792           for spot in row:
    33    131.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    131.3 MiB      0.0 MiB           1       count = 0
    36    131.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    131.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    131.3 MiB      0.0 MiB           1       came_from = {}
    39    133.8 MiB      2.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    133.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    133.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    133.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    133.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    133.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    133.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    133.8 MiB      0.0 MiB         147       while not open_set.empty():
    49    133.8 MiB      0.0 MiB         147           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    133.8 MiB      0.0 MiB         147           current = open_set.get()[2]
    55    133.8 MiB      0.0 MiB         147           open_set_hash.remove(current)
    56                                         
    57    133.8 MiB      0.0 MiB         147           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    133.8 MiB      0.0 MiB         147           if current == end:
    62    133.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    133.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    133.8 MiB      0.0 MiB        1314           for neighbor in current.neighbors:
    67    133.8 MiB      0.0 MiB        1168               if current.row != neighbor.row and current.col != neighbor.col:
    68    133.8 MiB      0.0 MiB         584                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    133.8 MiB      0.0 MiB         584                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    133.8 MiB      0.0 MiB        1168               if temp_g_score < g_score[neighbor]:
    73    133.8 MiB      0.0 MiB         243                   came_from[neighbor] = current
    74    133.8 MiB      0.0 MiB         243                   g_score[neighbor] = temp_g_score
    75    133.8 MiB      0.0 MiB         243                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    133.8 MiB      0.0 MiB         243                   if neighbor not in open_set_hash:
    77    133.8 MiB      0.0 MiB         243                       count += 1
    78    133.8 MiB      0.0 MiB         243                       open_set.put((f_score[neighbor], count, neighbor))
    79    133.8 MiB      0.0 MiB         243                       open_set_hash.add(neighbor)
    80                                                             
    81    133.8 MiB      0.0 MiB         146           if draw is not None:
    82                                                     draw()
    83                                         
    84    133.8 MiB      0.0 MiB         146           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    133.8 MiB    133.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    133.8 MiB      0.0 MiB         257       for row in grid:
    32    133.8 MiB      0.0 MiB       65792           for spot in row:
    33    133.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    133.8 MiB      0.0 MiB           1       count = 0
    36    133.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    133.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    133.8 MiB      0.0 MiB           1       came_from = {}
    39    133.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    133.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    133.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    133.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    133.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    133.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    133.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    133.8 MiB      0.0 MiB          66       while not open_set.empty():
    49    133.8 MiB      0.0 MiB          66           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    133.8 MiB      0.0 MiB          66           current = open_set.get()[2]
    55    133.8 MiB      0.0 MiB          66           open_set_hash.remove(current)
    56                                         
    57    133.8 MiB      0.0 MiB          66           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    133.8 MiB      0.0 MiB          66           if current == end:
    62    133.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    133.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    133.8 MiB      0.0 MiB         585           for neighbor in current.neighbors:
    67    133.8 MiB      0.0 MiB         520               if current.row != neighbor.row and current.col != neighbor.col:
    68    133.8 MiB      0.0 MiB         260                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    133.8 MiB      0.0 MiB         260                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    133.8 MiB      0.0 MiB         520               if temp_g_score < g_score[neighbor]:
    73    133.8 MiB      0.0 MiB         120                   came_from[neighbor] = current
    74    133.8 MiB      0.0 MiB         120                   g_score[neighbor] = temp_g_score
    75    133.8 MiB      0.0 MiB         120                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    133.8 MiB      0.0 MiB         120                   if neighbor not in open_set_hash:
    77    133.8 MiB      0.0 MiB         120                       count += 1
    78    133.8 MiB      0.0 MiB         120                       open_set.put((f_score[neighbor], count, neighbor))
    79    133.8 MiB      0.0 MiB         120                       open_set_hash.add(neighbor)
    80                                                             
    81    133.8 MiB      0.0 MiB          65           if draw is not None:
    82                                                     draw()
    83                                         
    84    133.8 MiB      0.0 MiB          65           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    133.8 MiB    133.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    133.8 MiB      0.0 MiB         257       for row in grid:
    32    133.8 MiB      0.0 MiB       65792           for spot in row:
    33    133.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    133.8 MiB      0.0 MiB           1       count = 0
    36    133.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    133.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    133.8 MiB      0.0 MiB           1       came_from = {}
    39    133.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    133.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    133.8 MiB      0.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    133.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    133.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    133.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    133.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    133.8 MiB      0.0 MiB        5046       while not open_set.empty():
    49    133.8 MiB      0.0 MiB        5046           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    133.8 MiB      0.0 MiB        5046           current = open_set.get()[2]
    55    133.8 MiB      0.0 MiB        5046           open_set_hash.remove(current)
    56                                         
    57    133.8 MiB      0.0 MiB        5046           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    133.8 MiB      0.0 MiB        5046           if current == end:
    62    133.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    133.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    133.8 MiB      0.0 MiB       45405           for neighbor in current.neighbors:
    67    133.8 MiB      0.0 MiB       40360               if current.row != neighbor.row and current.col != neighbor.col:
    68    133.8 MiB      0.0 MiB       20180                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    133.8 MiB      0.0 MiB       20180                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    133.8 MiB      0.0 MiB       40360               if temp_g_score < g_score[neighbor]:
    73    133.8 MiB      0.0 MiB        5798                   came_from[neighbor] = current
    74    133.8 MiB      0.0 MiB        5798                   g_score[neighbor] = temp_g_score
    75    133.8 MiB      0.0 MiB        5798                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    133.8 MiB      0.0 MiB        5798                   if neighbor not in open_set_hash:
    77    133.8 MiB      0.0 MiB        5798                       count += 1
    78    133.8 MiB      0.0 MiB        5798                       open_set.put((f_score[neighbor], count, neighbor))
    79    133.8 MiB      0.0 MiB        5798                       open_set_hash.add(neighbor)
    80                                                             
    81    133.8 MiB      0.0 MiB        5045           if draw is not None:
    82                                                     draw()
    83                                         
    84    133.8 MiB      0.0 MiB        5045           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    133.8 MiB    133.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    133.8 MiB      0.0 MiB         257       for row in grid:
    32    133.8 MiB      0.0 MiB       65792           for spot in row:
    33    133.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    133.8 MiB      0.0 MiB           1       count = 0
    36    133.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    133.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    133.8 MiB      0.0 MiB           1       came_from = {}
    39    133.9 MiB      0.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    133.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.3 MiB      0.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.3 MiB      0.0 MiB        5820       while not open_set.empty():
    49    134.3 MiB      0.0 MiB        5820           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.3 MiB      0.0 MiB        5820           current = open_set.get()[2]
    55    134.3 MiB      0.0 MiB        5820           open_set_hash.remove(current)
    56                                         
    57    134.3 MiB      0.0 MiB        5820           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.3 MiB      0.0 MiB        5820           if current == end:
    62    134.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.3 MiB      0.0 MiB       52371           for neighbor in current.neighbors:
    67    134.3 MiB      0.0 MiB       46552               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.3 MiB      0.0 MiB       23276                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.3 MiB      0.0 MiB       23276                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.3 MiB      0.0 MiB       46552               if temp_g_score < g_score[neighbor]:
    73    134.3 MiB      0.0 MiB        6326                   came_from[neighbor] = current
    74    134.3 MiB      0.0 MiB        6326                   g_score[neighbor] = temp_g_score
    75    134.3 MiB      0.0 MiB        6326                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.3 MiB      0.0 MiB        6326                   if neighbor not in open_set_hash:
    77    134.3 MiB      0.0 MiB        6326                       count += 1
    78    134.3 MiB      0.0 MiB        6326                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.3 MiB      0.0 MiB        6326                       open_set_hash.add(neighbor)
    80                                                             
    81    134.3 MiB      0.0 MiB        5819           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.3 MiB      0.0 MiB        5819           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.3 MiB    134.3 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.3 MiB      0.0 MiB         257       for row in grid:
    32    134.3 MiB      0.0 MiB       65792           for spot in row:
    33    134.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.3 MiB      0.0 MiB           1       count = 0
    36    134.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.3 MiB      0.0 MiB           1       came_from = {}
    39    134.3 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.3 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.4 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.4 MiB      0.0 MiB        1938       while not open_set.empty():
    49    134.4 MiB      0.0 MiB        1938           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.4 MiB      0.0 MiB        1938           current = open_set.get()[2]
    55    134.4 MiB      0.0 MiB        1938           open_set_hash.remove(current)
    56                                         
    57    134.4 MiB      0.0 MiB        1938           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.4 MiB      0.0 MiB        1938           if current == end:
    62    134.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.4 MiB      0.0 MiB       17433           for neighbor in current.neighbors:
    67    134.4 MiB      0.0 MiB       15496               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.4 MiB      0.0 MiB        7748                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.4 MiB      0.0 MiB        7748                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.4 MiB      0.0 MiB       15496               if temp_g_score < g_score[neighbor]:
    73    134.4 MiB      0.0 MiB        2190                   came_from[neighbor] = current
    74    134.4 MiB      0.0 MiB        2190                   g_score[neighbor] = temp_g_score
    75    134.4 MiB      0.0 MiB        2190                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.4 MiB      0.0 MiB        2190                   if neighbor not in open_set_hash:
    77    134.4 MiB      0.0 MiB        2190                       count += 1
    78    134.4 MiB      0.0 MiB        2190                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.4 MiB      0.0 MiB        2190                       open_set_hash.add(neighbor)
    80                                                             
    81    134.4 MiB      0.0 MiB        1937           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.4 MiB      0.0 MiB        1937           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.4 MiB    134.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.4 MiB    -69.5 MiB         257       for row in grid:
    32    134.4 MiB -17778.7 MiB       65792           for spot in row:
    33    134.4 MiB -17709.5 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.0 MiB     -0.4 MiB           1       count = 0
    36    134.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.0 MiB      0.0 MiB           1       came_from = {}
    39    134.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.0 MiB      0.0 MiB        6664       while not open_set.empty():
    49    134.0 MiB      0.0 MiB        6664           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.0 MiB      0.0 MiB        6664           current = open_set.get()[2]
    55    134.0 MiB      0.0 MiB        6664           open_set_hash.remove(current)
    56                                         
    57    134.0 MiB      0.0 MiB        6664           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.0 MiB      0.0 MiB        6664           if current == end:
    62    134.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.0 MiB      0.0 MiB       59967           for neighbor in current.neighbors:
    67    134.0 MiB      0.0 MiB       53304               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.0 MiB      0.0 MiB       26652                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.0 MiB      0.0 MiB       26652                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.0 MiB      0.0 MiB       53304               if temp_g_score < g_score[neighbor]:
    73    134.0 MiB      0.0 MiB        7130                   came_from[neighbor] = current
    74    134.0 MiB      0.0 MiB        7130                   g_score[neighbor] = temp_g_score
    75    134.0 MiB      0.0 MiB        7130                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.0 MiB      0.0 MiB        7130                   if neighbor not in open_set_hash:
    77    134.0 MiB      0.0 MiB        7130                       count += 1
    78    134.0 MiB      0.0 MiB        7130                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.0 MiB      0.0 MiB        7130                       open_set_hash.add(neighbor)
    80                                                             
    81    134.0 MiB      0.0 MiB        6663           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.0 MiB      0.0 MiB        6663           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.0 MiB    134.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.0 MiB      0.0 MiB         257       for row in grid:
    32    134.0 MiB      0.0 MiB       65792           for spot in row:
    33    134.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.0 MiB      0.0 MiB           1       count = 0
    36    134.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.0 MiB      0.0 MiB           1       came_from = {}
    39    134.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.0 MiB      0.0 MiB        1560       while not open_set.empty():
    49    134.0 MiB      0.0 MiB        1560           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.0 MiB      0.0 MiB        1560           current = open_set.get()[2]
    55    134.0 MiB      0.0 MiB        1560           open_set_hash.remove(current)
    56                                         
    57    134.0 MiB      0.0 MiB        1560           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.0 MiB      0.0 MiB        1560           if current == end:
    62    134.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.0 MiB      0.0 MiB       14031           for neighbor in current.neighbors:
    67    134.0 MiB      0.0 MiB       12472               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.0 MiB      0.0 MiB        6236                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.0 MiB      0.0 MiB        6236                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.0 MiB      0.0 MiB       12472               if temp_g_score < g_score[neighbor]:
    73    134.0 MiB      0.0 MiB        1782                   came_from[neighbor] = current
    74    134.0 MiB      0.0 MiB        1782                   g_score[neighbor] = temp_g_score
    75    134.0 MiB      0.0 MiB        1782                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.0 MiB      0.0 MiB        1782                   if neighbor not in open_set_hash:
    77    134.0 MiB      0.0 MiB        1782                       count += 1
    78    134.0 MiB      0.0 MiB        1782                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.0 MiB      0.0 MiB        1782                       open_set_hash.add(neighbor)
    80                                                             
    81    134.0 MiB      0.0 MiB        1559           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.0 MiB      0.0 MiB        1559           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.0 MiB    134.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.0 MiB      0.0 MiB         257       for row in grid:
    32    134.0 MiB      0.0 MiB       65792           for spot in row:
    33    134.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.0 MiB      0.0 MiB           1       count = 0
    36    134.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.0 MiB      0.0 MiB           1       came_from = {}
    39    134.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.0 MiB      0.0 MiB         684       while not open_set.empty():
    49    134.0 MiB      0.0 MiB         684           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.0 MiB      0.0 MiB         684           current = open_set.get()[2]
    55    134.0 MiB      0.0 MiB         684           open_set_hash.remove(current)
    56                                         
    57    134.0 MiB      0.0 MiB         684           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.0 MiB      0.0 MiB         684           if current == end:
    62    134.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.0 MiB      0.0 MiB        6147           for neighbor in current.neighbors:
    67    134.0 MiB      0.0 MiB        5464               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.0 MiB      0.0 MiB        2732                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.0 MiB      0.0 MiB        2732                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.0 MiB      0.0 MiB        5464               if temp_g_score < g_score[neighbor]:
    73    134.0 MiB      0.0 MiB         830                   came_from[neighbor] = current
    74    134.0 MiB      0.0 MiB         830                   g_score[neighbor] = temp_g_score
    75    134.0 MiB      0.0 MiB         830                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.0 MiB      0.0 MiB         830                   if neighbor not in open_set_hash:
    77    134.0 MiB      0.0 MiB         830                       count += 1
    78    134.0 MiB      0.0 MiB         830                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.0 MiB      0.0 MiB         830                       open_set_hash.add(neighbor)
    80                                                             
    81    134.0 MiB      0.0 MiB         683           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.0 MiB      0.0 MiB         683           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.0 MiB    134.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.0 MiB      0.0 MiB         257       for row in grid:
    32    134.0 MiB      0.0 MiB       65792           for spot in row:
    33    134.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.0 MiB      0.0 MiB           1       count = 0
    36    134.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.0 MiB      0.0 MiB           1       came_from = {}
    39    134.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.1 MiB      0.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.1 MiB      0.0 MiB        2821       while not open_set.empty():
    49    134.1 MiB      0.0 MiB        2821           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.1 MiB      0.0 MiB        2821           current = open_set.get()[2]
    55    134.1 MiB      0.0 MiB        2821           open_set_hash.remove(current)
    56                                         
    57    134.1 MiB      0.0 MiB        2821           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.1 MiB      0.0 MiB        2821           if current == end:
    62    134.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.1 MiB      0.0 MiB       25380           for neighbor in current.neighbors:
    67    134.1 MiB      0.0 MiB       22560               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.1 MiB      0.0 MiB       11280                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.1 MiB      0.0 MiB       11280                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.1 MiB      0.0 MiB       22560               if temp_g_score < g_score[neighbor]:
    73    134.1 MiB      0.0 MiB        3125                   came_from[neighbor] = current
    74    134.1 MiB      0.0 MiB        3125                   g_score[neighbor] = temp_g_score
    75    134.1 MiB      0.0 MiB        3125                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.1 MiB      0.0 MiB        3125                   if neighbor not in open_set_hash:
    77    134.1 MiB      0.0 MiB        3125                       count += 1
    78    134.1 MiB      0.0 MiB        3125                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.1 MiB      0.0 MiB        3125                       open_set_hash.add(neighbor)
    80                                                             
    81    134.1 MiB      0.0 MiB        2820           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.1 MiB      0.0 MiB        2820           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.1 MiB    134.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.1 MiB      0.0 MiB         257       for row in grid:
    32    134.1 MiB      0.0 MiB       65792           for spot in row:
    33    134.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.1 MiB      0.0 MiB           1       count = 0
    36    134.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.1 MiB      0.0 MiB           1       came_from = {}
    39    134.1 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.1 MiB      0.0 MiB           1       g_score[start] = 0
    41    134.1 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    134.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    134.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    134.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    134.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    134.1 MiB      0.0 MiB          36       while not open_set.empty():
    49    134.1 MiB      0.0 MiB          36           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    134.1 MiB      0.0 MiB          36           current = open_set.get()[2]
    55    134.1 MiB      0.0 MiB          36           open_set_hash.remove(current)
    56                                         
    57    134.1 MiB      0.0 MiB          36           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    134.1 MiB      0.0 MiB          36           if current == end:
    62    134.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    134.1 MiB      0.0 MiB         315           for neighbor in current.neighbors:
    67    134.1 MiB      0.0 MiB         280               if current.row != neighbor.row and current.col != neighbor.col:
    68    134.1 MiB      0.0 MiB         140                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    134.1 MiB      0.0 MiB         140                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    134.1 MiB      0.0 MiB         280               if temp_g_score < g_score[neighbor]:
    73    134.1 MiB      0.0 MiB          88                   came_from[neighbor] = current
    74    134.1 MiB      0.0 MiB          88                   g_score[neighbor] = temp_g_score
    75    134.1 MiB      0.0 MiB          88                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    134.1 MiB      0.0 MiB          88                   if neighbor not in open_set_hash:
    77    134.1 MiB      0.0 MiB          88                       count += 1
    78    134.1 MiB      0.0 MiB          88                       open_set.put((f_score[neighbor], count, neighbor))
    79    134.1 MiB      0.0 MiB          88                       open_set_hash.add(neighbor)
    80                                                             
    81    134.1 MiB      0.0 MiB          35           if draw is not None:
    82                                                     draw()
    83                                         
    84    134.1 MiB      0.0 MiB          35           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    134.1 MiB    134.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    134.1 MiB      0.0 MiB         257       for row in grid:
    32    134.1 MiB      0.0 MiB       65792           for spot in row:
    33    134.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    134.1 MiB      0.0 MiB           1       count = 0
    36    134.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    134.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    134.1 MiB      0.0 MiB           1       came_from = {}
    39    134.1 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.1 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.6 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.8 MiB  -3963.1 MiB        6096       while not open_set.empty():
    49    136.8 MiB  -3963.1 MiB        6096           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.8 MiB  -3963.1 MiB        6096           current = open_set.get()[2]
    55    136.8 MiB  -3963.1 MiB        6096           open_set_hash.remove(current)
    56                                         
    57    136.8 MiB  -3963.1 MiB        6096           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.8 MiB  -3963.1 MiB        6096           if current == end:
    62    135.2 MiB     -1.5 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.8 MiB -35657.8 MiB       54855           for neighbor in current.neighbors:
    67    136.8 MiB -31695.0 MiB       48760               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.8 MiB -15849.0 MiB       24380                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.8 MiB -15846.2 MiB       24380                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.8 MiB -31695.4 MiB       48760               if temp_g_score < g_score[neighbor]:
    73    136.8 MiB  -4194.4 MiB        6540                   came_from[neighbor] = current
    74    136.8 MiB  -4194.7 MiB        6540                   g_score[neighbor] = temp_g_score
    75    136.8 MiB  -4194.8 MiB        6540                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.8 MiB  -4194.9 MiB        6540                   if neighbor not in open_set_hash:
    77    136.8 MiB  -4195.0 MiB        6540                       count += 1
    78    136.8 MiB  -4195.1 MiB        6540                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.8 MiB  -4195.1 MiB        6540                       open_set_hash.add(neighbor)
    80                                                             
    81    136.8 MiB  -3963.1 MiB        6095           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.8 MiB  -3963.1 MiB        6095           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.2 MiB    135.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.2 MiB      0.0 MiB         257       for row in grid:
    32    135.2 MiB      0.0 MiB       65792           for spot in row:
    33    135.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.2 MiB      0.0 MiB           1       count = 0
    36    135.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.2 MiB      0.0 MiB           1       came_from = {}
    39    135.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.2 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.2 MiB      0.0 MiB         996       while not open_set.empty():
    49    135.2 MiB      0.0 MiB         996           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.2 MiB      0.0 MiB         996           current = open_set.get()[2]
    55    135.2 MiB      0.0 MiB         996           open_set_hash.remove(current)
    56                                         
    57    135.2 MiB      0.0 MiB         996           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.2 MiB      0.0 MiB         996           if current == end:
    62    135.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.2 MiB      0.0 MiB        8955           for neighbor in current.neighbors:
    67    135.2 MiB      0.0 MiB        7960               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.2 MiB      0.0 MiB        3980                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.2 MiB      0.0 MiB        3980                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.2 MiB      0.0 MiB        7960               if temp_g_score < g_score[neighbor]:
    73    135.2 MiB      0.0 MiB        1208                   came_from[neighbor] = current
    74    135.2 MiB      0.0 MiB        1208                   g_score[neighbor] = temp_g_score
    75    135.2 MiB      0.0 MiB        1208                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.2 MiB      0.0 MiB        1208                   if neighbor not in open_set_hash:
    77    135.2 MiB      0.0 MiB        1208                       count += 1
    78    135.2 MiB      0.0 MiB        1208                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.2 MiB      0.0 MiB        1208                       open_set_hash.add(neighbor)
    80                                                             
    81    135.2 MiB      0.0 MiB         995           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.2 MiB      0.0 MiB         995           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.2 MiB    135.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.2 MiB      0.0 MiB         257       for row in grid:
    32    135.2 MiB      0.0 MiB       65792           for spot in row:
    33    135.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.2 MiB      0.0 MiB           1       count = 0
    36    135.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.2 MiB      0.0 MiB           1       came_from = {}
    39    135.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.2 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.2 MiB      0.0 MiB        1260       while not open_set.empty():
    49    135.2 MiB      0.0 MiB        1260           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.2 MiB      0.0 MiB        1260           current = open_set.get()[2]
    55    135.2 MiB      0.0 MiB        1260           open_set_hash.remove(current)
    56                                         
    57    135.2 MiB      0.0 MiB        1260           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.2 MiB      0.0 MiB        1260           if current == end:
    62    135.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.2 MiB      0.0 MiB       11331           for neighbor in current.neighbors:
    67    135.2 MiB      0.0 MiB       10072               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.2 MiB      0.0 MiB        5036                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.2 MiB      0.0 MiB        5036                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.2 MiB      0.0 MiB       10072               if temp_g_score < g_score[neighbor]:
    73    135.2 MiB      0.0 MiB        1646                   came_from[neighbor] = current
    74    135.2 MiB      0.0 MiB        1646                   g_score[neighbor] = temp_g_score
    75    135.2 MiB      0.0 MiB        1646                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.2 MiB      0.0 MiB        1646                   if neighbor not in open_set_hash:
    77    135.2 MiB      0.0 MiB        1646                       count += 1
    78    135.2 MiB      0.0 MiB        1646                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.2 MiB      0.0 MiB        1646                       open_set_hash.add(neighbor)
    80                                                             
    81    135.2 MiB      0.0 MiB        1259           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.2 MiB      0.0 MiB        1259           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.2 MiB    135.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.2 MiB      0.0 MiB         257       for row in grid:
    32    135.2 MiB      0.0 MiB       65792           for spot in row:
    33    135.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.2 MiB      0.0 MiB           1       count = 0
    36    135.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.2 MiB      0.0 MiB           1       came_from = {}
    39    135.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.2 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.2 MiB      0.0 MiB        4824       while not open_set.empty():
    49    135.2 MiB      0.0 MiB        4824           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.2 MiB      0.0 MiB        4824           current = open_set.get()[2]
    55    135.2 MiB      0.0 MiB        4824           open_set_hash.remove(current)
    56                                         
    57    135.2 MiB      0.0 MiB        4824           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.2 MiB      0.0 MiB        4824           if current == end:
    62    135.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.2 MiB      0.0 MiB       43407           for neighbor in current.neighbors:
    67    135.2 MiB      0.0 MiB       38584               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.2 MiB      0.0 MiB       19292                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.2 MiB      0.0 MiB       19292                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.2 MiB      0.0 MiB       38584               if temp_g_score < g_score[neighbor]:
    73    135.2 MiB      0.0 MiB        5244                   came_from[neighbor] = current
    74    135.2 MiB      0.0 MiB        5244                   g_score[neighbor] = temp_g_score
    75    135.2 MiB      0.0 MiB        5244                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.2 MiB      0.0 MiB        5244                   if neighbor not in open_set_hash:
    77    135.2 MiB      0.0 MiB        5244                       count += 1
    78    135.2 MiB      0.0 MiB        5244                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.2 MiB      0.0 MiB        5244                       open_set_hash.add(neighbor)
    80                                                             
    81    135.2 MiB      0.0 MiB        4823           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.2 MiB      0.0 MiB        4823           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.2 MiB    135.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.2 MiB      0.0 MiB         257       for row in grid:
    32    135.2 MiB      0.0 MiB       65792           for spot in row:
    33    135.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.2 MiB      0.0 MiB           1       count = 0
    36    135.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.2 MiB      0.0 MiB           1       came_from = {}
    39    135.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.2 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.2 MiB      0.0 MiB        4464       while not open_set.empty():
    49    135.2 MiB      0.0 MiB        4464           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.2 MiB      0.0 MiB        4464           current = open_set.get()[2]
    55    135.2 MiB      0.0 MiB        4464           open_set_hash.remove(current)
    56                                         
    57    135.2 MiB      0.0 MiB        4464           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.2 MiB      0.0 MiB        4464           if current == end:
    62    135.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.2 MiB      0.0 MiB       40167           for neighbor in current.neighbors:
    67    135.2 MiB      0.0 MiB       35704               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.2 MiB      0.0 MiB       17852                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.2 MiB      0.0 MiB       17852                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.2 MiB      0.0 MiB       35704               if temp_g_score < g_score[neighbor]:
    73    135.2 MiB      0.0 MiB        4930                   came_from[neighbor] = current
    74    135.2 MiB      0.0 MiB        4930                   g_score[neighbor] = temp_g_score
    75    135.2 MiB      0.0 MiB        4930                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.2 MiB      0.0 MiB        4930                   if neighbor not in open_set_hash:
    77    135.2 MiB      0.0 MiB        4930                       count += 1
    78    135.2 MiB      0.0 MiB        4930                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.2 MiB      0.0 MiB        4930                       open_set_hash.add(neighbor)
    80                                                             
    81    135.2 MiB      0.0 MiB        4463           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.2 MiB      0.0 MiB        4463           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.2 MiB    135.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.2 MiB      0.0 MiB         257       for row in grid:
    32    135.2 MiB      0.0 MiB       65792           for spot in row:
    33    135.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.2 MiB      0.0 MiB           1       count = 0
    36    135.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.2 MiB      0.0 MiB           1       came_from = {}
    39    135.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.2 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.2 MiB      0.0 MiB        2375       while not open_set.empty():
    49    135.2 MiB      0.0 MiB        2375           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.2 MiB      0.0 MiB        2375           current = open_set.get()[2]
    55    135.2 MiB      0.0 MiB        2375           open_set_hash.remove(current)
    56                                         
    57    135.2 MiB      0.0 MiB        2375           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.2 MiB      0.0 MiB        2375           if current == end:
    62    135.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.2 MiB      0.0 MiB       21366           for neighbor in current.neighbors:
    67    135.2 MiB      0.0 MiB       18992               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.2 MiB      0.0 MiB        9496                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.2 MiB      0.0 MiB        9496                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.2 MiB      0.0 MiB       18992               if temp_g_score < g_score[neighbor]:
    73    135.2 MiB      0.0 MiB        2663                   came_from[neighbor] = current
    74    135.2 MiB      0.0 MiB        2663                   g_score[neighbor] = temp_g_score
    75    135.2 MiB      0.0 MiB        2663                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.2 MiB      0.0 MiB        2663                   if neighbor not in open_set_hash:
    77    135.2 MiB      0.0 MiB        2663                       count += 1
    78    135.2 MiB      0.0 MiB        2663                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.2 MiB      0.0 MiB        2663                       open_set_hash.add(neighbor)
    80                                                             
    81    135.2 MiB      0.0 MiB        2374           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.2 MiB      0.0 MiB        2374           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.2 MiB    135.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.2 MiB      0.0 MiB         257       for row in grid:
    32    135.2 MiB      0.0 MiB       65792           for spot in row:
    33    135.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.2 MiB      0.0 MiB           1       count = 0
    36    135.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.2 MiB      0.0 MiB           1       came_from = {}
    39    135.3 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.3 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.5 MiB      0.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.5 MiB      0.0 MiB         465       while not open_set.empty():
    49    135.5 MiB      0.0 MiB         465           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.5 MiB      0.0 MiB         465           current = open_set.get()[2]
    55    135.5 MiB      0.0 MiB         465           open_set_hash.remove(current)
    56                                         
    57    135.5 MiB      0.0 MiB         465           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.5 MiB      0.0 MiB         465           if current == end:
    62    135.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.5 MiB      0.0 MiB        4176           for neighbor in current.neighbors:
    67    135.5 MiB      0.0 MiB        3712               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.5 MiB      0.0 MiB        1856                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.5 MiB      0.0 MiB        1856                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.5 MiB      0.0 MiB        3712               if temp_g_score < g_score[neighbor]:
    73    135.5 MiB      0.0 MiB         785                   came_from[neighbor] = current
    74    135.5 MiB      0.0 MiB         785                   g_score[neighbor] = temp_g_score
    75    135.5 MiB      0.0 MiB         785                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.5 MiB      0.0 MiB         785                   if neighbor not in open_set_hash:
    77    135.5 MiB      0.0 MiB         785                       count += 1
    78    135.5 MiB      0.0 MiB         785                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.5 MiB      0.0 MiB         785                       open_set_hash.add(neighbor)
    80                                                             
    81    135.5 MiB      0.0 MiB         464           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.5 MiB      0.0 MiB         464           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.5 MiB    135.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.5 MiB      0.0 MiB         257       for row in grid:
    32    135.5 MiB      0.0 MiB       65792           for spot in row:
    33    135.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.5 MiB      0.0 MiB           1       count = 0
    36    135.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.5 MiB      0.0 MiB           1       came_from = {}
    39    135.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.5 MiB      1.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.5 MiB      0.0 MiB         232       while not open_set.empty():
    49    136.5 MiB      0.0 MiB         232           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.5 MiB      0.0 MiB         232           current = open_set.get()[2]
    55    136.5 MiB      0.0 MiB         232           open_set_hash.remove(current)
    56                                         
    57    136.5 MiB      0.0 MiB         232           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.5 MiB      0.0 MiB         232           if current == end:
    62    136.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.5 MiB      0.0 MiB        2079           for neighbor in current.neighbors:
    67    136.5 MiB      0.0 MiB        1848               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.5 MiB      0.0 MiB         924                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.5 MiB      0.0 MiB         924                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.5 MiB      0.0 MiB        1848               if temp_g_score < g_score[neighbor]:
    73    136.5 MiB      0.0 MiB         362                   came_from[neighbor] = current
    74    136.5 MiB      0.0 MiB         362                   g_score[neighbor] = temp_g_score
    75    136.5 MiB      0.0 MiB         362                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.5 MiB      0.0 MiB         362                   if neighbor not in open_set_hash:
    77    136.5 MiB      0.0 MiB         362                       count += 1
    78    136.5 MiB      0.0 MiB         362                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.5 MiB      0.0 MiB         362                       open_set_hash.add(neighbor)
    80                                                             
    81    136.5 MiB      0.0 MiB         231           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.5 MiB      0.0 MiB         231           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.6 MiB    136.6 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.6 MiB      0.0 MiB         257       for row in grid:
    32    136.6 MiB      0.0 MiB       65792           for spot in row:
    33    136.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.6 MiB      0.0 MiB           1       count = 0
    36    136.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.6 MiB      0.0 MiB           1       came_from = {}
    39    136.6 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.6 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.8 MiB      0.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.8 MiB      0.0 MiB         756       while not open_set.empty():
    49    136.8 MiB      0.0 MiB         756           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.8 MiB      0.0 MiB         756           current = open_set.get()[2]
    55    136.8 MiB      0.0 MiB         756           open_set_hash.remove(current)
    56                                         
    57    136.8 MiB      0.0 MiB         756           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.8 MiB      0.0 MiB         756           if current == end:
    62    136.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.8 MiB      0.0 MiB        6795           for neighbor in current.neighbors:
    67    136.8 MiB      0.0 MiB        6040               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.8 MiB      0.0 MiB        3020                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.8 MiB      0.0 MiB        3020                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.8 MiB      0.0 MiB        6040               if temp_g_score < g_score[neighbor]:
    73    136.8 MiB      0.0 MiB        1148                   came_from[neighbor] = current
    74    136.8 MiB      0.0 MiB        1148                   g_score[neighbor] = temp_g_score
    75    136.8 MiB      0.0 MiB        1148                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.8 MiB      0.0 MiB        1148                   if neighbor not in open_set_hash:
    77    136.8 MiB      0.0 MiB        1148                       count += 1
    78    136.8 MiB      0.0 MiB        1148                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.8 MiB      0.0 MiB        1148                       open_set_hash.add(neighbor)
    80                                                             
    81    136.8 MiB      0.0 MiB         755           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.8 MiB      0.0 MiB         755           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.8 MiB    136.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.8 MiB      0.0 MiB         257       for row in grid:
    32    136.8 MiB      0.0 MiB       65792           for spot in row:
    33    136.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.8 MiB      0.0 MiB           1       count = 0
    36    136.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.8 MiB      0.0 MiB           1       came_from = {}
    39    136.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.8 MiB      0.0 MiB        3150       while not open_set.empty():
    49    136.8 MiB      0.0 MiB        3150           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.8 MiB      0.0 MiB        3150           current = open_set.get()[2]
    55    136.8 MiB      0.0 MiB        3150           open_set_hash.remove(current)
    56                                         
    57    136.8 MiB      0.0 MiB        3150           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.8 MiB      0.0 MiB        3150           if current == end:
    62    136.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.8 MiB      0.0 MiB       28341           for neighbor in current.neighbors:
    67    136.8 MiB      0.0 MiB       25192               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.8 MiB      0.0 MiB       12596                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.8 MiB      0.0 MiB       12596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.8 MiB      0.0 MiB       25192               if temp_g_score < g_score[neighbor]:
    73    136.8 MiB      0.0 MiB        3468                   came_from[neighbor] = current
    74    136.8 MiB      0.0 MiB        3468                   g_score[neighbor] = temp_g_score
    75    136.8 MiB      0.0 MiB        3468                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.8 MiB      0.0 MiB        3468                   if neighbor not in open_set_hash:
    77    136.8 MiB      0.0 MiB        3468                       count += 1
    78    136.8 MiB      0.0 MiB        3468                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.8 MiB      0.0 MiB        3468                       open_set_hash.add(neighbor)
    80                                                             
    81    136.8 MiB      0.0 MiB        3149           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.8 MiB      0.0 MiB        3149           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.8 MiB    136.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.8 MiB      0.0 MiB         257       for row in grid:
    32    136.8 MiB      0.0 MiB       65792           for spot in row:
    33    136.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.8 MiB      0.0 MiB           1       count = 0
    36    136.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.8 MiB      0.0 MiB           1       came_from = {}
    39    136.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.8 MiB      0.0 MiB        3264       while not open_set.empty():
    49    136.8 MiB      0.0 MiB        3264           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.8 MiB      0.0 MiB        3264           current = open_set.get()[2]
    55    136.8 MiB      0.0 MiB        3264           open_set_hash.remove(current)
    56                                         
    57    136.8 MiB      0.0 MiB        3264           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.8 MiB      0.0 MiB        3264           if current == end:
    62    136.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.8 MiB      0.0 MiB       29367           for neighbor in current.neighbors:
    67    136.8 MiB      0.0 MiB       26104               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.8 MiB      0.0 MiB       13052                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.8 MiB      0.0 MiB       13052                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.8 MiB      0.0 MiB       26104               if temp_g_score < g_score[neighbor]:
    73    136.8 MiB      0.0 MiB        3630                   came_from[neighbor] = current
    74    136.8 MiB      0.0 MiB        3630                   g_score[neighbor] = temp_g_score
    75    136.8 MiB      0.0 MiB        3630                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.8 MiB      0.0 MiB        3630                   if neighbor not in open_set_hash:
    77    136.8 MiB      0.0 MiB        3630                       count += 1
    78    136.8 MiB      0.0 MiB        3630                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.8 MiB      0.0 MiB        3630                       open_set_hash.add(neighbor)
    80                                                             
    81    136.8 MiB      0.0 MiB        3263           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.8 MiB      0.0 MiB        3263           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.8 MiB    136.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.8 MiB      0.0 MiB         257       for row in grid:
    32    136.8 MiB      0.0 MiB       65792           for spot in row:
    33    136.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.8 MiB      0.0 MiB           1       count = 0
    36    136.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.8 MiB      0.0 MiB           1       came_from = {}
    39    136.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.8 MiB      0.0 MiB         567       while not open_set.empty():
    49    136.8 MiB      0.0 MiB         567           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.8 MiB      0.0 MiB         567           current = open_set.get()[2]
    55    136.8 MiB      0.0 MiB         567           open_set_hash.remove(current)
    56                                         
    57    136.8 MiB      0.0 MiB         567           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.8 MiB      0.0 MiB         567           if current == end:
    62    136.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.8 MiB      0.0 MiB        5094           for neighbor in current.neighbors:
    67    136.8 MiB      0.0 MiB        4528               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.8 MiB      0.0 MiB        2264                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.8 MiB      0.0 MiB        2264                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.8 MiB      0.0 MiB        4528               if temp_g_score < g_score[neighbor]:
    73    136.8 MiB      0.0 MiB         715                   came_from[neighbor] = current
    74    136.8 MiB      0.0 MiB         715                   g_score[neighbor] = temp_g_score
    75    136.8 MiB      0.0 MiB         715                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.8 MiB      0.0 MiB         715                   if neighbor not in open_set_hash:
    77    136.8 MiB      0.0 MiB         715                       count += 1
    78    136.8 MiB      0.0 MiB         715                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.8 MiB      0.0 MiB         715                       open_set_hash.add(neighbor)
    80                                                             
    81    136.8 MiB      0.0 MiB         566           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.8 MiB      0.0 MiB         566           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.8 MiB    136.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.8 MiB      0.0 MiB         257       for row in grid:
    32    136.8 MiB      0.0 MiB       65792           for spot in row:
    33    136.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.8 MiB      0.0 MiB           1       count = 0
    36    136.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.8 MiB      0.0 MiB           1       came_from = {}
    39    136.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.8 MiB      0.0 MiB        5846       while not open_set.empty():
    49    136.8 MiB      0.0 MiB        5846           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.8 MiB      0.0 MiB        5846           current = open_set.get()[2]
    55    136.8 MiB      0.0 MiB        5846           open_set_hash.remove(current)
    56                                         
    57    136.8 MiB      0.0 MiB        5846           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.8 MiB      0.0 MiB        5846           if current == end:
    62    136.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.8 MiB      0.0 MiB       52605           for neighbor in current.neighbors:
    67    136.8 MiB      0.0 MiB       46760               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.8 MiB      0.0 MiB       23380                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.8 MiB      0.0 MiB       23380                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.8 MiB      0.0 MiB       46760               if temp_g_score < g_score[neighbor]:
    73    136.8 MiB      0.0 MiB        6308                   came_from[neighbor] = current
    74    136.8 MiB      0.0 MiB        6308                   g_score[neighbor] = temp_g_score
    75    136.8 MiB      0.0 MiB        6308                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.8 MiB      0.0 MiB        6308                   if neighbor not in open_set_hash:
    77    136.8 MiB      0.0 MiB        6308                       count += 1
    78    136.8 MiB      0.0 MiB        6308                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.8 MiB      0.0 MiB        6308                       open_set_hash.add(neighbor)
    80                                                             
    81    136.8 MiB      0.0 MiB        5845           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.8 MiB      0.0 MiB        5845           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.8 MiB    136.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.8 MiB      0.0 MiB         257       for row in grid:
    32    136.8 MiB      0.0 MiB       65792           for spot in row:
    33    136.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.8 MiB      0.0 MiB           1       count = 0
    36    136.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.8 MiB      0.0 MiB           1       came_from = {}
    39    136.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.2 MiB      0.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.2 MiB      0.0 MiB        4770       while not open_set.empty():
    49    137.2 MiB      0.0 MiB        4770           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.2 MiB      0.0 MiB        4770           current = open_set.get()[2]
    55    137.2 MiB      0.0 MiB        4770           open_set_hash.remove(current)
    56                                         
    57    137.2 MiB      0.0 MiB        4770           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.2 MiB      0.0 MiB        4770           if current == end:
    62    137.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.2 MiB      0.0 MiB       42921           for neighbor in current.neighbors:
    67    137.2 MiB      0.0 MiB       38152               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.2 MiB      0.0 MiB       19076                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.2 MiB      0.0 MiB       19076                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.2 MiB      0.0 MiB       38152               if temp_g_score < g_score[neighbor]:
    73    137.2 MiB      0.0 MiB        5234                   came_from[neighbor] = current
    74    137.2 MiB      0.0 MiB        5234                   g_score[neighbor] = temp_g_score
    75    137.2 MiB      0.0 MiB        5234                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.2 MiB      0.0 MiB        5234                   if neighbor not in open_set_hash:
    77    137.2 MiB      0.0 MiB        5234                       count += 1
    78    137.2 MiB      0.0 MiB        5234                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.2 MiB      0.0 MiB        5234                       open_set_hash.add(neighbor)
    80                                                             
    81    137.2 MiB      0.0 MiB        4769           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.2 MiB      0.0 MiB        4769           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.2 MiB    137.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.2 MiB      0.0 MiB         257       for row in grid:
    32    137.2 MiB      0.0 MiB       65792           for spot in row:
    33    137.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.2 MiB      0.0 MiB           1       count = 0
    36    137.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.2 MiB      0.0 MiB           1       came_from = {}
    39    137.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.2 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.2 MiB      0.0 MiB        5724       while not open_set.empty():
    49    137.2 MiB      0.0 MiB        5724           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.2 MiB      0.0 MiB        5724           current = open_set.get()[2]
    55    137.2 MiB      0.0 MiB        5724           open_set_hash.remove(current)
    56                                         
    57    137.2 MiB      0.0 MiB        5724           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.2 MiB      0.0 MiB        5724           if current == end:
    62    137.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.2 MiB      0.0 MiB       50874           for neighbor in current.neighbors:
    67    137.2 MiB      0.0 MiB       45151               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.2 MiB      0.0 MiB       22470                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.2 MiB      0.0 MiB       22681                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.2 MiB      0.0 MiB       45151               if temp_g_score < g_score[neighbor]:
    73    137.2 MiB      0.0 MiB        6041                   came_from[neighbor] = current
    74    137.2 MiB      0.0 MiB        6041                   g_score[neighbor] = temp_g_score
    75    137.2 MiB      0.0 MiB        6041                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.2 MiB      0.0 MiB        6041                   if neighbor not in open_set_hash:
    77    137.2 MiB      0.0 MiB        6041                       count += 1
    78    137.2 MiB      0.0 MiB        6041                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.2 MiB      0.0 MiB        6041                       open_set_hash.add(neighbor)
    80                                                             
    81    137.2 MiB      0.0 MiB        5723           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.2 MiB      0.0 MiB        5723           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.2 MiB    137.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.2 MiB      0.0 MiB         257       for row in grid:
    32    137.2 MiB      0.0 MiB       65792           for spot in row:
    33    137.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.2 MiB      0.0 MiB           1       count = 0
    36    137.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.2 MiB      0.0 MiB           1       came_from = {}
    39    137.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.2 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.2 MiB      0.0 MiB        4860       while not open_set.empty():
    49    137.2 MiB      0.0 MiB        4860           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.2 MiB      0.0 MiB        4860           current = open_set.get()[2]
    55    137.2 MiB      0.0 MiB        4860           open_set_hash.remove(current)
    56                                         
    57    137.2 MiB      0.0 MiB        4860           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.2 MiB      0.0 MiB        4860           if current == end:
    62    137.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.2 MiB      0.0 MiB       43731           for neighbor in current.neighbors:
    67    137.2 MiB      0.0 MiB       38872               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.2 MiB      0.0 MiB       19436                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.2 MiB      0.0 MiB       19436                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.2 MiB      0.0 MiB       38872               if temp_g_score < g_score[neighbor]:
    73    137.2 MiB      0.0 MiB        5326                   came_from[neighbor] = current
    74    137.2 MiB      0.0 MiB        5326                   g_score[neighbor] = temp_g_score
    75    137.2 MiB      0.0 MiB        5326                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.2 MiB      0.0 MiB        5326                   if neighbor not in open_set_hash:
    77    137.2 MiB      0.0 MiB        5326                       count += 1
    78    137.2 MiB      0.0 MiB        5326                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.2 MiB      0.0 MiB        5326                       open_set_hash.add(neighbor)
    80                                                             
    81    137.2 MiB      0.0 MiB        4859           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.2 MiB      0.0 MiB        4859           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.2 MiB    137.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.2 MiB      0.0 MiB         257       for row in grid:
    32    137.2 MiB      0.0 MiB       65792           for spot in row:
    33    137.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.2 MiB      0.0 MiB           1       count = 0
    36    137.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.2 MiB      0.0 MiB           1       came_from = {}
    39    137.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.2 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.2 MiB      0.0 MiB         986       while not open_set.empty():
    49    137.2 MiB      0.0 MiB         986           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.2 MiB      0.0 MiB         986           current = open_set.get()[2]
    55    137.2 MiB      0.0 MiB         986           open_set_hash.remove(current)
    56                                         
    57    137.2 MiB      0.0 MiB         986           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.2 MiB      0.0 MiB         986           if current == end:
    62    137.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.2 MiB      0.0 MiB        8865           for neighbor in current.neighbors:
    67    137.2 MiB      0.0 MiB        7880               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.2 MiB      0.0 MiB        3940                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.2 MiB      0.0 MiB        3940                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.2 MiB      0.0 MiB        7880               if temp_g_score < g_score[neighbor]:
    73    137.2 MiB      0.0 MiB        1168                   came_from[neighbor] = current
    74    137.2 MiB      0.0 MiB        1168                   g_score[neighbor] = temp_g_score
    75    137.2 MiB      0.0 MiB        1168                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.2 MiB      0.0 MiB        1168                   if neighbor not in open_set_hash:
    77    137.2 MiB      0.0 MiB        1168                       count += 1
    78    137.2 MiB      0.0 MiB        1168                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.2 MiB      0.0 MiB        1168                       open_set_hash.add(neighbor)
    80                                                             
    81    137.2 MiB      0.0 MiB         985           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.2 MiB      0.0 MiB         985           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.2 MiB    137.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.2 MiB   -302.3 MiB         257       for row in grid:
    32    137.2 MiB -77680.8 MiB       65792           for spot in row:
    33    137.2 MiB -77379.5 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB     -1.3 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB        1548       while not open_set.empty():
    49    135.8 MiB      0.0 MiB        1548           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB        1548           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB        1548           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB        1548           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB        1548           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB       13923           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB       12376               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB        6188                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB        6188                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB       12376               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB        1790                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB        1790                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB        1790                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB        1790                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB        1790                       count += 1
    78    135.8 MiB      0.0 MiB        1790                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB        1790                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB        1547           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB        1547           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.9 MiB      1.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.9 MiB      0.0 MiB         140       while not open_set.empty():
    49    136.9 MiB      0.0 MiB         140           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.9 MiB      0.0 MiB         140           current = open_set.get()[2]
    55    136.9 MiB      0.0 MiB         140           open_set_hash.remove(current)
    56                                         
    57    136.9 MiB      0.0 MiB         140           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.9 MiB      0.0 MiB         140           if current == end:
    62    136.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.9 MiB      0.0 MiB        1251           for neighbor in current.neighbors:
    67    136.9 MiB      0.0 MiB        1112               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.9 MiB      0.0 MiB         556                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.9 MiB      0.0 MiB         556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.9 MiB      0.0 MiB        1112               if temp_g_score < g_score[neighbor]:
    73    136.9 MiB      0.0 MiB         232                   came_from[neighbor] = current
    74    136.9 MiB      0.0 MiB         232                   g_score[neighbor] = temp_g_score
    75    136.9 MiB      0.0 MiB         232                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.9 MiB      0.0 MiB         232                   if neighbor not in open_set_hash:
    77    136.9 MiB      0.0 MiB         232                       count += 1
    78    136.9 MiB      0.0 MiB         232                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.9 MiB      0.0 MiB         232                       open_set_hash.add(neighbor)
    80                                                             
    81    136.9 MiB      0.0 MiB         139           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.9 MiB      0.0 MiB         139           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.9 MiB    136.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.9 MiB      0.0 MiB         257       for row in grid:
    32    136.9 MiB      0.0 MiB       65792           for spot in row:
    33    136.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.9 MiB      0.0 MiB           1       count = 0
    36    136.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.9 MiB      0.0 MiB           1       came_from = {}
    39    136.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.9 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.9 MiB      0.0 MiB         798       while not open_set.empty():
    49    136.9 MiB      0.0 MiB         798           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.9 MiB      0.0 MiB         798           current = open_set.get()[2]
    55    136.9 MiB      0.0 MiB         798           open_set_hash.remove(current)
    56                                         
    57    136.9 MiB      0.0 MiB         798           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.9 MiB      0.0 MiB         798           if current == end:
    62    136.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.9 MiB      0.0 MiB        7173           for neighbor in current.neighbors:
    67    136.9 MiB      0.0 MiB        6376               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.9 MiB      0.0 MiB        3188                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.9 MiB      0.0 MiB        3188                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.9 MiB      0.0 MiB        6376               if temp_g_score < g_score[neighbor]:
    73    136.9 MiB      0.0 MiB         956                   came_from[neighbor] = current
    74    136.9 MiB      0.0 MiB         956                   g_score[neighbor] = temp_g_score
    75    136.9 MiB      0.0 MiB         956                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.9 MiB      0.0 MiB         956                   if neighbor not in open_set_hash:
    77    136.9 MiB      0.0 MiB         956                       count += 1
    78    136.9 MiB      0.0 MiB         956                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.9 MiB      0.0 MiB         956                       open_set_hash.add(neighbor)
    80                                                             
    81    136.9 MiB      0.0 MiB         797           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.9 MiB      0.0 MiB         797           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.9 MiB    136.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.9 MiB      0.0 MiB         257       for row in grid:
    32    136.9 MiB      0.0 MiB       65792           for spot in row:
    33    136.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.9 MiB      0.0 MiB           1       count = 0
    36    136.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.9 MiB      0.0 MiB           1       came_from = {}
    39    136.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.9 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.9 MiB      0.0 MiB        1023       while not open_set.empty():
    49    136.9 MiB      0.0 MiB        1023           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.9 MiB      0.0 MiB        1023           current = open_set.get()[2]
    55    136.9 MiB      0.0 MiB        1023           open_set_hash.remove(current)
    56                                         
    57    136.9 MiB      0.0 MiB        1023           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.9 MiB      0.0 MiB        1023           if current == end:
    62    136.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.9 MiB      0.0 MiB        9198           for neighbor in current.neighbors:
    67    136.9 MiB      0.0 MiB        8176               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.9 MiB      0.0 MiB        4088                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.9 MiB      0.0 MiB        4088                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.9 MiB      0.0 MiB        8176               if temp_g_score < g_score[neighbor]:
    73    136.9 MiB      0.0 MiB        1215                   came_from[neighbor] = current
    74    136.9 MiB      0.0 MiB        1215                   g_score[neighbor] = temp_g_score
    75    136.9 MiB      0.0 MiB        1215                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.9 MiB      0.0 MiB        1215                   if neighbor not in open_set_hash:
    77    136.9 MiB      0.0 MiB        1215                       count += 1
    78    136.9 MiB      0.0 MiB        1215                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.9 MiB      0.0 MiB        1215                       open_set_hash.add(neighbor)
    80                                                             
    81    136.9 MiB      0.0 MiB        1022           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.9 MiB      0.0 MiB        1022           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.9 MiB    136.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.9 MiB      0.0 MiB         257       for row in grid:
    32    136.9 MiB      0.0 MiB       65792           for spot in row:
    33    136.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.9 MiB      0.0 MiB           1       count = 0
    36    136.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.9 MiB      0.0 MiB           1       came_from = {}
    39    136.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.9 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB        3648       while not open_set.empty():
    49    137.0 MiB      0.0 MiB        3648           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB        3648           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB        3648           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB        3648           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB        3648           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB       32823           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB       29176               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB       14588                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB       14588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB       29176               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB        4002                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB        4002                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB        4002                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB        4002                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB        4002                       count += 1
    78    137.0 MiB      0.0 MiB        4002                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB        4002                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB        3647           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB        3647           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.1 MiB      0.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.1 MiB      0.0 MiB         840       while not open_set.empty():
    49    137.1 MiB      0.0 MiB         840           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.1 MiB      0.0 MiB         840           current = open_set.get()[2]
    55    137.1 MiB      0.0 MiB         840           open_set_hash.remove(current)
    56                                         
    57    137.1 MiB      0.0 MiB         840           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.1 MiB      0.0 MiB         840           if current == end:
    62    137.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.1 MiB      0.0 MiB        7551           for neighbor in current.neighbors:
    67    137.1 MiB      0.0 MiB        6712               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.1 MiB      0.0 MiB        3356                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.1 MiB      0.0 MiB        3356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.1 MiB      0.0 MiB        6712               if temp_g_score < g_score[neighbor]:
    73    137.1 MiB      0.0 MiB        1040                   came_from[neighbor] = current
    74    137.1 MiB      0.0 MiB        1040                   g_score[neighbor] = temp_g_score
    75    137.1 MiB      0.0 MiB        1040                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.1 MiB      0.0 MiB        1040                   if neighbor not in open_set_hash:
    77    137.1 MiB      0.0 MiB        1040                       count += 1
    78    137.1 MiB      0.0 MiB        1040                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.1 MiB      0.0 MiB        1040                       open_set_hash.add(neighbor)
    80                                                             
    81    137.1 MiB      0.0 MiB         839           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.1 MiB      0.0 MiB         839           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.1 MiB    137.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.1 MiB      0.0 MiB         257       for row in grid:
    32    137.1 MiB      0.0 MiB       65792           for spot in row:
    33    137.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.1 MiB      0.0 MiB           1       count = 0
    36    137.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.1 MiB      0.0 MiB           1       came_from = {}
    39    137.1 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.1 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.1 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.1 MiB      0.0 MiB        9027       while not open_set.empty():
    49    137.1 MiB      0.0 MiB        9027           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.1 MiB      0.0 MiB        9027           current = open_set.get()[2]
    55    137.1 MiB      0.0 MiB        9027           open_set_hash.remove(current)
    56                                         
    57    137.1 MiB      0.0 MiB        9027           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.1 MiB      0.0 MiB        9027           if current == end:
    62    137.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.1 MiB      0.0 MiB       81234           for neighbor in current.neighbors:
    67    137.1 MiB      0.0 MiB       72208               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.1 MiB      0.0 MiB       36104                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.1 MiB      0.0 MiB       36104                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.1 MiB      0.0 MiB       72208               if temp_g_score < g_score[neighbor]:
    73    137.1 MiB      0.0 MiB        9755                   came_from[neighbor] = current
    74    137.1 MiB      0.0 MiB        9755                   g_score[neighbor] = temp_g_score
    75    137.1 MiB      0.0 MiB        9755                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.1 MiB      0.0 MiB        9755                   if neighbor not in open_set_hash:
    77    137.1 MiB      0.0 MiB        9755                       count += 1
    78    137.1 MiB      0.0 MiB        9755                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.1 MiB      0.0 MiB        9755                       open_set_hash.add(neighbor)
    80                                                             
    81    137.1 MiB      0.0 MiB        9026           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.1 MiB      0.0 MiB        9026           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.1 MiB    137.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.1 MiB      0.0 MiB         257       for row in grid:
    32    137.1 MiB      0.0 MiB       65792           for spot in row:
    33    137.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.1 MiB      0.0 MiB           1       count = 0
    36    137.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.1 MiB      0.0 MiB           1       came_from = {}
    39    137.1 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.1 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.1 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.1 MiB      0.0 MiB         336       while not open_set.empty():
    49    137.1 MiB      0.0 MiB         336           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.1 MiB      0.0 MiB         336           current = open_set.get()[2]
    55    137.1 MiB      0.0 MiB         336           open_set_hash.remove(current)
    56                                         
    57    137.1 MiB      0.0 MiB         336           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.1 MiB      0.0 MiB         336           if current == end:
    62    137.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.1 MiB      0.0 MiB        3015           for neighbor in current.neighbors:
    67    137.1 MiB      0.0 MiB        2680               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.1 MiB      0.0 MiB        1340                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.1 MiB      0.0 MiB        1340                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.1 MiB      0.0 MiB        2680               if temp_g_score < g_score[neighbor]:
    73    137.1 MiB      0.0 MiB         570                   came_from[neighbor] = current
    74    137.1 MiB      0.0 MiB         570                   g_score[neighbor] = temp_g_score
    75    137.1 MiB      0.0 MiB         570                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.1 MiB      0.0 MiB         570                   if neighbor not in open_set_hash:
    77    137.1 MiB      0.0 MiB         570                       count += 1
    78    137.1 MiB      0.0 MiB         570                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.1 MiB      0.0 MiB         570                       open_set_hash.add(neighbor)
    80                                                             
    81    137.1 MiB      0.0 MiB         335           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.1 MiB      0.0 MiB         335           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.1 MiB    137.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.1 MiB      0.0 MiB         257       for row in grid:
    32    137.1 MiB      0.0 MiB       65792           for spot in row:
    33    137.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.1 MiB      0.0 MiB           1       count = 0
    36    137.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.1 MiB      0.0 MiB           1       came_from = {}
    39    137.4 MiB      0.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.5 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.5 MiB      0.0 MiB        2379       while not open_set.empty():
    49    137.5 MiB      0.0 MiB        2379           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.5 MiB      0.0 MiB        2379           current = open_set.get()[2]
    55    137.5 MiB      0.0 MiB        2379           open_set_hash.remove(current)
    56                                         
    57    137.5 MiB      0.0 MiB        2379           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.5 MiB      0.0 MiB        2379           if current == end:
    62    137.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.5 MiB      0.0 MiB       21402           for neighbor in current.neighbors:
    67    137.5 MiB      0.0 MiB       19024               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.5 MiB      0.0 MiB        9512                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.5 MiB      0.0 MiB        9512                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.5 MiB      0.0 MiB       19024               if temp_g_score < g_score[neighbor]:
    73    137.5 MiB      0.0 MiB        2655                   came_from[neighbor] = current
    74    137.5 MiB      0.0 MiB        2655                   g_score[neighbor] = temp_g_score
    75    137.5 MiB      0.0 MiB        2655                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.5 MiB      0.0 MiB        2655                   if neighbor not in open_set_hash:
    77    137.5 MiB      0.0 MiB        2655                       count += 1
    78    137.5 MiB      0.0 MiB        2655                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.5 MiB      0.0 MiB        2655                       open_set_hash.add(neighbor)
    80                                                             
    81    137.5 MiB      0.0 MiB        2378           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.5 MiB      0.0 MiB        2378           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.5 MiB    137.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.5 MiB      0.0 MiB         257       for row in grid:
    32    137.5 MiB      0.0 MiB       65792           for spot in row:
    33    137.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.5 MiB      0.0 MiB           1       count = 0
    36    137.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.5 MiB      0.0 MiB           1       came_from = {}
    39    137.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.5 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.5 MiB      0.0 MiB          23       while not open_set.empty():
    49    137.5 MiB      0.0 MiB          23           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.5 MiB      0.0 MiB          23           current = open_set.get()[2]
    55    137.5 MiB      0.0 MiB          23           open_set_hash.remove(current)
    56                                         
    57    137.5 MiB      0.0 MiB          23           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.5 MiB      0.0 MiB          23           if current == end:
    62    137.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.5 MiB      0.0 MiB         198           for neighbor in current.neighbors:
    67    137.5 MiB      0.0 MiB         176               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.5 MiB      0.0 MiB          88                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.5 MiB      0.0 MiB          88                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.5 MiB      0.0 MiB         176               if temp_g_score < g_score[neighbor]:
    73    137.5 MiB      0.0 MiB         113                   came_from[neighbor] = current
    74    137.5 MiB      0.0 MiB         113                   g_score[neighbor] = temp_g_score
    75    137.5 MiB      0.0 MiB         113                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.5 MiB      0.0 MiB         113                   if neighbor not in open_set_hash:
    77    137.5 MiB      0.0 MiB         113                       count += 1
    78    137.5 MiB      0.0 MiB         113                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.5 MiB      0.0 MiB         113                       open_set_hash.add(neighbor)
    80                                                             
    81    137.5 MiB      0.0 MiB          22           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.5 MiB      0.0 MiB          22           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.5 MiB    137.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.5 MiB      0.0 MiB         257       for row in grid:
    32    137.5 MiB      0.0 MiB       65792           for spot in row:
    33    137.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.5 MiB      0.0 MiB           1       count = 0
    36    137.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.5 MiB      0.0 MiB           1       came_from = {}
    39    137.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.5 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.5 MiB      0.0 MiB        4480       while not open_set.empty():
    49    137.5 MiB      0.0 MiB        4480           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.5 MiB      0.0 MiB        4480           current = open_set.get()[2]
    55    137.5 MiB      0.0 MiB        4480           open_set_hash.remove(current)
    56                                         
    57    137.5 MiB      0.0 MiB        4480           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.5 MiB      0.0 MiB        4480           if current == end:
    62    137.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.5 MiB      0.0 MiB       40311           for neighbor in current.neighbors:
    67    137.5 MiB      0.0 MiB       35832               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.5 MiB      0.0 MiB       17916                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.5 MiB      0.0 MiB       17916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.5 MiB      0.0 MiB       35832               if temp_g_score < g_score[neighbor]:
    73    137.5 MiB      0.0 MiB        4886                   came_from[neighbor] = current
    74    137.5 MiB      0.0 MiB        4886                   g_score[neighbor] = temp_g_score
    75    137.5 MiB      0.0 MiB        4886                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.5 MiB      0.0 MiB        4886                   if neighbor not in open_set_hash:
    77    137.5 MiB      0.0 MiB        4886                       count += 1
    78    137.5 MiB      0.0 MiB        4886                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.5 MiB      0.0 MiB        4886                       open_set_hash.add(neighbor)
    80                                                             
    81    137.5 MiB      0.0 MiB        4479           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.5 MiB      0.0 MiB        4479           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.5 MiB    137.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.5 MiB      0.0 MiB         257       for row in grid:
    32    137.5 MiB      0.0 MiB       65792           for spot in row:
    33    137.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.5 MiB      0.0 MiB           1       count = 0
    36    137.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.5 MiB      0.0 MiB           1       came_from = {}
    39    137.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.5 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.5 MiB      0.0 MiB         174       while not open_set.empty():
    49    137.5 MiB      0.0 MiB         174           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.5 MiB      0.0 MiB         174           current = open_set.get()[2]
    55    137.5 MiB      0.0 MiB         174           open_set_hash.remove(current)
    56                                         
    57    137.5 MiB      0.0 MiB         174           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.5 MiB      0.0 MiB         174           if current == end:
    62    137.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.5 MiB      0.0 MiB        1557           for neighbor in current.neighbors:
    67    137.5 MiB      0.0 MiB        1384               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.5 MiB      0.0 MiB         692                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.5 MiB      0.0 MiB         692                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.5 MiB      0.0 MiB        1384               if temp_g_score < g_score[neighbor]:
    73    137.5 MiB      0.0 MiB         300                   came_from[neighbor] = current
    74    137.5 MiB      0.0 MiB         300                   g_score[neighbor] = temp_g_score
    75    137.5 MiB      0.0 MiB         300                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.5 MiB      0.0 MiB         300                   if neighbor not in open_set_hash:
    77    137.5 MiB      0.0 MiB         300                       count += 1
    78    137.5 MiB      0.0 MiB         300                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.5 MiB      0.0 MiB         300                       open_set_hash.add(neighbor)
    80                                                             
    81    137.5 MiB      0.0 MiB         173           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.5 MiB      0.0 MiB         173           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.5 MiB    137.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.5 MiB    -29.6 MiB         257       for row in grid:
    32    137.5 MiB  -7557.5 MiB       65792           for spot in row:
    33    137.5 MiB  -7528.4 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.9 MiB     -0.7 MiB           1       count = 0
    36    136.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.9 MiB      0.0 MiB           1       came_from = {}
    39    136.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.9 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.9 MiB      0.0 MiB        1807       while not open_set.empty():
    49    136.9 MiB      0.0 MiB        1807           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.9 MiB      0.0 MiB        1807           current = open_set.get()[2]
    55    136.9 MiB      0.0 MiB        1807           open_set_hash.remove(current)
    56                                         
    57    136.9 MiB      0.0 MiB        1807           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.9 MiB      0.0 MiB        1807           if current == end:
    62    136.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.9 MiB      0.0 MiB       16254           for neighbor in current.neighbors:
    67    136.9 MiB      0.0 MiB       14448               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.9 MiB      0.0 MiB        7224                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.9 MiB      0.0 MiB        7224                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.9 MiB      0.0 MiB       14448               if temp_g_score < g_score[neighbor]:
    73    136.9 MiB      0.0 MiB        2387                   came_from[neighbor] = current
    74    136.9 MiB      0.0 MiB        2387                   g_score[neighbor] = temp_g_score
    75    136.9 MiB      0.0 MiB        2387                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.9 MiB      0.0 MiB        2387                   if neighbor not in open_set_hash:
    77    136.9 MiB      0.0 MiB        2387                       count += 1
    78    136.9 MiB      0.0 MiB        2387                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.9 MiB      0.0 MiB        2387                       open_set_hash.add(neighbor)
    80                                                             
    81    136.9 MiB      0.0 MiB        1806           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.9 MiB      0.0 MiB        1806           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.9 MiB    136.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.9 MiB      0.0 MiB         257       for row in grid:
    32    136.9 MiB      0.0 MiB       65792           for spot in row:
    33    136.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.9 MiB      0.0 MiB           1       count = 0
    36    136.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.9 MiB      0.0 MiB           1       came_from = {}
    39    136.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.9 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.9 MiB      0.0 MiB         325       while not open_set.empty():
    49    136.9 MiB      0.0 MiB         325           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.9 MiB      0.0 MiB         325           current = open_set.get()[2]
    55    136.9 MiB      0.0 MiB         325           open_set_hash.remove(current)
    56                                         
    57    136.9 MiB      0.0 MiB         325           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.9 MiB      0.0 MiB         325           if current == end:
    62    136.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.9 MiB      0.0 MiB        2916           for neighbor in current.neighbors:
    67    136.9 MiB      0.0 MiB        2592               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.9 MiB      0.0 MiB        1296                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.9 MiB      0.0 MiB        1296                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.9 MiB      0.0 MiB        2592               if temp_g_score < g_score[neighbor]:
    73    136.9 MiB      0.0 MiB         473                   came_from[neighbor] = current
    74    136.9 MiB      0.0 MiB         473                   g_score[neighbor] = temp_g_score
    75    136.9 MiB      0.0 MiB         473                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.9 MiB      0.0 MiB         473                   if neighbor not in open_set_hash:
    77    136.9 MiB      0.0 MiB         473                       count += 1
    78    136.9 MiB      0.0 MiB         473                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.9 MiB      0.0 MiB         473                       open_set_hash.add(neighbor)
    80                                                             
    81    136.9 MiB      0.0 MiB         324           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.9 MiB      0.0 MiB         324           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.9 MiB    136.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.9 MiB      0.0 MiB         257       for row in grid:
    32    136.9 MiB      0.0 MiB       65792           for spot in row:
    33    136.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.9 MiB      0.0 MiB           1       count = 0
    36    136.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.9 MiB      0.0 MiB           1       came_from = {}
    39    136.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.1 MiB      0.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.1 MiB      0.0 MiB         464       while not open_set.empty():
    49    137.1 MiB      0.0 MiB         464           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.1 MiB      0.0 MiB         464           current = open_set.get()[2]
    55    137.1 MiB      0.0 MiB         464           open_set_hash.remove(current)
    56                                         
    57    137.1 MiB      0.0 MiB         464           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.1 MiB      0.0 MiB         464           if current == end:
    62    137.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.1 MiB      0.0 MiB        4167           for neighbor in current.neighbors:
    67    137.1 MiB      0.0 MiB        3704               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.1 MiB      0.0 MiB        1852                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.1 MiB      0.0 MiB        1852                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.1 MiB      0.0 MiB        3704               if temp_g_score < g_score[neighbor]:
    73    137.1 MiB      0.0 MiB         584                   came_from[neighbor] = current
    74    137.1 MiB      0.0 MiB         584                   g_score[neighbor] = temp_g_score
    75    137.1 MiB      0.0 MiB         584                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.1 MiB      0.0 MiB         584                   if neighbor not in open_set_hash:
    77    137.1 MiB      0.0 MiB         584                       count += 1
    78    137.1 MiB      0.0 MiB         584                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.1 MiB      0.0 MiB         584                       open_set_hash.add(neighbor)
    80                                                             
    81    137.1 MiB      0.0 MiB         463           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.1 MiB      0.0 MiB         463           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.1 MiB    137.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.1 MiB      0.0 MiB         257       for row in grid:
    32    137.1 MiB      0.0 MiB       65792           for spot in row:
    33    137.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.1 MiB      0.0 MiB           1       count = 0
    36    137.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.1 MiB      0.0 MiB           1       came_from = {}
    39    137.1 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.1 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.1 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.1 MiB      0.0 MiB         133       while not open_set.empty():
    49    137.1 MiB      0.0 MiB         133           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.1 MiB      0.0 MiB         133           current = open_set.get()[2]
    55    137.1 MiB      0.0 MiB         133           open_set_hash.remove(current)
    56                                         
    57    137.1 MiB      0.0 MiB         133           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.1 MiB      0.0 MiB         133           if current == end:
    62    137.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.1 MiB      0.0 MiB        1188           for neighbor in current.neighbors:
    67    137.1 MiB      0.0 MiB        1056               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.1 MiB      0.0 MiB         528                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.1 MiB      0.0 MiB         528                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.1 MiB      0.0 MiB        1056               if temp_g_score < g_score[neighbor]:
    73    137.1 MiB      0.0 MiB         197                   came_from[neighbor] = current
    74    137.1 MiB      0.0 MiB         197                   g_score[neighbor] = temp_g_score
    75    137.1 MiB      0.0 MiB         197                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.1 MiB      0.0 MiB         197                   if neighbor not in open_set_hash:
    77    137.1 MiB      0.0 MiB         197                       count += 1
    78    137.1 MiB      0.0 MiB         197                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.1 MiB      0.0 MiB         197                       open_set_hash.add(neighbor)
    80                                                             
    81    137.1 MiB      0.0 MiB         132           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.1 MiB      0.0 MiB         132           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.1 MiB    137.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.1 MiB      0.0 MiB         257       for row in grid:
    32    137.1 MiB      0.0 MiB       65792           for spot in row:
    33    137.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.1 MiB      0.0 MiB           1       count = 0
    36    137.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.1 MiB      0.0 MiB           1       came_from = {}
    39    137.1 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.1 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.1 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.1 MiB      0.0 MiB        7040       while not open_set.empty():
    49    137.1 MiB      0.0 MiB        7040           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.1 MiB      0.0 MiB        7040           current = open_set.get()[2]
    55    137.1 MiB      0.0 MiB        7040           open_set_hash.remove(current)
    56                                         
    57    137.1 MiB      0.0 MiB        7040           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.1 MiB      0.0 MiB        7040           if current == end:
    62    137.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.1 MiB      0.0 MiB       63351           for neighbor in current.neighbors:
    67    137.1 MiB      0.0 MiB       56312               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.1 MiB      0.0 MiB       28156                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.1 MiB      0.0 MiB       28156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.1 MiB      0.0 MiB       56312               if temp_g_score < g_score[neighbor]:
    73    137.1 MiB      0.0 MiB        7550                   came_from[neighbor] = current
    74    137.1 MiB      0.0 MiB        7550                   g_score[neighbor] = temp_g_score
    75    137.1 MiB      0.0 MiB        7550                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.1 MiB      0.0 MiB        7550                   if neighbor not in open_set_hash:
    77    137.1 MiB      0.0 MiB        7550                       count += 1
    78    137.1 MiB      0.0 MiB        7550                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.1 MiB      0.0 MiB        7550                       open_set_hash.add(neighbor)
    80                                                             
    81    137.1 MiB      0.0 MiB        7039           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.1 MiB      0.0 MiB        7039           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.1 MiB    137.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.1 MiB   -284.6 MiB         257       for row in grid:
    32    137.1 MiB -72854.5 MiB       65792           for spot in row:
    33    137.1 MiB -72571.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.7 MiB     -1.4 MiB           1       count = 0
    36    135.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.7 MiB      0.0 MiB           1       came_from = {}
    39    136.2 MiB      0.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.2 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.2 MiB      0.0 MiB        3094       while not open_set.empty():
    49    136.2 MiB      0.0 MiB        3094           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.2 MiB      0.0 MiB        3094           current = open_set.get()[2]
    55    136.2 MiB      0.0 MiB        3094           open_set_hash.remove(current)
    56                                         
    57    136.2 MiB      0.0 MiB        3094           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.2 MiB      0.0 MiB        3094           if current == end:
    62    136.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.2 MiB      0.0 MiB       27837           for neighbor in current.neighbors:
    67    136.2 MiB      0.0 MiB       24744               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.2 MiB      0.0 MiB       12372                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.2 MiB      0.0 MiB       12372                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.2 MiB      0.0 MiB       24744               if temp_g_score < g_score[neighbor]:
    73    136.2 MiB      0.0 MiB        3434                   came_from[neighbor] = current
    74    136.2 MiB      0.0 MiB        3434                   g_score[neighbor] = temp_g_score
    75    136.2 MiB      0.0 MiB        3434                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.2 MiB      0.0 MiB        3434                   if neighbor not in open_set_hash:
    77    136.2 MiB      0.0 MiB        3434                       count += 1
    78    136.2 MiB      0.0 MiB        3434                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.2 MiB      0.0 MiB        3434                       open_set_hash.add(neighbor)
    80                                                             
    81    136.2 MiB      0.0 MiB        3093           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.2 MiB      0.0 MiB        3093           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.2 MiB    136.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.2 MiB      0.0 MiB         257       for row in grid:
    32    136.2 MiB      0.0 MiB       65792           for spot in row:
    33    136.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.2 MiB      0.0 MiB           1       count = 0
    36    136.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.2 MiB      0.0 MiB           1       came_from = {}
    39    136.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.2 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.2 MiB      0.0 MiB        1305       while not open_set.empty():
    49    136.2 MiB      0.0 MiB        1305           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.2 MiB      0.0 MiB        1305           current = open_set.get()[2]
    55    136.2 MiB      0.0 MiB        1305           open_set_hash.remove(current)
    56                                         
    57    136.2 MiB      0.0 MiB        1305           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.2 MiB      0.0 MiB        1305           if current == end:
    62    136.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.2 MiB      0.0 MiB       11736           for neighbor in current.neighbors:
    67    136.2 MiB      0.0 MiB       10432               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.2 MiB      0.0 MiB        5216                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.2 MiB      0.0 MiB        5216                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.2 MiB      0.0 MiB       10432               if temp_g_score < g_score[neighbor]:
    73    136.2 MiB      0.0 MiB        1681                   came_from[neighbor] = current
    74    136.2 MiB      0.0 MiB        1681                   g_score[neighbor] = temp_g_score
    75    136.2 MiB      0.0 MiB        1681                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.2 MiB      0.0 MiB        1681                   if neighbor not in open_set_hash:
    77    136.2 MiB      0.0 MiB        1681                       count += 1
    78    136.2 MiB      0.0 MiB        1681                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.2 MiB      0.0 MiB        1681                       open_set_hash.add(neighbor)
    80                                                             
    81    136.2 MiB      0.0 MiB        1304           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.2 MiB      0.0 MiB        1304           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.2 MiB    136.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.2 MiB   -781.3 MiB         257       for row in grid:
    32    136.2 MiB -200386.2 MiB       65792           for spot in row:
    33    136.2 MiB -199607.4 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    132.4 MiB     -3.8 MiB           1       count = 0
    36    132.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    132.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    132.4 MiB      0.0 MiB           1       came_from = {}
    39    132.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    132.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    133.4 MiB      0.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    133.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    133.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    133.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    133.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    133.4 MiB      0.0 MiB        1494       while not open_set.empty():
    49    133.4 MiB      0.0 MiB        1494           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    133.4 MiB      0.0 MiB        1494           current = open_set.get()[2]
    55    133.4 MiB      0.0 MiB        1494           open_set_hash.remove(current)
    56                                         
    57    133.4 MiB      0.0 MiB        1494           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    133.4 MiB      0.0 MiB        1494           if current == end:
    62    133.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    133.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    133.4 MiB      0.0 MiB       13437           for neighbor in current.neighbors:
    67    133.4 MiB      0.0 MiB       11944               if current.row != neighbor.row and current.col != neighbor.col:
    68    133.4 MiB      0.0 MiB        5972                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    133.4 MiB      0.0 MiB        5972                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    133.4 MiB      0.0 MiB       11944               if temp_g_score < g_score[neighbor]:
    73    133.4 MiB      0.0 MiB        1730                   came_from[neighbor] = current
    74    133.4 MiB      0.0 MiB        1730                   g_score[neighbor] = temp_g_score
    75    133.4 MiB      0.0 MiB        1730                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    133.4 MiB      0.0 MiB        1730                   if neighbor not in open_set_hash:
    77    133.4 MiB      0.0 MiB        1730                       count += 1
    78    133.4 MiB      0.0 MiB        1730                       open_set.put((f_score[neighbor], count, neighbor))
    79    133.4 MiB      0.0 MiB        1730                       open_set_hash.add(neighbor)
    80                                                             
    81    133.4 MiB      0.0 MiB        1493           if draw is not None:
    82                                                     draw()
    83                                         
    84    133.4 MiB      0.0 MiB        1493           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    133.4 MiB    133.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    133.4 MiB      0.0 MiB         257       for row in grid:
    32    133.4 MiB      0.0 MiB       65792           for spot in row:
    33    133.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    133.4 MiB      0.0 MiB           1       count = 0
    36    133.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    133.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    133.4 MiB      0.0 MiB           1       came_from = {}
    39    133.5 MiB      0.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    133.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    133.5 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    133.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    133.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    133.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    133.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    133.5 MiB      0.0 MiB         539       while not open_set.empty():
    49    133.5 MiB      0.0 MiB         539           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    133.5 MiB      0.0 MiB         539           current = open_set.get()[2]
    55    133.5 MiB      0.0 MiB         539           open_set_hash.remove(current)
    56                                         
    57    133.5 MiB      0.0 MiB         539           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    133.5 MiB      0.0 MiB         539           if current == end:
    62    133.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    133.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    133.5 MiB      0.0 MiB        4842           for neighbor in current.neighbors:
    67    133.5 MiB      0.0 MiB        4304               if current.row != neighbor.row and current.col != neighbor.col:
    68    133.5 MiB      0.0 MiB        2152                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    133.5 MiB      0.0 MiB        2152                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    133.5 MiB      0.0 MiB        4304               if temp_g_score < g_score[neighbor]:
    73    133.5 MiB      0.0 MiB         755                   came_from[neighbor] = current
    74    133.5 MiB      0.0 MiB         755                   g_score[neighbor] = temp_g_score
    75    133.5 MiB      0.0 MiB         755                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    133.5 MiB      0.0 MiB         755                   if neighbor not in open_set_hash:
    77    133.5 MiB      0.0 MiB         755                       count += 1
    78    133.5 MiB      0.0 MiB         755                       open_set.put((f_score[neighbor], count, neighbor))
    79    133.5 MiB      0.0 MiB         755                       open_set_hash.add(neighbor)
    80                                                             
    81    133.5 MiB      0.0 MiB         538           if draw is not None:
    82                                                     draw()
    83                                         
    84    133.5 MiB      0.0 MiB         538           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    133.5 MiB    133.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    133.5 MiB      0.0 MiB         257       for row in grid:
    32    133.5 MiB      0.0 MiB       65792           for spot in row:
    33    133.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    133.5 MiB      0.0 MiB           1       count = 0
    36    133.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    133.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    133.5 MiB      0.0 MiB           1       came_from = {}
    39    133.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    133.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.6 MiB      2.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.6 MiB      0.0 MiB        2600       while not open_set.empty():
    49    135.6 MiB      0.0 MiB        2600           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.6 MiB      0.0 MiB        2600           current = open_set.get()[2]
    55    135.6 MiB      0.0 MiB        2600           open_set_hash.remove(current)
    56                                         
    57    135.6 MiB      0.0 MiB        2600           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.6 MiB      0.0 MiB        2600           if current == end:
    62    135.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.6 MiB      0.0 MiB       23391           for neighbor in current.neighbors:
    67    135.6 MiB      0.0 MiB       20792               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.6 MiB      0.0 MiB       10396                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.6 MiB      0.0 MiB       10396                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.6 MiB      0.0 MiB       20792               if temp_g_score < g_score[neighbor]:
    73    135.6 MiB      0.0 MiB        2902                   came_from[neighbor] = current
    74    135.6 MiB      0.0 MiB        2902                   g_score[neighbor] = temp_g_score
    75    135.6 MiB      0.0 MiB        2902                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.6 MiB      0.0 MiB        2902                   if neighbor not in open_set_hash:
    77    135.6 MiB      0.0 MiB        2902                       count += 1
    78    135.6 MiB      0.0 MiB        2902                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.6 MiB      0.0 MiB        2902                       open_set_hash.add(neighbor)
    80                                                             
    81    135.6 MiB      0.0 MiB        2599           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.6 MiB      0.0 MiB        2599           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.6 MiB    135.6 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.6 MiB      0.0 MiB         257       for row in grid:
    32    135.6 MiB      0.0 MiB       65792           for spot in row:
    33    135.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.6 MiB      0.0 MiB           1       count = 0
    36    135.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.6 MiB      0.0 MiB           1       came_from = {}
    39    136.8 MiB      1.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.9 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.9 MiB      0.0 MiB         132       while not open_set.empty():
    49    136.9 MiB      0.0 MiB         132           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.9 MiB      0.0 MiB         132           current = open_set.get()[2]
    55    136.9 MiB      0.0 MiB         132           open_set_hash.remove(current)
    56                                         
    57    136.9 MiB      0.0 MiB         132           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.9 MiB      0.0 MiB         132           if current == end:
    62    136.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.9 MiB      0.0 MiB        1179           for neighbor in current.neighbors:
    67    136.9 MiB      0.0 MiB        1048               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.9 MiB      0.0 MiB         524                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.9 MiB      0.0 MiB         524                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.9 MiB      0.0 MiB        1048               if temp_g_score < g_score[neighbor]:
    73    136.9 MiB      0.0 MiB         270                   came_from[neighbor] = current
    74    136.9 MiB      0.0 MiB         270                   g_score[neighbor] = temp_g_score
    75    136.9 MiB      0.0 MiB         270                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.9 MiB      0.0 MiB         270                   if neighbor not in open_set_hash:
    77    136.9 MiB      0.0 MiB         270                       count += 1
    78    136.9 MiB      0.0 MiB         270                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.9 MiB      0.0 MiB         270                       open_set_hash.add(neighbor)
    80                                                             
    81    136.9 MiB      0.0 MiB         131           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.9 MiB      0.0 MiB         131           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.9 MiB    136.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.9 MiB      0.0 MiB         257       for row in grid:
    32    136.9 MiB      0.0 MiB       65792           for spot in row:
    33    136.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.9 MiB      0.0 MiB           1       count = 0
    36    136.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.9 MiB      0.0 MiB           1       came_from = {}
    39    136.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.9 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.9 MiB      0.0 MiB        6517       while not open_set.empty():
    49    136.9 MiB      0.0 MiB        6517           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.9 MiB      0.0 MiB        6517           current = open_set.get()[2]
    55    136.9 MiB      0.0 MiB        6517           open_set_hash.remove(current)
    56                                         
    57    136.9 MiB      0.0 MiB        6517           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.9 MiB      0.0 MiB        6517           if current == end:
    62    136.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.9 MiB      0.0 MiB       58644           for neighbor in current.neighbors:
    67    136.9 MiB      0.0 MiB       52128               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.9 MiB      0.0 MiB       26064                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.9 MiB      0.0 MiB       26064                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.9 MiB      0.0 MiB       52128               if temp_g_score < g_score[neighbor]:
    73    136.9 MiB      0.0 MiB        6977                   came_from[neighbor] = current
    74    136.9 MiB      0.0 MiB        6977                   g_score[neighbor] = temp_g_score
    75    136.9 MiB      0.0 MiB        6977                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.9 MiB      0.0 MiB        6977                   if neighbor not in open_set_hash:
    77    136.9 MiB      0.0 MiB        6977                       count += 1
    78    136.9 MiB      0.0 MiB        6977                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.9 MiB      0.0 MiB        6977                       open_set_hash.add(neighbor)
    80                                                             
    81    136.9 MiB      0.0 MiB        6516           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.9 MiB      0.0 MiB        6516           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.9 MiB    136.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.9 MiB      0.0 MiB         257       for row in grid:
    32    136.9 MiB      0.0 MiB       65792           for spot in row:
    33    136.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.9 MiB      0.0 MiB           1       count = 0
    36    136.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.9 MiB      0.0 MiB           1       came_from = {}
    39    136.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB         306       while not open_set.empty():
    49    137.0 MiB      0.0 MiB         306           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB         306           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB         306           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB         306           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB         306           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB        2745           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB        2440               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB        1220                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB        1220                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB        2440               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB         408                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB         408                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB         408                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB         408                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB         408                       count += 1
    78    137.0 MiB      0.0 MiB         408                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB         408                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB         305           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB         305           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB       14336       while not open_set.empty():
    49    137.0 MiB      0.0 MiB       14336           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB       14336           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB       14336           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB       14336           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB       14336           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB      129015           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB      114680               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB       57340                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB       57340                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB      114680               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB       15070                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB       15070                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB       15070                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB       15070                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB       15070                       count += 1
    78    137.0 MiB      0.0 MiB       15070                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB       15070                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB       14335           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB       14335           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB        5890       while not open_set.empty():
    49    137.0 MiB      0.0 MiB        5890           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB        5890           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB        5890           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB        5890           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB        5890           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB       53001           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB       47112               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB       23556                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB       23556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB       47112               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB        6392                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB        6392                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB        6392                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB        6392                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB        6392                       count += 1
    78    137.0 MiB      0.0 MiB        6392                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB        6392                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB        5889           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB        5889           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB        3230       while not open_set.empty():
    49    137.0 MiB      0.0 MiB        3230           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB        3230           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB        3230           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB        3230           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB        3230           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB       29061           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB       25832               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB       12916                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB       12916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB       25832               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB        3550                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB        3550                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB        3550                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB        3550                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB        3550                       count += 1
    78    137.0 MiB      0.0 MiB        3550                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB        3550                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB        3229           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB        3229           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB          90       while not open_set.empty():
    49    137.0 MiB      0.0 MiB          90           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB          90           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB          90           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB          90           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB          90           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB         801           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB         712               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB         356                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB         356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB         712               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB         142                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB         142                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB         142                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB         142                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB         142                       count += 1
    78    137.0 MiB      0.0 MiB         142                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB         142                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB          89           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB          89           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB         864       while not open_set.empty():
    49    137.0 MiB      0.0 MiB         864           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB         864           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB         864           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB         864           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB         864           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB        7767           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB        6904               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB        3452                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB        3452                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB        6904               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB        1030                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB        1030                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB        1030                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB        1030                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB        1030                       count += 1
    78    137.0 MiB      0.0 MiB        1030                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB        1030                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB         863           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB         863           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB        7332       while not open_set.empty():
    49    137.0 MiB      0.0 MiB        7332           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB        7332           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB        7332           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB        7332           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB        7332           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB       65979           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB       58648               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB       29324                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB       29324                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB       58648               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB        7830                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB        7830                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB        7830                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB        7830                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB        7830                       count += 1
    78    137.0 MiB      0.0 MiB        7830                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB        7830                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB        7331           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB        7331           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB         322       while not open_set.empty():
    49    137.0 MiB      0.0 MiB         322           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB         322           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB         322           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB         322           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB         322           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB        2889           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB        2568               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB        1284                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB        1284                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB        2568               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB         440                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB         440                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB         440                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB         440                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB         440                       count += 1
    78    137.0 MiB      0.0 MiB         440                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB         440                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB         321           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB         321           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB         360       while not open_set.empty():
    49    137.0 MiB      0.0 MiB         360           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB         360           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB         360           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB         360           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB         360           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB        3231           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB        2872               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB        1436                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB        1436                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB        2872               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB         656                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB         656                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB         656                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB         656                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB         656                       count += 1
    78    137.0 MiB      0.0 MiB         656                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB         656                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB         359           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB         359           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB        2400       while not open_set.empty():
    49    137.0 MiB      0.0 MiB        2400           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB        2400           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB        2400           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB        2400           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB        2400           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB       21591           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB       19192               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB        9596                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB        9596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB       19192               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB        2690                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB        2690                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB        2690                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB        2690                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB        2690                       count += 1
    78    137.0 MiB      0.0 MiB        2690                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB        2690                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB        2399           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB        2399           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB        5092       while not open_set.empty():
    49    137.0 MiB      0.0 MiB        5092           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB        5092           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB        5092           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB        5092           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB        5092           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB       45819           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB       40728               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB       20364                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB       20364                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB       40728               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB        5702                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB        5702                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB        5702                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB        5702                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB        5702                       count += 1
    78    137.0 MiB      0.0 MiB        5702                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB        5702                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB        5091           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB        5091           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.0 MiB      0.0 MiB        1330       while not open_set.empty():
    49    137.0 MiB      0.0 MiB        1330           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.0 MiB      0.0 MiB        1330           current = open_set.get()[2]
    55    137.0 MiB      0.0 MiB        1330           open_set_hash.remove(current)
    56                                         
    57    137.0 MiB      0.0 MiB        1330           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.0 MiB      0.0 MiB        1330           if current == end:
    62    137.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.0 MiB      0.0 MiB       11961           for neighbor in current.neighbors:
    67    137.0 MiB      0.0 MiB       10632               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.0 MiB      0.0 MiB        5316                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.0 MiB      0.0 MiB        5316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.0 MiB      0.0 MiB       10632               if temp_g_score < g_score[neighbor]:
    73    137.0 MiB      0.0 MiB        1574                   came_from[neighbor] = current
    74    137.0 MiB      0.0 MiB        1574                   g_score[neighbor] = temp_g_score
    75    137.0 MiB      0.0 MiB        1574                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.0 MiB      0.0 MiB        1574                   if neighbor not in open_set_hash:
    77    137.0 MiB      0.0 MiB        1574                       count += 1
    78    137.0 MiB      0.0 MiB        1574                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.0 MiB      0.0 MiB        1574                       open_set_hash.add(neighbor)
    80                                                             
    81    137.0 MiB      0.0 MiB        1329           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.0 MiB      0.0 MiB        1329           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.0 MiB    137.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.0 MiB      0.0 MiB         257       for row in grid:
    32    137.0 MiB      0.0 MiB       65792           for spot in row:
    33    137.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.0 MiB      0.0 MiB           1       count = 0
    36    137.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.0 MiB      0.0 MiB           1       came_from = {}
    39    137.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.7 MiB      0.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.7 MiB      0.0 MiB        4440       while not open_set.empty():
    49    137.7 MiB      0.0 MiB        4440           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.7 MiB      0.0 MiB        4440           current = open_set.get()[2]
    55    137.7 MiB      0.0 MiB        4440           open_set_hash.remove(current)
    56                                         
    57    137.7 MiB      0.0 MiB        4440           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.7 MiB      0.0 MiB        4440           if current == end:
    62    137.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.7 MiB      0.0 MiB       39951           for neighbor in current.neighbors:
    67    137.7 MiB      0.0 MiB       35512               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.7 MiB      0.0 MiB       17756                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.7 MiB      0.0 MiB       17756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.7 MiB      0.0 MiB       35512               if temp_g_score < g_score[neighbor]:
    73    137.7 MiB      0.0 MiB        4904                   came_from[neighbor] = current
    74    137.7 MiB      0.0 MiB        4904                   g_score[neighbor] = temp_g_score
    75    137.7 MiB      0.0 MiB        4904                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.7 MiB      0.0 MiB        4904                   if neighbor not in open_set_hash:
    77    137.7 MiB      0.0 MiB        4904                       count += 1
    78    137.7 MiB      0.0 MiB        4904                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.7 MiB      0.0 MiB        4904                       open_set_hash.add(neighbor)
    80                                                             
    81    137.7 MiB      0.0 MiB        4439           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.7 MiB      0.0 MiB        4439           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.7 MiB    137.7 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.7 MiB      0.0 MiB         257       for row in grid:
    32    137.7 MiB      0.0 MiB       65792           for spot in row:
    33    137.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.7 MiB      0.0 MiB           1       count = 0
    36    137.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.7 MiB      0.0 MiB           1       came_from = {}
    39    137.7 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.7 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.7 MiB      0.0 MiB        5499       while not open_set.empty():
    49    137.7 MiB      0.0 MiB        5499           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.7 MiB      0.0 MiB        5499           current = open_set.get()[2]
    55    137.7 MiB      0.0 MiB        5499           open_set_hash.remove(current)
    56                                         
    57    137.7 MiB      0.0 MiB        5499           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.7 MiB      0.0 MiB        5499           if current == end:
    62    137.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.7 MiB      0.0 MiB       49482           for neighbor in current.neighbors:
    67    137.7 MiB      0.0 MiB       43984               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.7 MiB      0.0 MiB       21992                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.7 MiB      0.0 MiB       21992                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.7 MiB      0.0 MiB       43984               if temp_g_score < g_score[neighbor]:
    73    137.7 MiB      0.0 MiB        5935                   came_from[neighbor] = current
    74    137.7 MiB      0.0 MiB        5935                   g_score[neighbor] = temp_g_score
    75    137.7 MiB      0.0 MiB        5935                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.7 MiB      0.0 MiB        5935                   if neighbor not in open_set_hash:
    77    137.7 MiB      0.0 MiB        5935                       count += 1
    78    137.7 MiB      0.0 MiB        5935                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.7 MiB      0.0 MiB        5935                       open_set_hash.add(neighbor)
    80                                                             
    81    137.7 MiB      0.0 MiB        5498           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.7 MiB      0.0 MiB        5498           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.7 MiB    137.7 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.7 MiB      0.0 MiB         257       for row in grid:
    32    137.7 MiB      0.0 MiB       65792           for spot in row:
    33    137.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.7 MiB      0.0 MiB           1       count = 0
    36    137.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.7 MiB      0.0 MiB           1       came_from = {}
    39    137.7 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.7 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.7 MiB      0.0 MiB         318       while not open_set.empty():
    49    137.7 MiB      0.0 MiB         318           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.7 MiB      0.0 MiB         318           current = open_set.get()[2]
    55    137.7 MiB      0.0 MiB         318           open_set_hash.remove(current)
    56                                         
    57    137.7 MiB      0.0 MiB         318           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.7 MiB      0.0 MiB         318           if current == end:
    62    137.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.7 MiB      0.0 MiB        2853           for neighbor in current.neighbors:
    67    137.7 MiB      0.0 MiB        2536               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.7 MiB      0.0 MiB        1268                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.7 MiB      0.0 MiB        1268                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.7 MiB      0.0 MiB        2536               if temp_g_score < g_score[neighbor]:
    73    137.7 MiB      0.0 MiB         746                   came_from[neighbor] = current
    74    137.7 MiB      0.0 MiB         746                   g_score[neighbor] = temp_g_score
    75    137.7 MiB      0.0 MiB         746                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.7 MiB      0.0 MiB         746                   if neighbor not in open_set_hash:
    77    137.7 MiB      0.0 MiB         746                       count += 1
    78    137.7 MiB      0.0 MiB         746                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.7 MiB      0.0 MiB         746                       open_set_hash.add(neighbor)
    80                                                             
    81    137.7 MiB      0.0 MiB         317           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.7 MiB      0.0 MiB         317           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.7 MiB    137.7 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.7 MiB      0.0 MiB         257       for row in grid:
    32    137.7 MiB      0.0 MiB       65792           for spot in row:
    33    137.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.7 MiB      0.0 MiB           1       count = 0
    36    137.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.7 MiB      0.0 MiB           1       came_from = {}
    39    137.7 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.7 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.7 MiB      0.0 MiB        1160       while not open_set.empty():
    49    137.7 MiB      0.0 MiB        1160           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.7 MiB      0.0 MiB        1160           current = open_set.get()[2]
    55    137.7 MiB      0.0 MiB        1160           open_set_hash.remove(current)
    56                                         
    57    137.7 MiB      0.0 MiB        1160           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.7 MiB      0.0 MiB        1160           if current == end:
    62    137.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.7 MiB      0.0 MiB       10431           for neighbor in current.neighbors:
    67    137.7 MiB      0.0 MiB        9272               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.7 MiB      0.0 MiB        4636                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.7 MiB      0.0 MiB        4636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.7 MiB      0.0 MiB        9272               if temp_g_score < g_score[neighbor]:
    73    137.7 MiB      0.0 MiB        1354                   came_from[neighbor] = current
    74    137.7 MiB      0.0 MiB        1354                   g_score[neighbor] = temp_g_score
    75    137.7 MiB      0.0 MiB        1354                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.7 MiB      0.0 MiB        1354                   if neighbor not in open_set_hash:
    77    137.7 MiB      0.0 MiB        1354                       count += 1
    78    137.7 MiB      0.0 MiB        1354                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.7 MiB      0.0 MiB        1354                       open_set_hash.add(neighbor)
    80                                                             
    81    137.7 MiB      0.0 MiB        1159           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.7 MiB      0.0 MiB        1159           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    138.1 MiB    138.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    138.1 MiB      0.0 MiB         257       for row in grid:
    32    138.1 MiB      0.0 MiB       65792           for spot in row:
    33    138.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    138.1 MiB      0.0 MiB           1       count = 0
    36    138.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    138.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    138.1 MiB      0.0 MiB           1       came_from = {}
    39    138.1 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    138.1 MiB      0.0 MiB           1       g_score[start] = 0
    41    138.1 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    138.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    138.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    138.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    138.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    138.1 MiB      0.0 MiB         154       while not open_set.empty():
    49    138.1 MiB      0.0 MiB         154           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    138.1 MiB      0.0 MiB         154           current = open_set.get()[2]
    55    138.1 MiB      0.0 MiB         154           open_set_hash.remove(current)
    56                                         
    57    138.1 MiB      0.0 MiB         154           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    138.1 MiB      0.0 MiB         154           if current == end:
    62    138.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    138.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    138.1 MiB      0.0 MiB        1377           for neighbor in current.neighbors:
    67    138.1 MiB      0.0 MiB        1224               if current.row != neighbor.row and current.col != neighbor.col:
    68    138.1 MiB      0.0 MiB         612                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    138.1 MiB      0.0 MiB         612                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    138.1 MiB      0.0 MiB        1224               if temp_g_score < g_score[neighbor]:
    73    138.1 MiB      0.0 MiB         230                   came_from[neighbor] = current
    74    138.1 MiB      0.0 MiB         230                   g_score[neighbor] = temp_g_score
    75    138.1 MiB      0.0 MiB         230                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    138.1 MiB      0.0 MiB         230                   if neighbor not in open_set_hash:
    77    138.1 MiB      0.0 MiB         230                       count += 1
    78    138.1 MiB      0.0 MiB         230                       open_set.put((f_score[neighbor], count, neighbor))
    79    138.1 MiB      0.0 MiB         230                       open_set_hash.add(neighbor)
    80                                                             
    81    138.1 MiB      0.0 MiB         153           if draw is not None:
    82                                                     draw()
    83                                         
    84    138.1 MiB      0.0 MiB         153           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    138.1 MiB    138.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    138.1 MiB  -2678.8 MiB         257       for row in grid:
    32    138.1 MiB -687441.4 MiB       65792           for spot in row:
    33    138.1 MiB -684772.9 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    123.7 MiB    -14.4 MiB           1       count = 0
    36    123.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    123.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    123.7 MiB      0.0 MiB           1       came_from = {}
    39    123.7 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    123.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    124.6 MiB      0.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    124.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    124.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    124.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    124.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    124.6 MiB      0.0 MiB         121       while not open_set.empty():
    49    124.6 MiB      0.0 MiB         121           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    124.6 MiB      0.0 MiB         121           current = open_set.get()[2]
    55    124.6 MiB      0.0 MiB         121           open_set_hash.remove(current)
    56                                         
    57    124.6 MiB      0.0 MiB         121           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    124.6 MiB      0.0 MiB         121           if current == end:
    62    124.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    124.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    124.6 MiB      0.0 MiB        1080           for neighbor in current.neighbors:
    67    124.6 MiB      0.0 MiB         960               if current.row != neighbor.row and current.col != neighbor.col:
    68    124.6 MiB      0.0 MiB         480                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    124.6 MiB      0.0 MiB         480                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    124.6 MiB      0.0 MiB         960               if temp_g_score < g_score[neighbor]:
    73    124.6 MiB      0.0 MiB         185                   came_from[neighbor] = current
    74    124.6 MiB      0.0 MiB         185                   g_score[neighbor] = temp_g_score
    75    124.6 MiB      0.0 MiB         185                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    124.6 MiB      0.0 MiB         185                   if neighbor not in open_set_hash:
    77    124.6 MiB      0.0 MiB         185                       count += 1
    78    124.6 MiB      0.0 MiB         185                       open_set.put((f_score[neighbor], count, neighbor))
    79    124.6 MiB      0.0 MiB         185                       open_set_hash.add(neighbor)
    80                                                             
    81    124.6 MiB      0.0 MiB         120           if draw is not None:
    82                                                     draw()
    83                                         
    84    124.6 MiB      0.0 MiB         120           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    124.6 MiB    124.6 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    124.6 MiB      0.0 MiB         257       for row in grid:
    32    124.6 MiB      0.0 MiB       65792           for spot in row:
    33    124.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    124.6 MiB      0.0 MiB           1       count = 0
    36    124.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    124.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    124.6 MiB      0.0 MiB           1       came_from = {}
    39    126.0 MiB      1.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    126.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    127.0 MiB      1.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    127.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    127.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    127.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    127.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    127.0 MiB      0.0 MiB        4940       while not open_set.empty():
    49    127.0 MiB      0.0 MiB        4940           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    127.0 MiB      0.0 MiB        4940           current = open_set.get()[2]
    55    127.0 MiB      0.0 MiB        4940           open_set_hash.remove(current)
    56                                         
    57    127.0 MiB      0.0 MiB        4940           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    127.0 MiB      0.0 MiB        4940           if current == end:
    62    127.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    127.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    127.0 MiB      0.0 MiB       44451           for neighbor in current.neighbors:
    67    127.0 MiB      0.0 MiB       39512               if current.row != neighbor.row and current.col != neighbor.col:
    68    127.0 MiB      0.0 MiB       19756                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    127.0 MiB      0.0 MiB       19756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    127.0 MiB      0.0 MiB       39512               if temp_g_score < g_score[neighbor]:
    73    127.0 MiB      0.0 MiB        5534                   came_from[neighbor] = current
    74    127.0 MiB      0.0 MiB        5534                   g_score[neighbor] = temp_g_score
    75    127.0 MiB      0.0 MiB        5534                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    127.0 MiB      0.0 MiB        5534                   if neighbor not in open_set_hash:
    77    127.0 MiB      0.0 MiB        5534                       count += 1
    78    127.0 MiB      0.0 MiB        5534                       open_set.put((f_score[neighbor], count, neighbor))
    79    127.0 MiB      0.0 MiB        5534                       open_set_hash.add(neighbor)
    80                                                             
    81    127.0 MiB      0.0 MiB        4939           if draw is not None:
    82                                                     draw()
    83                                         
    84    127.0 MiB      0.0 MiB        4939           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    127.0 MiB    127.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    127.0 MiB      0.0 MiB         257       for row in grid:
    32    127.0 MiB      0.0 MiB       65792           for spot in row:
    33    127.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    127.0 MiB      0.0 MiB           1       count = 0
    36    127.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    127.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    127.0 MiB      0.0 MiB           1       came_from = {}
    39    127.5 MiB      0.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    127.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    127.5 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    127.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    127.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    127.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    127.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    127.5 MiB      0.0 MiB        4087       while not open_set.empty():
    49    127.5 MiB      0.0 MiB        4087           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    127.5 MiB      0.0 MiB        4087           current = open_set.get()[2]
    55    127.5 MiB      0.0 MiB        4087           open_set_hash.remove(current)
    56                                         
    57    127.5 MiB      0.0 MiB        4087           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    127.5 MiB      0.0 MiB        4087           if current == end:
    62    127.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    127.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    127.5 MiB      0.0 MiB       36774           for neighbor in current.neighbors:
    67    127.5 MiB      0.0 MiB       32688               if current.row != neighbor.row and current.col != neighbor.col:
    68    127.5 MiB      0.0 MiB       16344                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    127.5 MiB      0.0 MiB       16344                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    127.5 MiB      0.0 MiB       32688               if temp_g_score < g_score[neighbor]:
    73    127.5 MiB      0.0 MiB        4463                   came_from[neighbor] = current
    74    127.5 MiB      0.0 MiB        4463                   g_score[neighbor] = temp_g_score
    75    127.5 MiB      0.0 MiB        4463                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    127.5 MiB      0.0 MiB        4463                   if neighbor not in open_set_hash:
    77    127.5 MiB      0.0 MiB        4463                       count += 1
    78    127.5 MiB      0.0 MiB        4463                       open_set.put((f_score[neighbor], count, neighbor))
    79    127.5 MiB      0.0 MiB        4463                       open_set_hash.add(neighbor)
    80                                                             
    81    127.5 MiB      0.0 MiB        4086           if draw is not None:
    82                                                     draw()
    83                                         
    84    127.5 MiB      0.0 MiB        4086           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    127.5 MiB    127.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    127.5 MiB      0.0 MiB         257       for row in grid:
    32    127.5 MiB      0.0 MiB       65792           for spot in row:
    33    127.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    127.5 MiB      0.0 MiB           1       count = 0
    36    127.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    127.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    127.5 MiB      0.0 MiB           1       came_from = {}
    39    127.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    127.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    128.2 MiB      0.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    128.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    128.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    128.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46    128.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    128.2 MiB      0.0 MiB        2001       while not open_set.empty():
    49    128.2 MiB      0.0 MiB        2001           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    128.2 MiB      0.0 MiB        2001           current = open_set.get()[2]
    55    128.2 MiB      0.0 MiB        2001           open_set_hash.remove(current)
    56                                         
    57    128.2 MiB      0.0 MiB        2001           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    128.2 MiB      0.0 MiB        2001           if current == end:
    62    128.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    128.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    128.2 MiB      0.0 MiB       18000           for neighbor in current.neighbors:
    67    128.2 MiB      0.0 MiB       16000               if current.row != neighbor.row and current.col != neighbor.col:
    68    128.2 MiB      0.0 MiB        8000                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    128.2 MiB      0.0 MiB        8000                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    128.2 MiB      0.0 MiB       16000               if temp_g_score < g_score[neighbor]:
    73    128.2 MiB      0.0 MiB        2253                   came_from[neighbor] = current
    74    128.2 MiB      0.0 MiB        2253                   g_score[neighbor] = temp_g_score
    75    128.2 MiB      0.0 MiB        2253                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    128.2 MiB      0.0 MiB        2253                   if neighbor not in open_set_hash:
    77    128.2 MiB      0.0 MiB        2253                       count += 1
    78    128.2 MiB      0.0 MiB        2253                       open_set.put((f_score[neighbor], count, neighbor))
    79    128.2 MiB      0.0 MiB        2253                       open_set_hash.add(neighbor)
    80                                                             
    81    128.2 MiB      0.0 MiB        2000           if draw is not None:
    82                                                     draw()
    83                                         
    84    128.2 MiB      0.0 MiB        2000           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    128.2 MiB    128.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    128.2 MiB      0.0 MiB         257       for row in grid:
    32    128.2 MiB      0.0 MiB       65792           for spot in row:
    33    128.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    128.2 MiB      0.0 MiB           1       count = 0
    36    128.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    128.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    128.2 MiB      0.0 MiB           1       came_from = {}
    39    129.4 MiB      1.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    129.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    129.4 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    129.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    129.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    129.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    129.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    129.4 MiB      0.0 MiB        7396       while not open_set.empty():
    49    129.4 MiB      0.0 MiB        7396           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    129.4 MiB      0.0 MiB        7396           current = open_set.get()[2]
    55    129.4 MiB      0.0 MiB        7396           open_set_hash.remove(current)
    56                                         
    57    129.4 MiB      0.0 MiB        7396           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    129.4 MiB      0.0 MiB        7396           if current == end:
    62    129.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    129.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    129.4 MiB      0.0 MiB       66555           for neighbor in current.neighbors:
    67    129.4 MiB      0.0 MiB       59160               if current.row != neighbor.row and current.col != neighbor.col:
    68    129.4 MiB      0.0 MiB       29580                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    129.4 MiB      0.0 MiB       29580                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    129.4 MiB      0.0 MiB       59160               if temp_g_score < g_score[neighbor]:
    73    129.4 MiB      0.0 MiB        7910                   came_from[neighbor] = current
    74    129.4 MiB      0.0 MiB        7910                   g_score[neighbor] = temp_g_score
    75    129.4 MiB      0.0 MiB        7910                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    129.4 MiB      0.0 MiB        7910                   if neighbor not in open_set_hash:
    77    129.4 MiB      0.0 MiB        7910                       count += 1
    78    129.4 MiB      0.0 MiB        7910                       open_set.put((f_score[neighbor], count, neighbor))
    79    129.4 MiB      0.0 MiB        7910                       open_set_hash.add(neighbor)
    80                                                             
    81    129.4 MiB      0.0 MiB        7395           if draw is not None:
    82                                                     draw()
    83                                         
    84    129.4 MiB      0.0 MiB        7395           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    129.4 MiB    129.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    129.4 MiB      0.0 MiB         257       for row in grid:
    32    129.4 MiB      0.0 MiB       65792           for spot in row:
    33    129.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    129.4 MiB      0.0 MiB           1       count = 0
    36    129.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    129.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    129.4 MiB      0.0 MiB           1       came_from = {}
    39    129.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    129.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    129.4 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    129.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    129.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    129.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    129.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    129.4 MiB      0.0 MiB         900       while not open_set.empty():
    49    129.4 MiB      0.0 MiB         900           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    129.4 MiB      0.0 MiB         900           current = open_set.get()[2]
    55    129.4 MiB      0.0 MiB         900           open_set_hash.remove(current)
    56                                         
    57    129.4 MiB      0.0 MiB         900           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    129.4 MiB      0.0 MiB         900           if current == end:
    62    129.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    129.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    129.4 MiB      0.0 MiB        8091           for neighbor in current.neighbors:
    67    129.4 MiB      0.0 MiB        7192               if current.row != neighbor.row and current.col != neighbor.col:
    68    129.4 MiB      0.0 MiB        3596                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    129.4 MiB      0.0 MiB        3596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    129.4 MiB      0.0 MiB        7192               if temp_g_score < g_score[neighbor]:
    73    129.4 MiB      0.0 MiB        1222                   came_from[neighbor] = current
    74    129.4 MiB      0.0 MiB        1222                   g_score[neighbor] = temp_g_score
    75    129.4 MiB      0.0 MiB        1222                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    129.4 MiB      0.0 MiB        1222                   if neighbor not in open_set_hash:
    77    129.4 MiB      0.0 MiB        1222                       count += 1
    78    129.4 MiB      0.0 MiB        1222                       open_set.put((f_score[neighbor], count, neighbor))
    79    129.4 MiB      0.0 MiB        1222                       open_set_hash.add(neighbor)
    80                                                             
    81    129.4 MiB      0.0 MiB         899           if draw is not None:
    82                                                     draw()
    83                                         
    84    129.4 MiB      0.0 MiB         899           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    129.4 MiB    129.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    129.4 MiB      0.0 MiB         257       for row in grid:
    32    129.4 MiB      0.0 MiB       65792           for spot in row:
    33    129.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    129.4 MiB      0.0 MiB           1       count = 0
    36    129.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    129.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    129.4 MiB      0.0 MiB           1       came_from = {}
    39    129.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    129.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    129.4 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    129.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    129.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    129.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    129.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    129.4 MiB      0.0 MiB        3168       while not open_set.empty():
    49    129.4 MiB      0.0 MiB        3168           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    129.4 MiB      0.0 MiB        3168           current = open_set.get()[2]
    55    129.4 MiB      0.0 MiB        3168           open_set_hash.remove(current)
    56                                         
    57    129.4 MiB      0.0 MiB        3168           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    129.4 MiB      0.0 MiB        3168           if current == end:
    62    129.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    129.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    129.4 MiB      0.0 MiB       28503           for neighbor in current.neighbors:
    67    129.4 MiB      0.0 MiB       25336               if current.row != neighbor.row and current.col != neighbor.col:
    68    129.4 MiB      0.0 MiB       12668                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    129.4 MiB      0.0 MiB       12668                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    129.4 MiB      0.0 MiB       25336               if temp_g_score < g_score[neighbor]:
    73    129.4 MiB      0.0 MiB        3490                   came_from[neighbor] = current
    74    129.4 MiB      0.0 MiB        3490                   g_score[neighbor] = temp_g_score
    75    129.4 MiB      0.0 MiB        3490                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    129.4 MiB      0.0 MiB        3490                   if neighbor not in open_set_hash:
    77    129.4 MiB      0.0 MiB        3490                       count += 1
    78    129.4 MiB      0.0 MiB        3490                       open_set.put((f_score[neighbor], count, neighbor))
    79    129.4 MiB      0.0 MiB        3490                       open_set_hash.add(neighbor)
    80                                                             
    81    129.4 MiB      0.0 MiB        3167           if draw is not None:
    82                                                     draw()
    83                                         
    84    129.4 MiB      0.0 MiB        3167           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    129.4 MiB    129.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    129.4 MiB      0.0 MiB         257       for row in grid:
    32    129.4 MiB      0.0 MiB       65792           for spot in row:
    33    129.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    129.4 MiB      0.0 MiB           1       count = 0
    36    129.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    129.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    129.4 MiB      0.0 MiB           1       came_from = {}
    39    129.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    129.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    129.4 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    129.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    129.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    129.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    129.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    129.4 MiB      0.0 MiB         646       while not open_set.empty():
    49    129.4 MiB      0.0 MiB         646           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    129.4 MiB      0.0 MiB         646           current = open_set.get()[2]
    55    129.4 MiB      0.0 MiB         646           open_set_hash.remove(current)
    56                                         
    57    129.4 MiB      0.0 MiB         646           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    129.4 MiB      0.0 MiB         646           if current == end:
    62    129.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    129.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    129.4 MiB      0.0 MiB        5805           for neighbor in current.neighbors:
    67    129.4 MiB      0.0 MiB        5160               if current.row != neighbor.row and current.col != neighbor.col:
    68    129.4 MiB      0.0 MiB        2580                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    129.4 MiB      0.0 MiB        2580                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    129.4 MiB      0.0 MiB        5160               if temp_g_score < g_score[neighbor]:
    73    129.4 MiB      0.0 MiB         788                   came_from[neighbor] = current
    74    129.4 MiB      0.0 MiB         788                   g_score[neighbor] = temp_g_score
    75    129.4 MiB      0.0 MiB         788                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    129.4 MiB      0.0 MiB         788                   if neighbor not in open_set_hash:
    77    129.4 MiB      0.0 MiB         788                       count += 1
    78    129.4 MiB      0.0 MiB         788                       open_set.put((f_score[neighbor], count, neighbor))
    79    129.4 MiB      0.0 MiB         788                       open_set_hash.add(neighbor)
    80                                                             
    81    129.4 MiB      0.0 MiB         645           if draw is not None:
    82                                                     draw()
    83                                         
    84    129.4 MiB      0.0 MiB         645           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    129.4 MiB    129.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    129.4 MiB      0.0 MiB         257       for row in grid:
    32    129.4 MiB      0.0 MiB       65792           for spot in row:
    33    129.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    129.4 MiB      0.0 MiB           1       count = 0
    36    129.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    129.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    129.4 MiB      0.0 MiB           1       came_from = {}
    39    129.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    129.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    129.4 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    129.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    129.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    129.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    129.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    129.4 MiB      0.0 MiB          98       while not open_set.empty():
    49    129.4 MiB      0.0 MiB          98           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    129.4 MiB      0.0 MiB          98           current = open_set.get()[2]
    55    129.4 MiB      0.0 MiB          98           open_set_hash.remove(current)
    56                                         
    57    129.4 MiB      0.0 MiB          98           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    129.4 MiB      0.0 MiB          98           if current == end:
    62    129.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    129.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    129.4 MiB      0.0 MiB         873           for neighbor in current.neighbors:
    67    129.4 MiB      0.0 MiB         776               if current.row != neighbor.row and current.col != neighbor.col:
    68    129.4 MiB      0.0 MiB         388                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    129.4 MiB      0.0 MiB         388                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    129.4 MiB      0.0 MiB         776               if temp_g_score < g_score[neighbor]:
    73    129.4 MiB      0.0 MiB         296                   came_from[neighbor] = current
    74    129.4 MiB      0.0 MiB         296                   g_score[neighbor] = temp_g_score
    75    129.4 MiB      0.0 MiB         296                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    129.4 MiB      0.0 MiB         296                   if neighbor not in open_set_hash:
    77    129.4 MiB      0.0 MiB         296                       count += 1
    78    129.4 MiB      0.0 MiB         296                       open_set.put((f_score[neighbor], count, neighbor))
    79    129.4 MiB      0.0 MiB         296                       open_set_hash.add(neighbor)
    80                                                             
    81    129.4 MiB      0.0 MiB          97           if draw is not None:
    82                                                     draw()
    83                                         
    84    129.4 MiB      0.0 MiB          97           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    129.4 MiB    129.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    129.4 MiB      0.0 MiB         257       for row in grid:
    32    129.4 MiB      0.0 MiB       65792           for spot in row:
    33    129.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    129.4 MiB      0.0 MiB           1       count = 0
    36    129.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    129.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    129.4 MiB      0.0 MiB           1       came_from = {}
    39    129.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    129.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    129.4 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    129.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    129.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    129.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    129.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    129.4 MiB      0.0 MiB         975       while not open_set.empty():
    49    129.4 MiB      0.0 MiB         975           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    129.4 MiB      0.0 MiB         975           current = open_set.get()[2]
    55    129.4 MiB      0.0 MiB         975           open_set_hash.remove(current)
    56                                         
    57    129.4 MiB      0.0 MiB         975           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    129.4 MiB      0.0 MiB         975           if current == end:
    62    129.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    129.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    129.4 MiB      0.0 MiB        8766           for neighbor in current.neighbors:
    67    129.4 MiB      0.0 MiB        7792               if current.row != neighbor.row and current.col != neighbor.col:
    68    129.4 MiB      0.0 MiB        3896                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    129.4 MiB      0.0 MiB        3896                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    129.4 MiB      0.0 MiB        7792               if temp_g_score < g_score[neighbor]:
    73    129.4 MiB      0.0 MiB        1175                   came_from[neighbor] = current
    74    129.4 MiB      0.0 MiB        1175                   g_score[neighbor] = temp_g_score
    75    129.4 MiB      0.0 MiB        1175                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    129.4 MiB      0.0 MiB        1175                   if neighbor not in open_set_hash:
    77    129.4 MiB      0.0 MiB        1175                       count += 1
    78    129.4 MiB      0.0 MiB        1175                       open_set.put((f_score[neighbor], count, neighbor))
    79    129.4 MiB      0.0 MiB        1175                       open_set_hash.add(neighbor)
    80                                                             
    81    129.4 MiB      0.0 MiB         974           if draw is not None:
    82                                                     draw()
    83                                         
    84    129.4 MiB      0.0 MiB         974           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    129.4 MiB    129.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    129.4 MiB  -1250.3 MiB         257       for row in grid:
    32    129.4 MiB -320582.1 MiB       65792           for spot in row:
    33    129.4 MiB -319336.2 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    123.0 MiB     -6.4 MiB           1       count = 0
    36    123.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    123.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    123.0 MiB      0.0 MiB           1       came_from = {}
    39    123.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    123.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    125.0 MiB      2.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    125.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    125.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    125.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    125.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    125.0 MiB      0.0 MiB        4577       while not open_set.empty():
    49    125.0 MiB      0.0 MiB        4577           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    125.0 MiB      0.0 MiB        4577           current = open_set.get()[2]
    55    125.0 MiB      0.0 MiB        4577           open_set_hash.remove(current)
    56                                         
    57    125.0 MiB      0.0 MiB        4577           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    125.0 MiB      0.0 MiB        4577           if current == end:
    62    125.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    125.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    125.0 MiB      0.0 MiB       41184           for neighbor in current.neighbors:
    67    125.0 MiB      0.0 MiB       36608               if current.row != neighbor.row and current.col != neighbor.col:
    68    125.0 MiB      0.0 MiB       18304                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    125.0 MiB      0.0 MiB       18304                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    125.0 MiB      0.0 MiB       36608               if temp_g_score < g_score[neighbor]:
    73    125.0 MiB      0.0 MiB        5417                   came_from[neighbor] = current
    74    125.0 MiB      0.0 MiB        5417                   g_score[neighbor] = temp_g_score
    75    125.0 MiB      0.0 MiB        5417                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    125.0 MiB      0.0 MiB        5417                   if neighbor not in open_set_hash:
    77    125.0 MiB      0.0 MiB        5417                       count += 1
    78    125.0 MiB      0.0 MiB        5417                       open_set.put((f_score[neighbor], count, neighbor))
    79    125.0 MiB      0.0 MiB        5417                       open_set_hash.add(neighbor)
    80                                                             
    81    125.0 MiB      0.0 MiB        4576           if draw is not None:
    82                                                     draw()
    83                                         
    84    125.0 MiB      0.0 MiB        4576           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    125.1 MiB    125.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    125.1 MiB      0.0 MiB         257       for row in grid:
    32    125.1 MiB      0.0 MiB       65792           for spot in row:
    33    125.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    125.1 MiB      0.0 MiB           1       count = 0
    36    125.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    125.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    125.1 MiB      0.0 MiB           1       came_from = {}
    39    125.7 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    125.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    127.1 MiB      1.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    127.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    127.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    127.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    127.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    127.3 MiB      0.0 MiB        3332       while not open_set.empty():
    49    127.3 MiB      0.0 MiB        3332           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    127.3 MiB      0.0 MiB        3332           current = open_set.get()[2]
    55    127.3 MiB      0.0 MiB        3332           open_set_hash.remove(current)
    56                                         
    57    127.3 MiB      0.0 MiB        3332           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    127.3 MiB      0.0 MiB        3332           if current == end:
    62    127.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    127.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    127.3 MiB      0.0 MiB       29979           for neighbor in current.neighbors:
    67    127.3 MiB      0.0 MiB       26648               if current.row != neighbor.row and current.col != neighbor.col:
    68    127.3 MiB      0.0 MiB       13324                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    127.3 MiB      0.0 MiB       13324                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    127.3 MiB      0.0 MiB       26648               if temp_g_score < g_score[neighbor]:
    73    127.3 MiB      0.2 MiB        3862                   came_from[neighbor] = current
    74    127.3 MiB      0.0 MiB        3862                   g_score[neighbor] = temp_g_score
    75    127.3 MiB      0.0 MiB        3862                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    127.3 MiB      0.0 MiB        3862                   if neighbor not in open_set_hash:
    77    127.3 MiB      0.0 MiB        3862                       count += 1
    78    127.3 MiB      0.0 MiB        3862                       open_set.put((f_score[neighbor], count, neighbor))
    79    127.3 MiB      0.0 MiB        3862                       open_set_hash.add(neighbor)
    80                                                             
    81    127.3 MiB      0.0 MiB        3331           if draw is not None:
    82                                                     draw()
    83                                         
    84    127.3 MiB      0.0 MiB        3331           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    127.4 MiB    127.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    127.4 MiB    -39.2 MiB         257       for row in grid:
    32    127.4 MiB -10071.0 MiB       65792           for spot in row:
    33    127.4 MiB -10031.8 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    127.2 MiB     -0.2 MiB           1       count = 0
    36    127.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    127.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    127.2 MiB      0.0 MiB           1       came_from = {}
    39    127.5 MiB      0.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    127.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    129.0 MiB      1.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    129.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    129.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    129.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    129.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    129.0 MiB      0.0 MiB         159       while not open_set.empty():
    49    129.0 MiB      0.0 MiB         159           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    129.0 MiB      0.0 MiB         159           current = open_set.get()[2]
    55    129.0 MiB      0.0 MiB         159           open_set_hash.remove(current)
    56                                         
    57    129.0 MiB      0.0 MiB         159           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    129.0 MiB      0.0 MiB         159           if current == end:
    62    129.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    129.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    129.0 MiB      0.0 MiB        1422           for neighbor in current.neighbors:
    67    129.0 MiB      0.0 MiB        1264               if current.row != neighbor.row and current.col != neighbor.col:
    68    129.0 MiB      0.0 MiB         632                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    129.0 MiB      0.0 MiB         632                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    129.0 MiB      0.0 MiB        1264               if temp_g_score < g_score[neighbor]:
    73    129.0 MiB      0.0 MiB         275                   came_from[neighbor] = current
    74    129.0 MiB      0.0 MiB         275                   g_score[neighbor] = temp_g_score
    75    129.0 MiB      0.0 MiB         275                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    129.0 MiB      0.0 MiB         275                   if neighbor not in open_set_hash:
    77    129.0 MiB      0.0 MiB         275                       count += 1
    78    129.0 MiB      0.0 MiB         275                       open_set.put((f_score[neighbor], count, neighbor))
    79    129.0 MiB      0.0 MiB         275                       open_set_hash.add(neighbor)
    80                                                             
    81    129.0 MiB      0.0 MiB         158           if draw is not None:
    82                                                     draw()
    83                                         
    84    129.0 MiB      0.0 MiB         158           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    129.0 MiB    129.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    129.0 MiB      0.0 MiB         257       for row in grid:
    32    129.0 MiB      0.0 MiB       65792           for spot in row:
    33    129.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    129.0 MiB      0.0 MiB           1       count = 0
    36    129.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    129.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    129.0 MiB      0.0 MiB           1       came_from = {}
    39    129.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    129.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    129.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    129.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    129.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    129.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    129.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    129.0 MiB      0.0 MiB        5073       while not open_set.empty():
    49    129.0 MiB      0.0 MiB        5073           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    129.0 MiB      0.0 MiB        5073           current = open_set.get()[2]
    55    129.0 MiB      0.0 MiB        5073           open_set_hash.remove(current)
    56                                         
    57    129.0 MiB      0.0 MiB        5073           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    129.0 MiB      0.0 MiB        5073           if current == end:
    62    129.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    129.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    129.0 MiB      0.0 MiB       45648           for neighbor in current.neighbors:
    67    129.0 MiB      0.0 MiB       40576               if current.row != neighbor.row and current.col != neighbor.col:
    68    129.0 MiB      0.0 MiB       20288                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    129.0 MiB      0.0 MiB       20288                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    129.0 MiB      0.0 MiB       40576               if temp_g_score < g_score[neighbor]:
    73    129.0 MiB      0.0 MiB        5541                   came_from[neighbor] = current
    74    129.0 MiB      0.0 MiB        5541                   g_score[neighbor] = temp_g_score
    75    129.0 MiB      0.0 MiB        5541                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    129.0 MiB      0.0 MiB        5541                   if neighbor not in open_set_hash:
    77    129.0 MiB      0.0 MiB        5541                       count += 1
    78    129.0 MiB      0.0 MiB        5541                       open_set.put((f_score[neighbor], count, neighbor))
    79    129.0 MiB      0.0 MiB        5541                       open_set_hash.add(neighbor)
    80                                                             
    81    129.0 MiB      0.0 MiB        5072           if draw is not None:
    82                                                     draw()
    83                                         
    84    129.0 MiB      0.0 MiB        5072           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    129.0 MiB    129.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    129.0 MiB      0.0 MiB         257       for row in grid:
    32    129.0 MiB      0.0 MiB       65792           for spot in row:
    33    129.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    129.0 MiB      0.0 MiB           1       count = 0
    36    129.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    129.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    129.0 MiB      0.0 MiB           1       came_from = {}
    39    129.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    129.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    132.6 MiB      3.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    132.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    132.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    132.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    132.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    132.6 MiB      0.0 MiB         459       while not open_set.empty():
    49    132.6 MiB      0.0 MiB         459           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    132.6 MiB      0.0 MiB         459           current = open_set.get()[2]
    55    132.6 MiB      0.0 MiB         459           open_set_hash.remove(current)
    56                                         
    57    132.6 MiB      0.0 MiB         459           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    132.6 MiB      0.0 MiB         459           if current == end:
    62    132.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    132.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    132.6 MiB      0.0 MiB        4122           for neighbor in current.neighbors:
    67    132.6 MiB      0.0 MiB        3664               if current.row != neighbor.row and current.col != neighbor.col:
    68    132.6 MiB      0.0 MiB        1832                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    132.6 MiB      0.0 MiB        1832                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    132.6 MiB      0.0 MiB        3664               if temp_g_score < g_score[neighbor]:
    73    132.6 MiB      0.0 MiB         599                   came_from[neighbor] = current
    74    132.6 MiB      0.0 MiB         599                   g_score[neighbor] = temp_g_score
    75    132.6 MiB      0.0 MiB         599                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    132.6 MiB      0.0 MiB         599                   if neighbor not in open_set_hash:
    77    132.6 MiB      0.0 MiB         599                       count += 1
    78    132.6 MiB      0.0 MiB         599                       open_set.put((f_score[neighbor], count, neighbor))
    79    132.6 MiB      0.0 MiB         599                       open_set_hash.add(neighbor)
    80                                                             
    81    132.6 MiB      0.0 MiB         458           if draw is not None:
    82                                                     draw()
    83                                         
    84    132.6 MiB      0.0 MiB         458           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    132.6 MiB    132.6 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    132.6 MiB      0.0 MiB         257       for row in grid:
    32    132.6 MiB      0.0 MiB       65792           for spot in row:
    33    132.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    132.6 MiB      0.0 MiB           1       count = 0
    36    132.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    132.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    132.6 MiB      0.0 MiB           1       came_from = {}
    39    132.9 MiB      0.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    132.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    132.9 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    132.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    132.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    132.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    132.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    132.9 MiB      0.0 MiB        6355       while not open_set.empty():
    49    132.9 MiB      0.0 MiB        6355           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    132.9 MiB      0.0 MiB        6355           current = open_set.get()[2]
    55    132.9 MiB      0.0 MiB        6355           open_set_hash.remove(current)
    56                                         
    57    132.9 MiB      0.0 MiB        6355           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    132.9 MiB      0.0 MiB        6355           if current == end:
    62    132.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    132.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    132.9 MiB      0.0 MiB       57186           for neighbor in current.neighbors:
    67    132.9 MiB      0.0 MiB       50832               if current.row != neighbor.row and current.col != neighbor.col:
    68    132.9 MiB      0.0 MiB       25416                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    132.9 MiB      0.0 MiB       25416                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    132.9 MiB      0.0 MiB       50832               if temp_g_score < g_score[neighbor]:
    73    132.9 MiB      0.0 MiB        6827                   came_from[neighbor] = current
    74    132.9 MiB      0.0 MiB        6827                   g_score[neighbor] = temp_g_score
    75    132.9 MiB      0.0 MiB        6827                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    132.9 MiB      0.0 MiB        6827                   if neighbor not in open_set_hash:
    77    132.9 MiB      0.0 MiB        6827                       count += 1
    78    132.9 MiB      0.0 MiB        6827                       open_set.put((f_score[neighbor], count, neighbor))
    79    132.9 MiB      0.0 MiB        6827                       open_set_hash.add(neighbor)
    80                                                             
    81    132.9 MiB      0.0 MiB        6354           if draw is not None:
    82                                                     draw()
    83                                         
    84    132.9 MiB      0.0 MiB        6354           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    132.9 MiB    132.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    132.9 MiB      0.0 MiB         257       for row in grid:
    32    132.9 MiB      0.0 MiB       65792           for spot in row:
    33    132.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    132.9 MiB      0.0 MiB           1       count = 0
    36    132.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    132.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    132.9 MiB      0.0 MiB           1       came_from = {}
    39    132.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    132.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    132.9 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    132.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    132.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    132.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    132.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    132.9 MiB      0.0 MiB         950       while not open_set.empty():
    49    132.9 MiB      0.0 MiB         950           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    132.9 MiB      0.0 MiB         950           current = open_set.get()[2]
    55    132.9 MiB      0.0 MiB         950           open_set_hash.remove(current)
    56                                         
    57    132.9 MiB      0.0 MiB         950           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    132.9 MiB      0.0 MiB         950           if current == end:
    62    132.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    132.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    132.9 MiB      0.0 MiB        8541           for neighbor in current.neighbors:
    67    132.9 MiB      0.0 MiB        7592               if current.row != neighbor.row and current.col != neighbor.col:
    68    132.9 MiB      0.0 MiB        3796                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    132.9 MiB      0.0 MiB        3796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    132.9 MiB      0.0 MiB        7592               if temp_g_score < g_score[neighbor]:
    73    132.9 MiB      0.0 MiB        1186                   came_from[neighbor] = current
    74    132.9 MiB      0.0 MiB        1186                   g_score[neighbor] = temp_g_score
    75    132.9 MiB      0.0 MiB        1186                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    132.9 MiB      0.0 MiB        1186                   if neighbor not in open_set_hash:
    77    132.9 MiB      0.0 MiB        1186                       count += 1
    78    132.9 MiB      0.0 MiB        1186                       open_set.put((f_score[neighbor], count, neighbor))
    79    132.9 MiB      0.0 MiB        1186                       open_set_hash.add(neighbor)
    80                                                             
    81    132.9 MiB      0.0 MiB         949           if draw is not None:
    82                                                     draw()
    83                                         
    84    132.9 MiB      0.0 MiB         949           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    132.9 MiB    132.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    132.9 MiB      0.0 MiB         257       for row in grid:
    32    132.9 MiB      0.0 MiB       65792           for spot in row:
    33    132.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    132.9 MiB      0.0 MiB           1       count = 0
    36    132.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    132.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    132.9 MiB      0.0 MiB           1       came_from = {}
    39    132.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    132.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    132.9 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    132.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    132.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    132.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    132.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    132.9 MiB      0.0 MiB        4750       while not open_set.empty():
    49    132.9 MiB      0.0 MiB        4750           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    132.9 MiB      0.0 MiB        4750           current = open_set.get()[2]
    55    132.9 MiB      0.0 MiB        4750           open_set_hash.remove(current)
    56                                         
    57    132.9 MiB      0.0 MiB        4750           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    132.9 MiB      0.0 MiB        4750           if current == end:
    62    132.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    132.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    132.9 MiB      0.0 MiB       42741           for neighbor in current.neighbors:
    67    132.9 MiB      0.0 MiB       37992               if current.row != neighbor.row and current.col != neighbor.col:
    68    132.9 MiB      0.0 MiB       18996                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    132.9 MiB      0.0 MiB       18996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    132.9 MiB      0.0 MiB       37992               if temp_g_score < g_score[neighbor]:
    73    132.9 MiB      0.0 MiB        5324                   came_from[neighbor] = current
    74    132.9 MiB      0.0 MiB        5324                   g_score[neighbor] = temp_g_score
    75    132.9 MiB      0.0 MiB        5324                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    132.9 MiB      0.0 MiB        5324                   if neighbor not in open_set_hash:
    77    132.9 MiB      0.0 MiB        5324                       count += 1
    78    132.9 MiB      0.0 MiB        5324                       open_set.put((f_score[neighbor], count, neighbor))
    79    132.9 MiB      0.0 MiB        5324                       open_set_hash.add(neighbor)
    80                                                             
    81    132.9 MiB      0.0 MiB        4749           if draw is not None:
    82                                                     draw()
    83                                         
    84    132.9 MiB      0.0 MiB        4749           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    132.9 MiB    132.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    132.9 MiB      0.0 MiB         257       for row in grid:
    32    132.9 MiB      0.0 MiB       65792           for spot in row:
    33    132.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    132.9 MiB      0.0 MiB           1       count = 0
    36    132.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    132.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    132.9 MiB      0.0 MiB           1       came_from = {}
    39    133.2 MiB      0.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    133.2 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.5 MiB      2.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.5 MiB      0.0 MiB         360       while not open_set.empty():
    49    135.5 MiB      0.0 MiB         360           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.5 MiB      0.0 MiB         360           current = open_set.get()[2]
    55    135.5 MiB      0.0 MiB         360           open_set_hash.remove(current)
    56                                         
    57    135.5 MiB      0.0 MiB         360           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.5 MiB      0.0 MiB         360           if current == end:
    62    135.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.5 MiB      0.0 MiB        3231           for neighbor in current.neighbors:
    67    135.5 MiB      0.0 MiB        2872               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.5 MiB      0.0 MiB        1436                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.5 MiB      0.0 MiB        1436                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.5 MiB      0.0 MiB        2872               if temp_g_score < g_score[neighbor]:
    73    135.5 MiB      0.0 MiB         502                   came_from[neighbor] = current
    74    135.5 MiB      0.0 MiB         502                   g_score[neighbor] = temp_g_score
    75    135.5 MiB      0.0 MiB         502                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.5 MiB      0.0 MiB         502                   if neighbor not in open_set_hash:
    77    135.5 MiB      0.0 MiB         502                       count += 1
    78    135.5 MiB      0.0 MiB         502                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.5 MiB      0.0 MiB         502                       open_set_hash.add(neighbor)
    80                                                             
    81    135.5 MiB      0.0 MiB         359           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.5 MiB      0.0 MiB         359           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.5 MiB    135.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.5 MiB      0.0 MiB         257       for row in grid:
    32    135.5 MiB      0.0 MiB       65792           for spot in row:
    33    135.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.5 MiB      0.0 MiB           1       count = 0
    36    135.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.5 MiB      0.0 MiB           1       came_from = {}
    39    135.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB       10201       while not open_set.empty():
    49    135.8 MiB      0.0 MiB       10201           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB       10201           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB       10201           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB       10201           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB       10201           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB       91800           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB       81600               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB       40800                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB       40800                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB       81600               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB       10805                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB       10805                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB       10805                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB       10805                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB       10805                       count += 1
    78    135.8 MiB      0.0 MiB       10805                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB       10805                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB       10200           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB       10200           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB        1740       while not open_set.empty():
    49    135.8 MiB      0.0 MiB        1740           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB        1740           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB        1740           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB        1740           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB        1740           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB       15651           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB       13912               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB        6956                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB        6956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB       13912               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB        2076                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB        2076                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB        2076                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB        2076                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB        2076                       count += 1
    78    135.8 MiB      0.0 MiB        2076                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB        2076                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB        1739           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB        1739           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB        1710       while not open_set.empty():
    49    135.8 MiB      0.0 MiB        1710           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB        1710           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB        1710           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB        1710           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB        1710           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB       15381           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB       13672               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB        6836                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB        6836                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB       13672               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB        2106                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB        2106                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB        2106                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB        2106                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB        2106                       count += 1
    78    135.8 MiB      0.0 MiB        2106                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB        2106                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB        1709           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB        1709           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB         882       while not open_set.empty():
    49    135.8 MiB      0.0 MiB         882           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB         882           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB         882           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB         882           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB         882           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB        7929           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB        7048               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB        3524                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB        3524                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB        7048               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB        1398                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB        1398                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB        1398                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB        1398                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB        1398                       count += 1
    78    135.8 MiB      0.0 MiB        1398                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB        1398                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB         881           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB         881           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB        7776       while not open_set.empty():
    49    135.8 MiB      0.0 MiB        7776           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB        7776           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB        7776           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB        7776           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB        7776           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB       69975           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB       62200               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB       31100                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB       31100                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB       62200               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB        8278                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB        8278                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB        8278                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB        8278                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB        8278                       count += 1
    78    135.8 MiB      0.0 MiB        8278                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB        8278                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB        7775           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB        7775           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB         216       while not open_set.empty():
    49    135.8 MiB      0.0 MiB         216           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB         216           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB         216           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB         216           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB         216           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB        1935           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB        1720               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB         860                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB         860                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB        1720               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB         508                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB         508                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB         508                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB         508                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB         508                       count += 1
    78    135.8 MiB      0.0 MiB         508                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB         508                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB         215           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB         215           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB        1975       while not open_set.empty():
    49    135.8 MiB      0.0 MiB        1975           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB        1975           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB        1975           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB        1975           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB        1975           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB       17766           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB       15792               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB        7896                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB        7896                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB       15792               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB        2231                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB        2231                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB        2231                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB        2231                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB        2231                       count += 1
    78    135.8 MiB      0.0 MiB        2231                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB        2231                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB        1974           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB        1974           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB        1323       while not open_set.empty():
    49    135.8 MiB      0.0 MiB        1323           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB        1323           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB        1323           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB        1323           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB        1323           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB       11898           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB       10576               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB        5288                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB        5288                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB       10576               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB        1527                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB        1527                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB        1527                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB        1527                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB        1527                       count += 1
    78    135.8 MiB      0.0 MiB        1527                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB        1527                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB        1322           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB        1322           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB        1340       while not open_set.empty():
    49    135.8 MiB      0.0 MiB        1340           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB        1340           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB        1340           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB        1340           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB        1340           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB       12051           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB       10712               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB        5356                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB        5356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB       10712               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB        1646                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB        1646                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB        1646                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB        1646                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB        1646                       count += 1
    78    135.8 MiB      0.0 MiB        1646                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB        1646                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB        1339           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB        1339           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB        2862       while not open_set.empty():
    49    135.8 MiB      0.0 MiB        2862           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB        2862           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB        2862           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB        2862           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB        2862           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB       25749           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB       22888               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB       11444                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB       11444                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB       22888               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB        3180                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB        3180                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB        3180                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB        3180                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB        3180                       count += 1
    78    135.8 MiB      0.0 MiB        3180                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB        3180                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB        2861           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB        2861           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB        1540       while not open_set.empty():
    49    135.8 MiB      0.0 MiB        1540           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB        1540           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB        1540           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB        1540           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB        1540           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB       13851           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB       12312               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB        6156                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB        6156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB       12312               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB        1862                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB        1862                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB        1862                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB        1862                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB        1862                       count += 1
    78    135.8 MiB      0.0 MiB        1862                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB        1862                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB        1539           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB        1539           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB        3362       while not open_set.empty():
    49    135.8 MiB      0.0 MiB        3362           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB        3362           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB        3362           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB        3362           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB        3362           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB       30249           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB       26888               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB       13444                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB       13444                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB       26888               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB        3688                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB        3688                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB        3688                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB        3688                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB        3688                       count += 1
    78    135.8 MiB      0.0 MiB        3688                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB        3688                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB        3361           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB        3361           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB          84       while not open_set.empty():
    49    135.8 MiB      0.0 MiB          84           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB          84           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB          84           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB          84           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB          84           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB         747           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB         664               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB         332                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB         332                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB         664               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB         144                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB         144                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB         144                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB         144                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB         144                       count += 1
    78    135.8 MiB      0.0 MiB         144                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB         144                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB          83           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB          83           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB         495       while not open_set.empty():
    49    135.8 MiB      0.0 MiB         495           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB         495           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB         495           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB         495           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB         495           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB        4446           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB        3952               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB        1976                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB        1976                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB        3952               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB         731                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB         731                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB         731                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB         731                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB         731                       count += 1
    78    135.8 MiB      0.0 MiB         731                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB         731                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB         494           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB         494           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB        4316       while not open_set.empty():
    49    135.8 MiB      0.0 MiB        4316           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB        4316           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB        4316           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB        4316           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB        4316           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB       38835           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB       34520               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB       17260                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB       17260                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB       34520               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB        4750                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB        4750                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB        4750                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB        4750                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB        4750                       count += 1
    78    135.8 MiB      0.0 MiB        4750                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB        4750                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB        4315           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB        4315           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB        2610       while not open_set.empty():
    49    135.8 MiB      0.0 MiB        2610           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB        2610           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB        2610           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB        2610           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB        2610           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB       23481           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB       20872               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB       10436                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB       10436                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB       20872               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB        3026                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB        3026                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB        3026                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB        3026                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB        3026                       count += 1
    78    135.8 MiB      0.0 MiB        3026                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB        3026                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB        2609           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB        2609           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB       11368       while not open_set.empty():
    49    135.8 MiB      0.0 MiB       11368           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB       11368           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB       11368           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB       11368           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB       11368           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB      102303           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB       90936               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB       45468                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB       45468                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB       90936               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB       12026                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB       12026                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB       12026                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB       12026                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB       12026                       count += 1
    78    135.8 MiB      0.0 MiB       12026                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB       12026                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB       11367           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB       11367           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB        1890       while not open_set.empty():
    49    135.8 MiB      0.0 MiB        1890           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB        1890           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB        1890           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB        1890           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB        1890           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB       17001           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB       15112               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB        7556                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB        7556                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB       15112               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB        2136                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB        2136                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB        2136                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB        2136                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB        2136                       count += 1
    78    135.8 MiB      0.0 MiB        2136                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB        2136                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB        1889           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB        1889           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB         820       while not open_set.empty():
    49    135.8 MiB      0.0 MiB         820           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB         820           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB         820           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB         820           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB         820           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB        7371           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB        6552               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB        3276                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB        3276                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB        6552               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB         980                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB         980                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB         980                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB         980                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB         980                       count += 1
    78    135.8 MiB      0.0 MiB         980                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB         980                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB         819           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB         819           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.8 MiB      0.0 MiB         790       while not open_set.empty():
    49    135.8 MiB      0.0 MiB         790           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.8 MiB      0.0 MiB         790           current = open_set.get()[2]
    55    135.8 MiB      0.0 MiB         790           open_set_hash.remove(current)
    56                                         
    57    135.8 MiB      0.0 MiB         790           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.8 MiB      0.0 MiB         790           if current == end:
    62    135.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.8 MiB      0.0 MiB        7101           for neighbor in current.neighbors:
    67    135.8 MiB      0.0 MiB        6312               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.8 MiB      0.0 MiB        3156                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.8 MiB      0.0 MiB        3156                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.8 MiB      0.0 MiB        6312               if temp_g_score < g_score[neighbor]:
    73    135.8 MiB      0.0 MiB        1124                   came_from[neighbor] = current
    74    135.8 MiB      0.0 MiB        1124                   g_score[neighbor] = temp_g_score
    75    135.8 MiB      0.0 MiB        1124                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.8 MiB      0.0 MiB        1124                   if neighbor not in open_set_hash:
    77    135.8 MiB      0.0 MiB        1124                       count += 1
    78    135.8 MiB      0.0 MiB        1124                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.8 MiB      0.0 MiB        1124                       open_set_hash.add(neighbor)
    80                                                             
    81    135.8 MiB      0.0 MiB         789           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.8 MiB      0.0 MiB         789           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.8 MiB    135.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.8 MiB      0.0 MiB         257       for row in grid:
    32    135.8 MiB      0.0 MiB       65792           for spot in row:
    33    135.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.8 MiB      0.0 MiB           1       count = 0
    36    135.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.8 MiB      0.0 MiB           1       came_from = {}
    39    135.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.9 MiB      0.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.9 MiB      0.0 MiB          84       while not open_set.empty():
    49    135.9 MiB      0.0 MiB          84           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.9 MiB      0.0 MiB          84           current = open_set.get()[2]
    55    135.9 MiB      0.0 MiB          84           open_set_hash.remove(current)
    56                                         
    57    135.9 MiB      0.0 MiB          84           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.9 MiB      0.0 MiB          84           if current == end:
    62    135.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.9 MiB      0.0 MiB         747           for neighbor in current.neighbors:
    67    135.9 MiB      0.0 MiB         664               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.9 MiB      0.0 MiB         332                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.9 MiB      0.0 MiB         332                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.9 MiB      0.0 MiB         664               if temp_g_score < g_score[neighbor]:
    73    135.9 MiB      0.0 MiB         174                   came_from[neighbor] = current
    74    135.9 MiB      0.0 MiB         174                   g_score[neighbor] = temp_g_score
    75    135.9 MiB      0.0 MiB         174                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.9 MiB      0.0 MiB         174                   if neighbor not in open_set_hash:
    77    135.9 MiB      0.0 MiB         174                       count += 1
    78    135.9 MiB      0.0 MiB         174                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.9 MiB      0.0 MiB         174                       open_set_hash.add(neighbor)
    80                                                             
    81    135.9 MiB      0.0 MiB          83           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.9 MiB      0.0 MiB          83           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.9 MiB    135.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.9 MiB      0.0 MiB         257       for row in grid:
    32    135.9 MiB      0.0 MiB       65792           for spot in row:
    33    135.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.9 MiB      0.0 MiB           1       count = 0
    36    135.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.9 MiB      0.0 MiB           1       came_from = {}
    39    135.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.9 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.9 MiB      0.0 MiB         684       while not open_set.empty():
    49    135.9 MiB      0.0 MiB         684           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.9 MiB      0.0 MiB         684           current = open_set.get()[2]
    55    135.9 MiB      0.0 MiB         684           open_set_hash.remove(current)
    56                                         
    57    135.9 MiB      0.0 MiB         684           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.9 MiB      0.0 MiB         684           if current == end:
    62    135.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.9 MiB      0.0 MiB        6147           for neighbor in current.neighbors:
    67    135.9 MiB      0.0 MiB        5464               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.9 MiB      0.0 MiB        2732                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.9 MiB      0.0 MiB        2732                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.9 MiB      0.0 MiB        5464               if temp_g_score < g_score[neighbor]:
    73    135.9 MiB      0.0 MiB        1004                   came_from[neighbor] = current
    74    135.9 MiB      0.0 MiB        1004                   g_score[neighbor] = temp_g_score
    75    135.9 MiB      0.0 MiB        1004                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.9 MiB      0.0 MiB        1004                   if neighbor not in open_set_hash:
    77    135.9 MiB      0.0 MiB        1004                       count += 1
    78    135.9 MiB      0.0 MiB        1004                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.9 MiB      0.0 MiB        1004                       open_set_hash.add(neighbor)
    80                                                             
    81    135.9 MiB      0.0 MiB         683           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.9 MiB      0.0 MiB         683           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.9 MiB    135.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.9 MiB      0.0 MiB         257       for row in grid:
    32    135.9 MiB      0.0 MiB       65792           for spot in row:
    33    135.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.9 MiB      0.0 MiB           1       count = 0
    36    135.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.9 MiB      0.0 MiB           1       came_from = {}
    39    135.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.9 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.9 MiB      0.0 MiB          24       while not open_set.empty():
    49    135.9 MiB      0.0 MiB          24           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.9 MiB      0.0 MiB          24           current = open_set.get()[2]
    55    135.9 MiB      0.0 MiB          24           open_set_hash.remove(current)
    56                                         
    57    135.9 MiB      0.0 MiB          24           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.9 MiB      0.0 MiB          24           if current == end:
    62    135.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.9 MiB      0.0 MiB         207           for neighbor in current.neighbors:
    67    135.9 MiB      0.0 MiB         184               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.9 MiB      0.0 MiB          92                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.9 MiB      0.0 MiB          92                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.9 MiB      0.0 MiB         184               if temp_g_score < g_score[neighbor]:
    73    135.9 MiB      0.0 MiB          74                   came_from[neighbor] = current
    74    135.9 MiB      0.0 MiB          74                   g_score[neighbor] = temp_g_score
    75    135.9 MiB      0.0 MiB          74                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.9 MiB      0.0 MiB          74                   if neighbor not in open_set_hash:
    77    135.9 MiB      0.0 MiB          74                       count += 1
    78    135.9 MiB      0.0 MiB          74                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.9 MiB      0.0 MiB          74                       open_set_hash.add(neighbor)
    80                                                             
    81    135.9 MiB      0.0 MiB          23           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.9 MiB      0.0 MiB          23           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.9 MiB    135.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.9 MiB      0.0 MiB         257       for row in grid:
    32    135.9 MiB      0.0 MiB       65792           for spot in row:
    33    135.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.9 MiB      0.0 MiB           1       count = 0
    36    135.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.9 MiB      0.0 MiB           1       came_from = {}
    39    135.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    135.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.9 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.9 MiB      0.0 MiB        1176       while not open_set.empty():
    49    135.9 MiB      0.0 MiB        1176           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.9 MiB      0.0 MiB        1176           current = open_set.get()[2]
    55    135.9 MiB      0.0 MiB        1176           open_set_hash.remove(current)
    56                                         
    57    135.9 MiB      0.0 MiB        1176           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.9 MiB      0.0 MiB        1176           if current == end:
    62    135.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.9 MiB      0.0 MiB       10575           for neighbor in current.neighbors:
    67    135.9 MiB      0.0 MiB        9400               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.9 MiB      0.0 MiB        4700                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.9 MiB      0.0 MiB        4700                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.9 MiB      0.0 MiB        9400               if temp_g_score < g_score[neighbor]:
    73    135.9 MiB      0.0 MiB        1398                   came_from[neighbor] = current
    74    135.9 MiB      0.0 MiB        1398                   g_score[neighbor] = temp_g_score
    75    135.9 MiB      0.0 MiB        1398                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.9 MiB      0.0 MiB        1398                   if neighbor not in open_set_hash:
    77    135.9 MiB      0.0 MiB        1398                       count += 1
    78    135.9 MiB      0.0 MiB        1398                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.9 MiB      0.0 MiB        1398                       open_set_hash.add(neighbor)
    80                                                             
    81    135.9 MiB      0.0 MiB        1175           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.9 MiB      0.0 MiB        1175           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.9 MiB    135.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.9 MiB      0.0 MiB         257       for row in grid:
    32    135.9 MiB      0.0 MiB       65792           for spot in row:
    33    135.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.9 MiB      0.0 MiB           1       count = 0
    36    135.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.9 MiB      0.0 MiB           1       came_from = {}
    39    136.0 MiB      0.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.0 MiB      0.0 MiB         950       while not open_set.empty():
    49    136.0 MiB      0.0 MiB         950           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.0 MiB      0.0 MiB         950           current = open_set.get()[2]
    55    136.0 MiB      0.0 MiB         950           open_set_hash.remove(current)
    56                                         
    57    136.0 MiB      0.0 MiB         950           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.0 MiB      0.0 MiB         950           if current == end:
    62    136.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.0 MiB      0.0 MiB        8541           for neighbor in current.neighbors:
    67    136.0 MiB      0.0 MiB        7592               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.0 MiB      0.0 MiB        3796                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.0 MiB      0.0 MiB        3796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.0 MiB      0.0 MiB        7592               if temp_g_score < g_score[neighbor]:
    73    136.0 MiB      0.0 MiB        1124                   came_from[neighbor] = current
    74    136.0 MiB      0.0 MiB        1124                   g_score[neighbor] = temp_g_score
    75    136.0 MiB      0.0 MiB        1124                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.0 MiB      0.0 MiB        1124                   if neighbor not in open_set_hash:
    77    136.0 MiB      0.0 MiB        1124                       count += 1
    78    136.0 MiB      0.0 MiB        1124                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.0 MiB      0.0 MiB        1124                       open_set_hash.add(neighbor)
    80                                                             
    81    136.0 MiB      0.0 MiB         949           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.0 MiB      0.0 MiB         949           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.0 MiB    136.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.0 MiB      0.0 MiB         257       for row in grid:
    32    136.0 MiB      0.0 MiB       65792           for spot in row:
    33    136.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    136.0 MiB      0.0 MiB           1       count = 0
    36    136.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    136.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    136.0 MiB      0.0 MiB           1       came_from = {}
    39    136.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.4 MiB      1.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.4 MiB      0.0 MiB         435       while not open_set.empty():
    49    137.4 MiB      0.0 MiB         435           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.4 MiB      0.0 MiB         435           current = open_set.get()[2]
    55    137.4 MiB      0.0 MiB         435           open_set_hash.remove(current)
    56                                         
    57    137.4 MiB      0.0 MiB         435           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.4 MiB      0.0 MiB         435           if current == end:
    62    137.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.4 MiB      0.0 MiB        3906           for neighbor in current.neighbors:
    67    137.4 MiB      0.0 MiB        3472               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.4 MiB      0.0 MiB        1736                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.4 MiB      0.0 MiB        1736                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.4 MiB      0.0 MiB        3472               if temp_g_score < g_score[neighbor]:
    73    137.4 MiB      0.0 MiB         791                   came_from[neighbor] = current
    74    137.4 MiB      0.0 MiB         791                   g_score[neighbor] = temp_g_score
    75    137.4 MiB      0.0 MiB         791                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.4 MiB      0.0 MiB         791                   if neighbor not in open_set_hash:
    77    137.4 MiB      0.0 MiB         791                       count += 1
    78    137.4 MiB      0.0 MiB         791                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.4 MiB      0.0 MiB         791                       open_set_hash.add(neighbor)
    80                                                             
    81    137.4 MiB      0.0 MiB         434           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.4 MiB      0.0 MiB         434           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.4 MiB    137.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.4 MiB      0.0 MiB         257       for row in grid:
    32    137.4 MiB      0.0 MiB       65792           for spot in row:
    33    137.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.4 MiB      0.0 MiB           1       count = 0
    36    137.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.4 MiB      0.0 MiB           1       came_from = {}
    39    137.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.4 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.4 MiB      0.0 MiB        2400       while not open_set.empty():
    49    137.4 MiB      0.0 MiB        2400           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.4 MiB      0.0 MiB        2400           current = open_set.get()[2]
    55    137.4 MiB      0.0 MiB        2400           open_set_hash.remove(current)
    56                                         
    57    137.4 MiB      0.0 MiB        2400           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.4 MiB      0.0 MiB        2400           if current == end:
    62    137.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.4 MiB      0.0 MiB       21591           for neighbor in current.neighbors:
    67    137.4 MiB      0.0 MiB       19192               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.4 MiB      0.0 MiB        9596                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.4 MiB      0.0 MiB        9596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.4 MiB      0.0 MiB       19192               if temp_g_score < g_score[neighbor]:
    73    137.4 MiB      0.0 MiB        2762                   came_from[neighbor] = current
    74    137.4 MiB      0.0 MiB        2762                   g_score[neighbor] = temp_g_score
    75    137.4 MiB      0.0 MiB        2762                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.4 MiB      0.0 MiB        2762                   if neighbor not in open_set_hash:
    77    137.4 MiB      0.0 MiB        2762                       count += 1
    78    137.4 MiB      0.0 MiB        2762                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.4 MiB      0.0 MiB        2762                       open_set_hash.add(neighbor)
    80                                                             
    81    137.4 MiB      0.0 MiB        2399           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.4 MiB      0.0 MiB        2399           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.4 MiB    137.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.4 MiB      0.0 MiB         257       for row in grid:
    32    137.4 MiB      0.0 MiB       65792           for spot in row:
    33    137.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.4 MiB      0.0 MiB           1       count = 0
    36    137.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.4 MiB      0.0 MiB           1       came_from = {}
    39    138.0 MiB      0.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    138.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    138.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    138.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    138.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    138.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    138.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    138.0 MiB      0.0 MiB        8645       while not open_set.empty():
    49    138.0 MiB      0.0 MiB        8645           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    138.0 MiB      0.0 MiB        8645           current = open_set.get()[2]
    55    138.0 MiB      0.0 MiB        8645           open_set_hash.remove(current)
    56                                         
    57    138.0 MiB      0.0 MiB        8645           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    138.0 MiB      0.0 MiB        8645           if current == end:
    62    138.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    138.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    138.0 MiB      0.0 MiB       77796           for neighbor in current.neighbors:
    67    138.0 MiB      0.0 MiB       69152               if current.row != neighbor.row and current.col != neighbor.col:
    68    138.0 MiB      0.0 MiB       34576                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    138.0 MiB      0.0 MiB       34576                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    138.0 MiB      0.0 MiB       69152               if temp_g_score < g_score[neighbor]:
    73    138.0 MiB      0.0 MiB        9169                   came_from[neighbor] = current
    74    138.0 MiB      0.0 MiB        9169                   g_score[neighbor] = temp_g_score
    75    138.0 MiB      0.0 MiB        9169                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    138.0 MiB      0.0 MiB        9169                   if neighbor not in open_set_hash:
    77    138.0 MiB      0.0 MiB        9169                       count += 1
    78    138.0 MiB      0.0 MiB        9169                       open_set.put((f_score[neighbor], count, neighbor))
    79    138.0 MiB      0.0 MiB        9169                       open_set_hash.add(neighbor)
    80                                                             
    81    138.0 MiB      0.0 MiB        8644           if draw is not None:
    82                                                     draw()
    83                                         
    84    138.0 MiB      0.0 MiB        8644           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    138.0 MiB    138.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    138.0 MiB      0.0 MiB         257       for row in grid:
    32    138.0 MiB      0.0 MiB       65792           for spot in row:
    33    138.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    138.0 MiB      0.0 MiB           1       count = 0
    36    138.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    138.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    138.0 MiB      0.0 MiB           1       came_from = {}
    39    138.0 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    138.0 MiB      0.0 MiB           1       g_score[start] = 0
    41    138.0 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    138.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    138.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    138.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    138.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    138.0 MiB      0.0 MiB        7238       while not open_set.empty():
    49    138.0 MiB      0.0 MiB        7238           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    138.0 MiB      0.0 MiB        7238           current = open_set.get()[2]
    55    138.0 MiB      0.0 MiB        7238           open_set_hash.remove(current)
    56                                         
    57    138.0 MiB      0.0 MiB        7238           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    138.0 MiB      0.0 MiB        7238           if current == end:
    62    138.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    138.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    138.0 MiB      0.0 MiB       65133           for neighbor in current.neighbors:
    67    138.0 MiB      0.0 MiB       57896               if current.row != neighbor.row and current.col != neighbor.col:
    68    138.0 MiB      0.0 MiB       28948                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    138.0 MiB      0.0 MiB       28948                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    138.0 MiB      0.0 MiB       57896               if temp_g_score < g_score[neighbor]:
    73    138.0 MiB      0.0 MiB        7732                   came_from[neighbor] = current
    74    138.0 MiB      0.0 MiB        7732                   g_score[neighbor] = temp_g_score
    75    138.0 MiB      0.0 MiB        7732                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    138.0 MiB      0.0 MiB        7732                   if neighbor not in open_set_hash:
    77    138.0 MiB      0.0 MiB        7732                       count += 1
    78    138.0 MiB      0.0 MiB        7732                       open_set.put((f_score[neighbor], count, neighbor))
    79    138.0 MiB      0.0 MiB        7732                       open_set_hash.add(neighbor)
    80                                                             
    81    138.0 MiB      0.0 MiB        7237           if draw is not None:
    82                                                     draw()
    83                                         
    84    138.0 MiB      0.0 MiB        7237           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    138.2 MiB    138.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    138.2 MiB      0.0 MiB         257       for row in grid:
    32    138.2 MiB      0.0 MiB       65792           for spot in row:
    33    138.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    138.2 MiB      0.0 MiB           1       count = 0
    36    138.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    138.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    138.2 MiB      0.0 MiB           1       came_from = {}
    39    138.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    138.2 MiB      0.0 MiB           1       g_score[start] = 0
    41    138.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    138.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    138.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    138.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46    138.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    138.2 MiB      0.0 MiB        7504       while not open_set.empty():
    49    138.2 MiB      0.0 MiB        7504           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    138.2 MiB      0.0 MiB        7504           current = open_set.get()[2]
    55    138.2 MiB      0.0 MiB        7504           open_set_hash.remove(current)
    56                                         
    57    138.2 MiB      0.0 MiB        7504           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    138.2 MiB      0.0 MiB        7504           if current == end:
    62    138.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    138.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    138.2 MiB      0.0 MiB       67527           for neighbor in current.neighbors:
    67    138.2 MiB      0.0 MiB       60024               if current.row != neighbor.row and current.col != neighbor.col:
    68    138.2 MiB      0.0 MiB       30012                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    138.2 MiB      0.0 MiB       30012                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    138.2 MiB      0.0 MiB       60024               if temp_g_score < g_score[neighbor]:
    73    138.2 MiB      0.0 MiB        7994                   came_from[neighbor] = current
    74    138.2 MiB      0.0 MiB        7994                   g_score[neighbor] = temp_g_score
    75    138.2 MiB      0.0 MiB        7994                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    138.2 MiB      0.0 MiB        7994                   if neighbor not in open_set_hash:
    77    138.2 MiB      0.0 MiB        7994                       count += 1
    78    138.2 MiB      0.0 MiB        7994                       open_set.put((f_score[neighbor], count, neighbor))
    79    138.2 MiB      0.0 MiB        7994                       open_set_hash.add(neighbor)
    80                                                             
    81    138.2 MiB      0.0 MiB        7503           if draw is not None:
    82                                                     draw()
    83                                         
    84    138.2 MiB      0.0 MiB        7503           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.2 MiB    137.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.2 MiB      0.0 MiB         257       for row in grid:
    32    137.2 MiB      0.0 MiB       65792           for spot in row:
    33    137.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.2 MiB      0.0 MiB           1       count = 0
    36    137.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.2 MiB      0.0 MiB           1       came_from = {}
    39    137.2 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    137.2 MiB      0.0 MiB           1       g_score[start] = 0
    41    137.2 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    137.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    137.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    137.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46    137.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    137.2 MiB      0.0 MiB         732       while not open_set.empty():
    49    137.2 MiB      0.0 MiB         732           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    137.2 MiB      0.0 MiB         732           current = open_set.get()[2]
    55    137.2 MiB      0.0 MiB         732           open_set_hash.remove(current)
    56                                         
    57    137.2 MiB      0.0 MiB         732           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    137.2 MiB      0.0 MiB         732           if current == end:
    62    137.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    137.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    137.2 MiB      0.0 MiB        6579           for neighbor in current.neighbors:
    67    137.2 MiB      0.0 MiB        5848               if current.row != neighbor.row and current.col != neighbor.col:
    68    137.2 MiB      0.0 MiB        2924                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    137.2 MiB      0.0 MiB        2924                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    137.2 MiB      0.0 MiB        5848               if temp_g_score < g_score[neighbor]:
    73    137.2 MiB      0.0 MiB         900                   came_from[neighbor] = current
    74    137.2 MiB      0.0 MiB         900                   g_score[neighbor] = temp_g_score
    75    137.2 MiB      0.0 MiB         900                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    137.2 MiB      0.0 MiB         900                   if neighbor not in open_set_hash:
    77    137.2 MiB      0.0 MiB         900                       count += 1
    78    137.2 MiB      0.0 MiB         900                       open_set.put((f_score[neighbor], count, neighbor))
    79    137.2 MiB      0.0 MiB         900                       open_set_hash.add(neighbor)
    80                                                             
    81    137.2 MiB      0.0 MiB         731           if draw is not None:
    82                                                     draw()
    83                                         
    84    137.2 MiB      0.0 MiB         731           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    137.2 MiB    137.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    137.2 MiB      0.0 MiB         257       for row in grid:
    32    137.2 MiB      0.0 MiB       65792           for spot in row:
    33    137.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    137.2 MiB      0.0 MiB           1       count = 0
    36    137.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    137.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    137.2 MiB      0.0 MiB           1       came_from = {}
    39    137.2 MiB -18555.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.6 MiB     -0.6 MiB           1       g_score[start] = 0
    41    136.6 MiB   -730.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.5 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.5 MiB  -1499.0 MiB        1014       while not open_set.empty():
    49    136.5 MiB  -1499.0 MiB        1014           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.5 MiB  -1499.0 MiB        1014           current = open_set.get()[2]
    55    136.5 MiB  -1499.0 MiB        1014           open_set_hash.remove(current)
    56                                         
    57    136.5 MiB  -1499.0 MiB        1014           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.5 MiB  -1499.0 MiB        1014           if current == end:
    62    134.9 MiB     -1.7 MiB           1               if draw:
    63                                                         end.make_end()
    64    134.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.5 MiB -13484.3 MiB        9117           for neighbor in current.neighbors:
    67    136.5 MiB -11985.7 MiB        8104               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.5 MiB  -5995.9 MiB        4052                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.5 MiB  -5990.2 MiB        4052                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.5 MiB -11986.3 MiB        8104               if temp_g_score < g_score[neighbor]:
    73    136.5 MiB  -1740.2 MiB        1220                   came_from[neighbor] = current
    74    136.5 MiB  -1740.2 MiB        1220                   g_score[neighbor] = temp_g_score
    75    136.5 MiB  -1740.3 MiB        1220                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.5 MiB  -1740.3 MiB        1220                   if neighbor not in open_set_hash:
    77    136.5 MiB  -1740.4 MiB        1220                       count += 1
    78    136.5 MiB  -1740.5 MiB        1220                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.5 MiB  -1740.6 MiB        1220                       open_set_hash.add(neighbor)
    80                                                             
    81    136.5 MiB  -1499.0 MiB        1013           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.5 MiB  -1499.0 MiB        1013           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.0 MiB    135.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.0 MiB   -286.1 MiB         257       for row in grid:
    32    135.0 MiB -73395.9 MiB       65792           for spot in row:
    33    135.0 MiB -73110.9 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    133.2 MiB     -1.7 MiB           1       count = 0
    36    133.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    133.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    133.2 MiB      0.0 MiB           1       came_from = {}
    39    134.6 MiB      1.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    134.6 MiB      0.0 MiB           1       g_score[start] = 0
    41    135.5 MiB      0.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    135.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    135.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    135.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    135.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    135.5 MiB      0.0 MiB        1494       while not open_set.empty():
    49    135.5 MiB      0.0 MiB        1494           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    135.5 MiB      0.0 MiB        1494           current = open_set.get()[2]
    55    135.5 MiB      0.0 MiB        1494           open_set_hash.remove(current)
    56                                         
    57    135.5 MiB      0.0 MiB        1494           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    135.5 MiB      0.0 MiB        1494           if current == end:
    62    135.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    135.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    135.5 MiB      0.0 MiB       13437           for neighbor in current.neighbors:
    67    135.5 MiB      0.0 MiB       11944               if current.row != neighbor.row and current.col != neighbor.col:
    68    135.5 MiB      0.0 MiB        5972                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    135.5 MiB      0.0 MiB        5972                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    135.5 MiB      0.0 MiB       11944               if temp_g_score < g_score[neighbor]:
    73    135.5 MiB      0.0 MiB        1860                   came_from[neighbor] = current
    74    135.5 MiB      0.0 MiB        1860                   g_score[neighbor] = temp_g_score
    75    135.5 MiB      0.0 MiB        1860                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    135.5 MiB      0.0 MiB        1860                   if neighbor not in open_set_hash:
    77    135.5 MiB      0.0 MiB        1860                       count += 1
    78    135.5 MiB      0.0 MiB        1860                       open_set.put((f_score[neighbor], count, neighbor))
    79    135.5 MiB      0.0 MiB        1860                       open_set_hash.add(neighbor)
    80                                                             
    81    135.5 MiB      0.0 MiB        1493           if draw is not None:
    82                                                     draw()
    83                                         
    84    135.5 MiB      0.0 MiB        1493           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    135.5 MiB    135.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    135.5 MiB      0.0 MiB         257       for row in grid:
    32    135.5 MiB      0.0 MiB       65792           for spot in row:
    33    135.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    135.5 MiB      0.0 MiB           1       count = 0
    36    135.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    135.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    135.5 MiB      0.0 MiB           1       came_from = {}
    39    136.7 MiB      1.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    136.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    136.8 MiB      0.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    136.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    136.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    136.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    136.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    136.8 MiB      0.0 MiB        6440       while not open_set.empty():
    49    136.8 MiB      0.0 MiB        6440           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    136.8 MiB      0.0 MiB        6440           current = open_set.get()[2]
    55    136.8 MiB      0.0 MiB        6440           open_set_hash.remove(current)
    56                                         
    57    136.8 MiB      0.0 MiB        6440           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    136.8 MiB      0.0 MiB        6440           if current == end:
    62    136.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    136.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    136.8 MiB      0.0 MiB       57951           for neighbor in current.neighbors:
    67    136.8 MiB      0.0 MiB       51512               if current.row != neighbor.row and current.col != neighbor.col:
    68    136.8 MiB      0.0 MiB       25756                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    136.8 MiB      0.0 MiB       25756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    136.8 MiB      0.0 MiB       51512               if temp_g_score < g_score[neighbor]:
    73    136.8 MiB      0.0 MiB        6946                   came_from[neighbor] = current
    74    136.8 MiB      0.0 MiB        6946                   g_score[neighbor] = temp_g_score
    75    136.8 MiB      0.0 MiB        6946                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    136.8 MiB      0.0 MiB        6946                   if neighbor not in open_set_hash:
    77    136.8 MiB      0.0 MiB        6946                       count += 1
    78    136.8 MiB      0.0 MiB        6946                       open_set.put((f_score[neighbor], count, neighbor))
    79    136.8 MiB      0.0 MiB        6946                       open_set_hash.add(neighbor)
    80                                                             
    81    136.8 MiB      0.0 MiB        6439           if draw is not None:
    82                                                     draw()
    83                                         
    84    136.8 MiB      0.0 MiB        6439           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    136.8 MiB    136.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    136.8 MiB  -2539.1 MiB         257       for row in grid:
    32    136.8 MiB -649542.0 MiB       65792           for spot in row:
    33    136.8 MiB -647015.9 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    118.6 MiB    -18.1 MiB           1       count = 0
    36    118.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    118.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    118.6 MiB      0.0 MiB           1       came_from = {}
    39    118.6 MiB -31250.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    117.7 MiB     -1.0 MiB           1       g_score[start] = 0
    41    118.5 MiB  -1261.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    118.4 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    118.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    118.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    118.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    118.4 MiB      0.0 MiB        3344       while not open_set.empty():
    49    118.4 MiB      0.0 MiB        3344           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    118.4 MiB      0.0 MiB        3344           current = open_set.get()[2]
    55    118.4 MiB      0.0 MiB        3344           open_set_hash.remove(current)
    56                                         
    57    118.4 MiB      0.0 MiB        3344           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    118.4 MiB      0.0 MiB        3344           if current == end:
    62    118.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    118.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    118.4 MiB      0.0 MiB       30087           for neighbor in current.neighbors:
    67    118.4 MiB      0.0 MiB       26744               if current.row != neighbor.row and current.col != neighbor.col:
    68    118.4 MiB      0.0 MiB       13372                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    118.4 MiB      0.0 MiB       13372                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    118.4 MiB      0.0 MiB       26744               if temp_g_score < g_score[neighbor]:
    73    118.4 MiB      0.0 MiB        3734                   came_from[neighbor] = current
    74    118.4 MiB      0.0 MiB        3734                   g_score[neighbor] = temp_g_score
    75    118.4 MiB      0.0 MiB        3734                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    118.4 MiB      0.0 MiB        3734                   if neighbor not in open_set_hash:
    77    118.4 MiB      0.0 MiB        3734                       count += 1
    78    118.4 MiB      0.0 MiB        3734                       open_set.put((f_score[neighbor], count, neighbor))
    79    118.4 MiB      0.0 MiB        3734                       open_set_hash.add(neighbor)
    80                                                             
    81    118.4 MiB      0.0 MiB        3343           if draw is not None:
    82                                                     draw()
    83                                         
    84    118.4 MiB      0.0 MiB        3343           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    118.4 MiB    118.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    118.4 MiB      0.0 MiB         257       for row in grid:
    32    118.4 MiB      0.0 MiB       65792           for spot in row:
    33    118.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    118.4 MiB      0.0 MiB           1       count = 0
    36    118.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    118.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    118.4 MiB      0.0 MiB           1       came_from = {}
    39    118.5 MiB      0.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    118.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    120.6 MiB      2.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    120.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    120.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    120.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    120.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    120.6 MiB -68633.2 MiB       13892       while not open_set.empty():
    49    120.6 MiB -68633.4 MiB       13892           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    120.6 MiB -68633.7 MiB       13892           current = open_set.get()[2]
    55    120.6 MiB -68633.8 MiB       13892           open_set_hash.remove(current)
    56                                         
    57    120.6 MiB -68633.9 MiB       13892           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    120.6 MiB -68634.0 MiB       13892           if current == end:
    62    114.1 MiB     -6.5 MiB           1               if draw:
    63                                                         end.make_end()
    64    114.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    120.6 MiB -617666.3 MiB      125019           for neighbor in current.neighbors:
    67    120.6 MiB -549034.7 MiB      111128               if current.row != neighbor.row and current.col != neighbor.col:
    68    120.6 MiB -274522.8 MiB       55564                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    120.6 MiB -274512.9 MiB       55564                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    120.6 MiB -549036.7 MiB      111128               if temp_g_score < g_score[neighbor]:
    73    120.6 MiB -71051.1 MiB       14560                   came_from[neighbor] = current
    74    120.6 MiB -71051.3 MiB       14560                   g_score[neighbor] = temp_g_score
    75    120.6 MiB -71051.6 MiB       14560                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    120.6 MiB -71051.8 MiB       14560                   if neighbor not in open_set_hash:
    77    120.6 MiB -71052.1 MiB       14560                       count += 1
    78    120.6 MiB -71052.3 MiB       14560                       open_set.put((f_score[neighbor], count, neighbor))
    79    120.6 MiB -71052.4 MiB       14560                       open_set_hash.add(neighbor)
    80                                                             
    81    120.6 MiB -68632.8 MiB       13891           if draw is not None:
    82                                                     draw()
    83                                         
    84    120.6 MiB -68633.1 MiB       13891           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    114.1 MiB    114.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    114.1 MiB      0.0 MiB         257       for row in grid:
    32    114.1 MiB      0.0 MiB       65792           for spot in row:
    33    114.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    114.1 MiB      0.0 MiB           1       count = 0
    36    114.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    114.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    114.1 MiB      0.0 MiB           1       came_from = {}
    39    115.3 MiB   -575.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    115.3 MiB      0.0 MiB           1       g_score[start] = 0
    41    118.9 MiB      3.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    118.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    118.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    118.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    118.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    118.9 MiB      0.0 MiB          90       while not open_set.empty():
    49    118.9 MiB      0.0 MiB          90           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    118.9 MiB      0.0 MiB          90           current = open_set.get()[2]
    55    118.9 MiB      0.0 MiB          90           open_set_hash.remove(current)
    56                                         
    57    118.9 MiB      0.0 MiB          90           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    118.9 MiB      0.0 MiB          90           if current == end:
    62    118.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    118.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    118.9 MiB      0.0 MiB         801           for neighbor in current.neighbors:
    67    118.9 MiB      0.0 MiB         712               if current.row != neighbor.row and current.col != neighbor.col:
    68    118.9 MiB      0.0 MiB         356                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    118.9 MiB      0.0 MiB         356                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    118.9 MiB      0.0 MiB         712               if temp_g_score < g_score[neighbor]:
    73    118.9 MiB      0.0 MiB         146                   came_from[neighbor] = current
    74    118.9 MiB      0.0 MiB         146                   g_score[neighbor] = temp_g_score
    75    118.9 MiB      0.0 MiB         146                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    118.9 MiB      0.0 MiB         146                   if neighbor not in open_set_hash:
    77    118.9 MiB      0.0 MiB         146                       count += 1
    78    118.9 MiB      0.0 MiB         146                       open_set.put((f_score[neighbor], count, neighbor))
    79    118.9 MiB      0.0 MiB         146                       open_set_hash.add(neighbor)
    80                                                             
    81    118.9 MiB      0.0 MiB          89           if draw is not None:
    82                                                     draw()
    83                                         
    84    118.9 MiB      0.0 MiB          89           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    115.9 MiB    115.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    115.9 MiB    -97.3 MiB         257       for row in grid:
    32    115.9 MiB -24569.2 MiB       65792           for spot in row:
    33    115.9 MiB -24474.4 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    112.3 MiB     -3.6 MiB           1       count = 0
    36    112.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    112.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    112.3 MiB      0.0 MiB           1       came_from = {}
    39    114.1 MiB      1.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    114.1 MiB      0.0 MiB           1       g_score[start] = 0
    41    116.0 MiB      1.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    116.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    116.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    116.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    116.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    116.0 MiB      0.0 MiB         282       while not open_set.empty():
    49    116.0 MiB      0.0 MiB         282           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    116.0 MiB      0.0 MiB         282           current = open_set.get()[2]
    55    116.0 MiB      0.0 MiB         282           open_set_hash.remove(current)
    56                                         
    57    116.0 MiB      0.0 MiB         282           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    116.0 MiB      0.0 MiB         282           if current == end:
    62    116.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    116.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    116.0 MiB      0.0 MiB        2529           for neighbor in current.neighbors:
    67    116.0 MiB      0.0 MiB        2248               if current.row != neighbor.row and current.col != neighbor.col:
    68    116.0 MiB      0.0 MiB        1124                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    116.0 MiB      0.0 MiB        1124                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    116.0 MiB      0.0 MiB        2248               if temp_g_score < g_score[neighbor]:
    73    116.0 MiB      0.0 MiB         570                   came_from[neighbor] = current
    74    116.0 MiB      0.0 MiB         570                   g_score[neighbor] = temp_g_score
    75    116.0 MiB      0.0 MiB         570                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    116.0 MiB      0.0 MiB         570                   if neighbor not in open_set_hash:
    77    116.0 MiB      0.0 MiB         570                       count += 1
    78    116.0 MiB      0.0 MiB         570                       open_set.put((f_score[neighbor], count, neighbor))
    79    116.0 MiB      0.0 MiB         570                       open_set_hash.add(neighbor)
    80                                                             
    81    116.0 MiB      0.0 MiB         281           if draw is not None:
    82                                                     draw()
    83                                         
    84    116.0 MiB      0.0 MiB         281           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    116.3 MiB    116.3 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    116.3 MiB  -1256.1 MiB         257       for row in grid:
    32    116.3 MiB -321766.0 MiB       65792           for spot in row:
    33    116.3 MiB -320516.2 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    107.3 MiB     -9.0 MiB           1       count = 0
    36    107.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    107.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    107.3 MiB      0.0 MiB           1       came_from = {}
    39    109.7 MiB      2.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    109.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    112.2 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    112.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    112.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    112.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46    112.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    112.2 MiB      0.0 MiB         475       while not open_set.empty():
    49    112.2 MiB      0.0 MiB         475           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    112.2 MiB      0.0 MiB         475           current = open_set.get()[2]
    55    112.2 MiB      0.0 MiB         475           open_set_hash.remove(current)
    56                                         
    57    112.2 MiB      0.0 MiB         475           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    112.2 MiB      0.0 MiB         475           if current == end:
    62    112.2 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    112.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    112.2 MiB      0.0 MiB        4266           for neighbor in current.neighbors:
    67    112.2 MiB      0.0 MiB        3792               if current.row != neighbor.row and current.col != neighbor.col:
    68    112.2 MiB      0.0 MiB        1896                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    112.2 MiB      0.0 MiB        1896                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    112.2 MiB      0.0 MiB        3792               if temp_g_score < g_score[neighbor]:
    73    112.2 MiB      0.0 MiB         599                   came_from[neighbor] = current
    74    112.2 MiB      0.0 MiB         599                   g_score[neighbor] = temp_g_score
    75    112.2 MiB      0.0 MiB         599                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    112.2 MiB      0.0 MiB         599                   if neighbor not in open_set_hash:
    77    112.2 MiB      0.0 MiB         599                       count += 1
    78    112.2 MiB      0.0 MiB         599                       open_set.put((f_score[neighbor], count, neighbor))
    79    112.2 MiB      0.0 MiB         599                       open_set_hash.add(neighbor)
    80                                                             
    81    112.2 MiB      0.0 MiB         474           if draw is not None:
    82                                                     draw()
    83                                         
    84    112.2 MiB      0.0 MiB         474           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    114.9 MiB    114.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    114.9 MiB      0.0 MiB         257       for row in grid:
    32    114.9 MiB      0.0 MiB       65792           for spot in row:
    33    114.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    114.9 MiB      0.0 MiB           1       count = 0
    36    114.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    114.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    114.9 MiB      0.0 MiB           1       came_from = {}
    39    117.7 MiB      2.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    117.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    122.5 MiB      4.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    122.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    122.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    122.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    122.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    122.7 MiB      0.0 MiB        8160       while not open_set.empty():
    49    122.7 MiB      0.0 MiB        8160           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    122.7 MiB      0.0 MiB        8160           current = open_set.get()[2]
    55    122.7 MiB      0.0 MiB        8160           open_set_hash.remove(current)
    56                                         
    57    122.7 MiB      0.0 MiB        8160           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    122.7 MiB      0.0 MiB        8160           if current == end:
    62    122.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    122.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    122.7 MiB      0.0 MiB       73431           for neighbor in current.neighbors:
    67    122.7 MiB      0.0 MiB       65272               if current.row != neighbor.row and current.col != neighbor.col:
    68    122.7 MiB      0.0 MiB       32636                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    122.7 MiB      0.0 MiB       32636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    122.7 MiB      0.0 MiB       65272               if temp_g_score < g_score[neighbor]:
    73    122.7 MiB      0.2 MiB        8726                   came_from[neighbor] = current
    74    122.7 MiB      0.0 MiB        8726                   g_score[neighbor] = temp_g_score
    75    122.7 MiB      0.0 MiB        8726                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    122.7 MiB      0.0 MiB        8726                   if neighbor not in open_set_hash:
    77    122.7 MiB      0.0 MiB        8726                       count += 1
    78    122.7 MiB      0.0 MiB        8726                       open_set.put((f_score[neighbor], count, neighbor))
    79    122.7 MiB      0.0 MiB        8726                       open_set_hash.add(neighbor)
    80                                                             
    81    122.7 MiB      0.0 MiB        8159           if draw is not None:
    82                                                     draw()
    83                                         
    84    122.7 MiB      0.0 MiB        8159           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    122.7 MiB    122.7 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    122.7 MiB      0.0 MiB         257       for row in grid:
    32    122.7 MiB      0.0 MiB       65792           for spot in row:
    33    122.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    122.7 MiB      0.0 MiB           1       count = 0
    36    122.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    122.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    122.7 MiB      0.0 MiB           1       came_from = {}
    39    122.7 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    122.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    125.1 MiB      2.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    125.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    125.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    125.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    125.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    125.1 MiB      0.0 MiB        1325       while not open_set.empty():
    49    125.1 MiB      0.0 MiB        1325           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    125.1 MiB      0.0 MiB        1325           current = open_set.get()[2]
    55    125.1 MiB      0.0 MiB        1325           open_set_hash.remove(current)
    56                                         
    57    125.1 MiB      0.0 MiB        1325           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    125.1 MiB      0.0 MiB        1325           if current == end:
    62    125.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    125.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    125.1 MiB      0.0 MiB       11916           for neighbor in current.neighbors:
    67    125.1 MiB      0.0 MiB       10592               if current.row != neighbor.row and current.col != neighbor.col:
    68    125.1 MiB      0.0 MiB        5296                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    125.1 MiB      0.0 MiB        5296                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    125.1 MiB      0.0 MiB       10592               if temp_g_score < g_score[neighbor]:
    73    125.1 MiB      0.0 MiB        1585                   came_from[neighbor] = current
    74    125.1 MiB      0.0 MiB        1585                   g_score[neighbor] = temp_g_score
    75    125.1 MiB      0.0 MiB        1585                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    125.1 MiB      0.0 MiB        1585                   if neighbor not in open_set_hash:
    77    125.1 MiB      0.0 MiB        1585                       count += 1
    78    125.1 MiB      0.0 MiB        1585                       open_set.put((f_score[neighbor], count, neighbor))
    79    125.1 MiB      0.0 MiB        1585                       open_set_hash.add(neighbor)
    80                                                             
    81    125.1 MiB      0.0 MiB        1324           if draw is not None:
    82                                                     draw()
    83                                         
    84    125.1 MiB      0.0 MiB        1324           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    125.1 MiB    125.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    125.1 MiB      0.0 MiB         257       for row in grid:
    32    125.1 MiB      0.0 MiB       65792           for spot in row:
    33    125.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    125.1 MiB      0.0 MiB           1       count = 0
    36    125.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    125.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    125.1 MiB      0.0 MiB           1       came_from = {}
    39    125.1 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    125.1 MiB      0.0 MiB           1       g_score[start] = 0
    41    125.8 MiB      0.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    125.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    125.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    125.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    125.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    126.1 MiB      0.0 MiB        6750       while not open_set.empty():
    49    126.1 MiB      0.0 MiB        6750           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    126.1 MiB      0.0 MiB        6750           current = open_set.get()[2]
    55    126.1 MiB      0.0 MiB        6750           open_set_hash.remove(current)
    56                                         
    57    126.1 MiB      0.0 MiB        6750           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    126.1 MiB      0.0 MiB        6750           if current == end:
    62    126.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    126.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    126.1 MiB      0.0 MiB       60741           for neighbor in current.neighbors:
    67    126.1 MiB      0.0 MiB       53992               if current.row != neighbor.row and current.col != neighbor.col:
    68    126.1 MiB      0.0 MiB       26996                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    126.1 MiB      0.0 MiB       26996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    126.1 MiB      0.0 MiB       53992               if temp_g_score < g_score[neighbor]:
    73    126.1 MiB      0.3 MiB        7218                   came_from[neighbor] = current
    74    126.1 MiB      0.0 MiB        7218                   g_score[neighbor] = temp_g_score
    75    126.1 MiB      0.0 MiB        7218                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    126.1 MiB      0.0 MiB        7218                   if neighbor not in open_set_hash:
    77    126.1 MiB      0.0 MiB        7218                       count += 1
    78    126.1 MiB      0.0 MiB        7218                       open_set.put((f_score[neighbor], count, neighbor))
    79    126.1 MiB      0.0 MiB        7218                       open_set_hash.add(neighbor)
    80                                                             
    81    126.1 MiB      0.0 MiB        6749           if draw is not None:
    82                                                     draw()
    83                                         
    84    126.1 MiB      0.0 MiB        6749           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    126.1 MiB    126.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    126.1 MiB      0.0 MiB         257       for row in grid:
    32    126.1 MiB      0.0 MiB       65792           for spot in row:
    33    126.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    126.1 MiB      0.0 MiB           1       count = 0
    36    126.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    126.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    126.1 MiB      0.0 MiB           1       came_from = {}
    39    126.1 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    126.1 MiB      0.0 MiB           1       g_score[start] = 0
    41    126.5 MiB      0.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    126.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    126.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    126.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    126.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    126.5 MiB      0.0 MiB        4602       while not open_set.empty():
    49    126.5 MiB      0.0 MiB        4602           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    126.5 MiB      0.0 MiB        4602           current = open_set.get()[2]
    55    126.5 MiB      0.0 MiB        4602           open_set_hash.remove(current)
    56                                         
    57    126.5 MiB      0.0 MiB        4602           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    126.5 MiB      0.0 MiB        4602           if current == end:
    62    126.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    126.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    126.5 MiB      0.0 MiB       41409           for neighbor in current.neighbors:
    67    126.5 MiB      0.0 MiB       36808               if current.row != neighbor.row and current.col != neighbor.col:
    68    126.5 MiB      0.0 MiB       18404                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    126.5 MiB      0.0 MiB       18404                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    126.5 MiB      0.0 MiB       36808               if temp_g_score < g_score[neighbor]:
    73    126.5 MiB      0.0 MiB        4992                   came_from[neighbor] = current
    74    126.5 MiB      0.0 MiB        4992                   g_score[neighbor] = temp_g_score
    75    126.5 MiB      0.0 MiB        4992                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    126.5 MiB      0.0 MiB        4992                   if neighbor not in open_set_hash:
    77    126.5 MiB      0.0 MiB        4992                       count += 1
    78    126.5 MiB      0.0 MiB        4992                       open_set.put((f_score[neighbor], count, neighbor))
    79    126.5 MiB      0.0 MiB        4992                       open_set_hash.add(neighbor)
    80                                                             
    81    126.5 MiB      0.0 MiB        4601           if draw is not None:
    82                                                     draw()
    83                                         
    84    126.5 MiB      0.0 MiB        4601           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    126.5 MiB    126.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    126.5 MiB      0.0 MiB         257       for row in grid:
    32    126.5 MiB     -0.0 MiB       65792           for spot in row:
    33    126.5 MiB     -0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    126.5 MiB      0.0 MiB           1       count = 0
    36    126.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    126.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    126.5 MiB      0.0 MiB           1       came_from = {}
    39    126.6 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    126.6 MiB      0.0 MiB           1       g_score[start] = 0
    41    126.6 MiB -326264.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    120.6 MiB     -6.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    120.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    120.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    120.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    120.6 MiB -16721.4 MiB        1479       while not open_set.empty():
    49    120.6 MiB -16721.8 MiB        1479           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    120.6 MiB -16722.5 MiB        1479           current = open_set.get()[2]
    55    120.6 MiB -16722.9 MiB        1479           open_set_hash.remove(current)
    56                                         
    57    120.6 MiB -16723.3 MiB        1479           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    120.6 MiB -16723.8 MiB        1479           if current == end:
    62    108.7 MiB    -11.9 MiB           1               if draw:
    63                                                         end.make_end()
    64    108.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    120.6 MiB -150452.9 MiB       13302           for neighbor in current.neighbors:
    67    120.6 MiB -133734.2 MiB       11824               if current.row != neighbor.row and current.col != neighbor.col:
    68    120.6 MiB -66874.6 MiB        5912                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    120.6 MiB -66861.1 MiB        5912                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    120.6 MiB -133737.4 MiB       11824               if temp_g_score < g_score[neighbor]:
    73    120.6 MiB -18773.5 MiB        1695                   came_from[neighbor] = current
    74    120.6 MiB -18773.7 MiB        1695                   g_score[neighbor] = temp_g_score
    75    120.6 MiB -18774.1 MiB        1695                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    120.6 MiB -18774.3 MiB        1695                   if neighbor not in open_set_hash:
    77    120.6 MiB -18774.5 MiB        1695                       count += 1
    78    120.6 MiB -18774.9 MiB        1695                       open_set.put((f_score[neighbor], count, neighbor))
    79    120.6 MiB -18775.2 MiB        1695                       open_set_hash.add(neighbor)
    80                                                             
    81    120.6 MiB -16720.6 MiB        1478           if draw is not None:
    82                                                     draw()
    83                                         
    84    120.6 MiB -16720.8 MiB        1478           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    109.1 MiB    109.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    109.1 MiB    -82.0 MiB         257       for row in grid:
    32    109.1 MiB -20982.6 MiB       65792           for spot in row:
    33    109.1 MiB -20901.3 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    108.1 MiB     -1.1 MiB           1       count = 0
    36    108.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    108.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    108.1 MiB      0.0 MiB           1       came_from = {}
    39    110.0 MiB -73843.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    106.0 MiB     -4.0 MiB           1       g_score[start] = 0
    41    109.9 MiB  -3753.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    109.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    109.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    109.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46    109.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    109.9 MiB -42925.6 MiB       10672       while not open_set.empty():
    49    109.9 MiB -42925.8 MiB       10672           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    109.9 MiB -42926.1 MiB       10672           current = open_set.get()[2]
    55    109.9 MiB -42926.3 MiB       10672           open_set_hash.remove(current)
    56                                         
    57    109.9 MiB -42926.4 MiB       10672           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    109.9 MiB -42926.5 MiB       10672           if current == end:
    62    106.4 MiB     -3.5 MiB           1               if draw:
    63                                                         end.make_end()
    64    106.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    109.9 MiB -386320.3 MiB       96039           for neighbor in current.neighbors:
    67    109.9 MiB -343395.9 MiB       85368               if current.row != neighbor.row and current.col != neighbor.col:
    68    109.9 MiB -171699.3 MiB       42684                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    109.9 MiB -171697.2 MiB       42684                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    109.9 MiB -343397.3 MiB       85368               if temp_g_score < g_score[neighbor]:
    73    109.9 MiB -44621.5 MiB       11270                   came_from[neighbor] = current
    74    109.9 MiB -44621.7 MiB       11270                   g_score[neighbor] = temp_g_score
    75    109.9 MiB -44621.7 MiB       11270                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    109.9 MiB -44621.8 MiB       11270                   if neighbor not in open_set_hash:
    77    109.9 MiB -44621.9 MiB       11270                       count += 1
    78    109.9 MiB -44621.2 MiB       11270                       open_set.put((f_score[neighbor], count, neighbor))
    79    109.9 MiB -44621.2 MiB       11270                       open_set_hash.add(neighbor)
    80                                                             
    81    109.9 MiB -42925.3 MiB       10671           if draw is not None:
    82                                                     draw()
    83                                         
    84    109.9 MiB -42925.4 MiB       10671           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    106.9 MiB    106.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    106.9 MiB      0.0 MiB         257       for row in grid:
    32    106.9 MiB      0.0 MiB       65792           for spot in row:
    33    106.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    106.9 MiB      0.0 MiB           1       count = 0
    36    106.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    106.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    106.9 MiB      0.0 MiB           1       came_from = {}
    39    108.6 MiB      1.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    108.6 MiB      0.0 MiB           1       g_score[start] = 0
    41    110.3 MiB      1.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    110.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    110.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    110.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46    110.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    110.3 MiB      0.0 MiB        1692       while not open_set.empty():
    49    110.3 MiB      0.0 MiB        1692           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    110.3 MiB      0.0 MiB        1692           current = open_set.get()[2]
    55    110.3 MiB      0.0 MiB        1692           open_set_hash.remove(current)
    56                                         
    57    110.3 MiB      0.0 MiB        1692           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    110.3 MiB      0.0 MiB        1692           if current == end:
    62    110.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    110.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    110.3 MiB      0.0 MiB       15219           for neighbor in current.neighbors:
    67    110.3 MiB      0.0 MiB       13528               if current.row != neighbor.row and current.col != neighbor.col:
    68    110.3 MiB      0.0 MiB        6764                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    110.3 MiB      0.0 MiB        6764                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    110.3 MiB      0.0 MiB       13528               if temp_g_score < g_score[neighbor]:
    73    110.3 MiB      0.0 MiB        2020                   came_from[neighbor] = current
    74    110.3 MiB      0.0 MiB        2020                   g_score[neighbor] = temp_g_score
    75    110.3 MiB      0.0 MiB        2020                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    110.3 MiB      0.0 MiB        2020                   if neighbor not in open_set_hash:
    77    110.3 MiB      0.0 MiB        2020                       count += 1
    78    110.3 MiB      0.0 MiB        2020                       open_set.put((f_score[neighbor], count, neighbor))
    79    110.3 MiB      0.0 MiB        2020                       open_set_hash.add(neighbor)
    80                                                             
    81    110.3 MiB      0.0 MiB        1691           if draw is not None:
    82                                                     draw()
    83                                         
    84    110.3 MiB      0.0 MiB        1691           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    110.4 MiB    110.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    110.4 MiB      0.0 MiB         257       for row in grid:
    32    110.4 MiB      0.0 MiB       65792           for spot in row:
    33    110.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    110.4 MiB      0.0 MiB           1       count = 0
    36    110.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    110.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    110.4 MiB      0.0 MiB           1       came_from = {}
    39    113.1 MiB      2.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    113.1 MiB      0.0 MiB           1       g_score[start] = 0
    41    113.7 MiB      0.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    113.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    113.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    113.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46    113.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    114.3 MiB      0.0 MiB       11176       while not open_set.empty():
    49    114.3 MiB      0.0 MiB       11176           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    114.3 MiB      0.0 MiB       11176           current = open_set.get()[2]
    55    114.3 MiB      0.0 MiB       11176           open_set_hash.remove(current)
    56                                         
    57    114.3 MiB      0.0 MiB       11176           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    114.3 MiB      0.0 MiB       11176           if current == end:
    62    114.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    114.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    114.3 MiB      0.0 MiB      100575           for neighbor in current.neighbors:
    67    114.3 MiB      0.0 MiB       89400               if current.row != neighbor.row and current.col != neighbor.col:
    68    114.3 MiB      0.0 MiB       44700                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    114.3 MiB      0.0 MiB       44700                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    114.3 MiB      0.0 MiB       89400               if temp_g_score < g_score[neighbor]:
    73    114.3 MiB      0.6 MiB       11780                   came_from[neighbor] = current
    74    114.3 MiB      0.0 MiB       11780                   g_score[neighbor] = temp_g_score
    75    114.3 MiB      0.0 MiB       11780                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    114.3 MiB      0.0 MiB       11780                   if neighbor not in open_set_hash:
    77    114.3 MiB      0.0 MiB       11780                       count += 1
    78    114.3 MiB      0.0 MiB       11780                       open_set.put((f_score[neighbor], count, neighbor))
    79    114.3 MiB      0.0 MiB       11780                       open_set_hash.add(neighbor)
    80                                                             
    81    114.3 MiB      0.0 MiB       11175           if draw is not None:
    82                                                     draw()
    83                                         
    84    114.3 MiB      0.0 MiB       11175           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    114.4 MiB    114.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    114.4 MiB      0.0 MiB         257       for row in grid:
    32    114.4 MiB      0.0 MiB       65792           for spot in row:
    33    114.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    114.4 MiB      0.0 MiB           1       count = 0
    36    114.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    114.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    114.4 MiB      0.0 MiB           1       came_from = {}
    39    114.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    114.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    114.5 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    114.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    114.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    114.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    114.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    114.5 MiB      0.0 MiB        2232       while not open_set.empty():
    49    114.5 MiB      0.0 MiB        2232           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    114.5 MiB      0.0 MiB        2232           current = open_set.get()[2]
    55    114.5 MiB      0.0 MiB        2232           open_set_hash.remove(current)
    56                                         
    57    114.5 MiB      0.0 MiB        2232           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    114.5 MiB      0.0 MiB        2232           if current == end:
    62    114.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    114.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    114.5 MiB      0.0 MiB       20079           for neighbor in current.neighbors:
    67    114.5 MiB      0.0 MiB       17848               if current.row != neighbor.row and current.col != neighbor.col:
    68    114.5 MiB      0.0 MiB        8924                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    114.5 MiB      0.0 MiB        8924                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    114.5 MiB      0.0 MiB       17848               if temp_g_score < g_score[neighbor]:
    73    114.5 MiB      0.0 MiB        2512                   came_from[neighbor] = current
    74    114.5 MiB      0.0 MiB        2512                   g_score[neighbor] = temp_g_score
    75    114.5 MiB      0.0 MiB        2512                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    114.5 MiB      0.0 MiB        2512                   if neighbor not in open_set_hash:
    77    114.5 MiB      0.0 MiB        2512                       count += 1
    78    114.5 MiB      0.0 MiB        2512                       open_set.put((f_score[neighbor], count, neighbor))
    79    114.5 MiB      0.0 MiB        2512                       open_set_hash.add(neighbor)
    80                                                             
    81    114.5 MiB      0.0 MiB        2231           if draw is not None:
    82                                                     draw()
    83                                         
    84    114.5 MiB      0.0 MiB        2231           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    114.6 MiB    114.6 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    114.6 MiB      0.0 MiB         257       for row in grid:
    32    114.6 MiB      0.0 MiB       65792           for spot in row:
    33    114.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    114.6 MiB      0.0 MiB           1       count = 0
    36    114.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    114.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    114.6 MiB      0.0 MiB           1       came_from = {}
    39    114.6 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    114.6 MiB      0.0 MiB           1       g_score[start] = 0
    41    114.6 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    114.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    114.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    114.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    114.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    114.6 MiB      0.0 MiB        5120       while not open_set.empty():
    49    114.6 MiB      0.0 MiB        5120           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    114.6 MiB      0.0 MiB        5120           current = open_set.get()[2]
    55    114.6 MiB      0.0 MiB        5120           open_set_hash.remove(current)
    56                                         
    57    114.6 MiB      0.0 MiB        5120           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    114.6 MiB      0.0 MiB        5120           if current == end:
    62    114.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    114.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    114.6 MiB     -0.0 MiB       46071           for neighbor in current.neighbors:
    67    114.6 MiB      0.0 MiB       40952               if current.row != neighbor.row and current.col != neighbor.col:
    68    114.6 MiB      0.0 MiB       20476                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    114.6 MiB      0.0 MiB       20476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    114.6 MiB      0.0 MiB       40952               if temp_g_score < g_score[neighbor]:
    73    114.6 MiB      0.0 MiB        5534                   came_from[neighbor] = current
    74    114.6 MiB      0.0 MiB        5534                   g_score[neighbor] = temp_g_score
    75    114.6 MiB      0.0 MiB        5534                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    114.6 MiB      0.0 MiB        5534                   if neighbor not in open_set_hash:
    77    114.6 MiB      0.0 MiB        5534                       count += 1
    78    114.6 MiB      0.0 MiB        5534                       open_set.put((f_score[neighbor], count, neighbor))
    79    114.6 MiB      0.0 MiB        5534                       open_set_hash.add(neighbor)
    80                                                             
    81    114.6 MiB      0.0 MiB        5119           if draw is not None:
    82                                                     draw()
    83                                         
    84    114.6 MiB      0.0 MiB        5119           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    114.7 MiB    114.7 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    114.7 MiB      0.0 MiB         257       for row in grid:
    32    114.7 MiB      0.0 MiB       65792           for spot in row:
    33    114.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    114.7 MiB      0.0 MiB           1       count = 0
    36    114.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    114.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    114.7 MiB      0.0 MiB           1       came_from = {}
    39    114.7 MiB -12034.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    114.4 MiB     -0.3 MiB           1       g_score[start] = 0
    41    115.5 MiB -68908.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    112.1 MiB     -3.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    112.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    112.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    112.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    112.1 MiB -11589.7 MiB        1400       while not open_set.empty():
    49    112.1 MiB -11590.0 MiB        1400           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    112.1 MiB -11591.0 MiB        1400           current = open_set.get()[2]
    55    112.1 MiB -11591.4 MiB        1400           open_set_hash.remove(current)
    56                                         
    57    112.1 MiB -11591.5 MiB        1400           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    112.1 MiB -11592.1 MiB        1400           if current == end:
    62     96.5 MiB    -15.6 MiB           1               if draw:
    63                                                         end.make_end()
    64     96.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    112.1 MiB -104240.2 MiB       12591           for neighbor in current.neighbors:
    67    112.1 MiB -92653.6 MiB       11192               if current.row != neighbor.row and current.col != neighbor.col:
    68    112.1 MiB -46339.8 MiB        5596                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    112.1 MiB -46315.9 MiB        5596                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    112.1 MiB -92658.6 MiB       11192               if temp_g_score < g_score[neighbor]:
    73    112.1 MiB -12784.0 MiB        1610                   came_from[neighbor] = current
    74    112.1 MiB -12784.4 MiB        1610                   g_score[neighbor] = temp_g_score
    75    112.1 MiB -12784.4 MiB        1610                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    112.1 MiB -12784.7 MiB        1610                   if neighbor not in open_set_hash:
    77    112.1 MiB -12784.9 MiB        1610                       count += 1
    78    112.1 MiB -12785.4 MiB        1610                       open_set.put((f_score[neighbor], count, neighbor))
    79    112.1 MiB -12785.7 MiB        1610                       open_set_hash.add(neighbor)
    80                                                             
    81    112.1 MiB -11589.2 MiB        1399           if draw is not None:
    82                                                     draw()
    83                                         
    84    112.1 MiB -11589.5 MiB        1399           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    111.5 MiB    111.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    111.5 MiB  -1444.7 MiB         257       for row in grid:
    32    111.5 MiB -363658.0 MiB       65792           for spot in row:
    33    111.5 MiB -362251.7 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35     53.2 MiB    -58.2 MiB           1       count = 0
    36     53.6 MiB      0.3 MiB           1       open_set = PriorityQueue()
    37     53.8 MiB      0.2 MiB           1       open_set.put((0, count, start))
    38     53.8 MiB      0.0 MiB           1       came_from = {}
    39     53.9 MiB -1906401.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40     31.8 MiB    -22.0 MiB           1       g_score[start] = 0
    41     38.7 MiB      6.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42     38.9 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     38.9 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     38.9 MiB      0.0 MiB           1       cost_diagonal = 14
    46     38.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     41.1 MiB      0.0 MiB         490       while not open_set.empty():
    49     41.1 MiB      0.0 MiB         490           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     41.1 MiB      0.0 MiB         490           current = open_set.get()[2]
    55     41.1 MiB      0.0 MiB         490           open_set_hash.remove(current)
    56                                         
    57     41.1 MiB      0.0 MiB         490           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     41.1 MiB      0.0 MiB         490           if current == end:
    62     41.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     41.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     41.1 MiB      0.7 MiB        4401           for neighbor in current.neighbors:
    67     41.1 MiB      1.1 MiB        3912               if current.row != neighbor.row and current.col != neighbor.col:
    68     41.1 MiB      0.0 MiB        1956                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     41.1 MiB      0.0 MiB        1956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     41.1 MiB      0.0 MiB        3912               if temp_g_score < g_score[neighbor]:
    73     41.1 MiB      0.1 MiB         614                   came_from[neighbor] = current
    74     41.1 MiB      0.0 MiB         614                   g_score[neighbor] = temp_g_score
    75     41.1 MiB      0.0 MiB         614                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     41.1 MiB      0.0 MiB         614                   if neighbor not in open_set_hash:
    77     41.1 MiB      0.0 MiB         614                       count += 1
    78     41.1 MiB      0.1 MiB         614                       open_set.put((f_score[neighbor], count, neighbor))
    79     41.1 MiB      0.1 MiB         614                       open_set_hash.add(neighbor)
    80                                                             
    81     41.1 MiB      0.0 MiB         489           if draw is not None:
    82                                                     draw()
    83                                         
    84     41.1 MiB      0.0 MiB         489           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     96.6 MiB     96.6 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     96.6 MiB  -1292.2 MiB         257       for row in grid:
    32     96.6 MiB -331024.6 MiB       65792           for spot in row:
    33     96.6 MiB -329737.3 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35     89.4 MiB     -7.2 MiB           1       count = 0
    36     89.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     89.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     89.4 MiB      0.0 MiB           1       came_from = {}
    39     92.9 MiB  -5522.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40     92.8 MiB     -0.1 MiB           1       g_score[start] = 0
    41     96.5 MiB      3.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42     96.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     96.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     96.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46     96.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     96.5 MiB      0.0 MiB        1152       while not open_set.empty():
    49     96.5 MiB      0.0 MiB        1152           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     96.5 MiB      0.0 MiB        1152           current = open_set.get()[2]
    55     96.5 MiB      0.0 MiB        1152           open_set_hash.remove(current)
    56                                         
    57     96.5 MiB      0.0 MiB        1152           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     96.5 MiB      0.0 MiB        1152           if current == end:
    62     96.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     96.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     96.5 MiB      0.0 MiB       10359           for neighbor in current.neighbors:
    67     96.5 MiB      0.0 MiB        9208               if current.row != neighbor.row and current.col != neighbor.col:
    68     96.5 MiB      0.0 MiB        4604                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     96.5 MiB      0.0 MiB        4604                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     96.5 MiB      0.0 MiB        9208               if temp_g_score < g_score[neighbor]:
    73     96.5 MiB      0.1 MiB        1358                   came_from[neighbor] = current
    74     96.5 MiB      0.0 MiB        1358                   g_score[neighbor] = temp_g_score
    75     96.5 MiB      0.0 MiB        1358                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     96.5 MiB      0.0 MiB        1358                   if neighbor not in open_set_hash:
    77     96.5 MiB      0.0 MiB        1358                       count += 1
    78     96.5 MiB      0.0 MiB        1358                       open_set.put((f_score[neighbor], count, neighbor))
    79     96.5 MiB      0.0 MiB        1358                       open_set_hash.add(neighbor)
    80                                                             
    81     96.5 MiB      0.0 MiB        1151           if draw is not None:
    82                                                     draw()
    83                                         
    84     96.5 MiB      0.0 MiB        1151           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     97.2 MiB     97.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     97.2 MiB      0.0 MiB         257       for row in grid:
    32     97.2 MiB      0.0 MiB       65792           for spot in row:
    33     97.2 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35     97.2 MiB      0.0 MiB           1       count = 0
    36     97.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     97.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     97.2 MiB      0.0 MiB           1       came_from = {}
    39     97.2 MiB      0.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40     97.2 MiB      0.0 MiB           1       g_score[start] = 0
    41     99.7 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42     99.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     99.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     99.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46     99.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     99.8 MiB      0.0 MiB        2448       while not open_set.empty():
    49     99.8 MiB      0.0 MiB        2448           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     99.8 MiB      0.0 MiB        2448           current = open_set.get()[2]
    55     99.8 MiB      0.0 MiB        2448           open_set_hash.remove(current)
    56                                         
    57     99.8 MiB      0.0 MiB        2448           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     99.8 MiB      0.0 MiB        2448           if current == end:
    62     99.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64     99.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     99.8 MiB      0.0 MiB       22023           for neighbor in current.neighbors:
    67     99.8 MiB      0.0 MiB       19576               if current.row != neighbor.row and current.col != neighbor.col:
    68     99.8 MiB      0.0 MiB        9788                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     99.8 MiB      0.0 MiB        9788                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     99.8 MiB      0.0 MiB       19576               if temp_g_score < g_score[neighbor]:
    73     99.8 MiB      0.0 MiB        2790                   came_from[neighbor] = current
    74     99.8 MiB      0.0 MiB        2790                   g_score[neighbor] = temp_g_score
    75     99.8 MiB      0.0 MiB        2790                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     99.8 MiB      0.0 MiB        2790                   if neighbor not in open_set_hash:
    77     99.8 MiB      0.0 MiB        2790                       count += 1
    78     99.8 MiB      0.0 MiB        2790                       open_set.put((f_score[neighbor], count, neighbor))
    79     99.8 MiB      0.0 MiB        2790                       open_set_hash.add(neighbor)
    80                                                             
    81     99.8 MiB      0.0 MiB        2447           if draw is not None:
    82                                                     draw()
    83                                         
    84     99.8 MiB      0.0 MiB        2447           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     99.9 MiB     99.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     99.9 MiB      0.0 MiB         257       for row in grid:
    32     99.9 MiB      0.0 MiB       65792           for spot in row:
    33     99.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35     99.9 MiB      0.0 MiB           1       count = 0
    36     99.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     99.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     99.9 MiB      0.0 MiB           1       came_from = {}
    39     99.9 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40     99.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    102.4 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    102.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    102.4 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    102.4 MiB      0.0 MiB           1       cost_diagonal = 14
    46    102.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    102.4 MiB      0.0 MiB         576       while not open_set.empty():
    49    102.4 MiB      0.0 MiB         576           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    102.4 MiB      0.0 MiB         576           current = open_set.get()[2]
    55    102.4 MiB      0.0 MiB         576           open_set_hash.remove(current)
    56                                         
    57    102.4 MiB      0.0 MiB         576           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    102.4 MiB      0.0 MiB         576           if current == end:
    62    102.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    102.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    102.4 MiB      0.0 MiB        5175           for neighbor in current.neighbors:
    67    102.4 MiB      0.0 MiB        4600               if current.row != neighbor.row and current.col != neighbor.col:
    68    102.4 MiB      0.0 MiB        2300                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    102.4 MiB      0.0 MiB        2300                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    102.4 MiB      0.0 MiB        4600               if temp_g_score < g_score[neighbor]:
    73    102.4 MiB      0.0 MiB         738                   came_from[neighbor] = current
    74    102.4 MiB      0.0 MiB         738                   g_score[neighbor] = temp_g_score
    75    102.4 MiB      0.0 MiB         738                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    102.4 MiB      0.0 MiB         738                   if neighbor not in open_set_hash:
    77    102.4 MiB      0.0 MiB         738                       count += 1
    78    102.4 MiB      0.0 MiB         738                       open_set.put((f_score[neighbor], count, neighbor))
    79    102.4 MiB      0.0 MiB         738                       open_set_hash.add(neighbor)
    80                                                             
    81    102.4 MiB      0.0 MiB         575           if draw is not None:
    82                                                     draw()
    83                                         
    84    102.4 MiB      0.0 MiB         575           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    102.9 MiB    102.9 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    102.9 MiB      0.0 MiB         257       for row in grid:
    32    102.9 MiB      0.0 MiB       65792           for spot in row:
    33    102.9 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    102.9 MiB      0.0 MiB           1       count = 0
    36    102.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    102.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    102.9 MiB      0.0 MiB           1       came_from = {}
    39    107.8 MiB      4.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    107.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    107.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    107.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    107.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    107.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    107.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    107.8 MiB      0.0 MiB         184       while not open_set.empty():
    49    107.8 MiB      0.0 MiB         184           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    107.8 MiB      0.0 MiB         184           current = open_set.get()[2]
    55    107.8 MiB      0.0 MiB         184           open_set_hash.remove(current)
    56                                         
    57    107.8 MiB      0.0 MiB         184           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    107.8 MiB      0.0 MiB         184           if current == end:
    62    107.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    107.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    107.8 MiB      0.0 MiB        1647           for neighbor in current.neighbors:
    67    107.8 MiB      0.0 MiB        1464               if current.row != neighbor.row and current.col != neighbor.col:
    68    107.8 MiB      0.0 MiB         732                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    107.8 MiB      0.0 MiB         732                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    107.8 MiB      0.0 MiB        1464               if temp_g_score < g_score[neighbor]:
    73    107.8 MiB      0.0 MiB         374                   came_from[neighbor] = current
    74    107.8 MiB      0.0 MiB         374                   g_score[neighbor] = temp_g_score
    75    107.8 MiB      0.0 MiB         374                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    107.8 MiB      0.0 MiB         374                   if neighbor not in open_set_hash:
    77    107.8 MiB      0.0 MiB         374                       count += 1
    78    107.8 MiB      0.0 MiB         374                       open_set.put((f_score[neighbor], count, neighbor))
    79    107.8 MiB      0.0 MiB         374                       open_set_hash.add(neighbor)
    80                                                             
    81    107.8 MiB      0.0 MiB         183           if draw is not None:
    82                                                     draw()
    83                                         
    84    107.8 MiB      0.0 MiB         183           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    107.8 MiB    107.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    107.8 MiB      0.0 MiB         257       for row in grid:
    32    107.8 MiB      0.0 MiB       65792           for spot in row:
    33    107.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    107.8 MiB      0.0 MiB           1       count = 0
    36    107.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    107.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    107.8 MiB      0.0 MiB           1       came_from = {}
    39    107.9 MiB      0.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    107.9 MiB      0.0 MiB           1       g_score[start] = 0
    41    109.5 MiB      1.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    109.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    109.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    109.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    109.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    109.5 MiB      0.0 MiB           6       while not open_set.empty():
    49    109.5 MiB      0.0 MiB           6           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    109.5 MiB      0.0 MiB           6           current = open_set.get()[2]
    55    109.5 MiB      0.0 MiB           6           open_set_hash.remove(current)
    56                                         
    57    109.5 MiB      0.0 MiB           6           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    109.5 MiB      0.0 MiB           6           if current == end:
    62    109.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    109.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    109.5 MiB      0.0 MiB          45           for neighbor in current.neighbors:
    67    109.5 MiB      0.0 MiB          40               if current.row != neighbor.row and current.col != neighbor.col:
    68    109.5 MiB      0.0 MiB          20                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    109.5 MiB      0.0 MiB          20                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    109.5 MiB      0.0 MiB          40               if temp_g_score < g_score[neighbor]:
    73    109.5 MiB      0.0 MiB          18                   came_from[neighbor] = current
    74    109.5 MiB      0.0 MiB          18                   g_score[neighbor] = temp_g_score
    75    109.5 MiB      0.0 MiB          18                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    109.5 MiB      0.0 MiB          18                   if neighbor not in open_set_hash:
    77    109.5 MiB      0.0 MiB          18                       count += 1
    78    109.5 MiB      0.0 MiB          18                       open_set.put((f_score[neighbor], count, neighbor))
    79    109.5 MiB      0.0 MiB          18                       open_set_hash.add(neighbor)
    80                                                             
    81    109.5 MiB      0.0 MiB           5           if draw is not None:
    82                                                     draw()
    83                                         
    84    109.5 MiB      0.0 MiB           5           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    109.8 MiB    109.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    109.8 MiB      0.0 MiB         257       for row in grid:
    32    109.8 MiB      0.0 MiB       65792           for spot in row:
    33    109.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    109.8 MiB      0.0 MiB           1       count = 0
    36    109.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    109.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    109.8 MiB      0.0 MiB           1       came_from = {}
    39    109.8 MiB      0.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    109.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    109.8 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    109.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    109.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    109.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    109.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    109.9 MiB      0.0 MiB        3780       while not open_set.empty():
    49    109.9 MiB      0.0 MiB        3780           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    109.9 MiB      0.0 MiB        3780           current = open_set.get()[2]
    55    109.9 MiB      0.0 MiB        3780           open_set_hash.remove(current)
    56                                         
    57    109.9 MiB      0.0 MiB        3780           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    109.9 MiB      0.0 MiB        3780           if current == end:
    62    109.9 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    109.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    109.9 MiB      0.0 MiB       34011           for neighbor in current.neighbors:
    67    109.9 MiB      0.0 MiB       30232               if current.row != neighbor.row and current.col != neighbor.col:
    68    109.9 MiB      0.0 MiB       15116                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    109.9 MiB      0.0 MiB       15116                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    109.9 MiB      0.0 MiB       30232               if temp_g_score < g_score[neighbor]:
    73    109.9 MiB      0.0 MiB        4134                   came_from[neighbor] = current
    74    109.9 MiB      0.0 MiB        4134                   g_score[neighbor] = temp_g_score
    75    109.9 MiB      0.0 MiB        4134                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    109.9 MiB      0.0 MiB        4134                   if neighbor not in open_set_hash:
    77    109.9 MiB      0.0 MiB        4134                       count += 1
    78    109.9 MiB      0.0 MiB        4134                       open_set.put((f_score[neighbor], count, neighbor))
    79    109.9 MiB      0.0 MiB        4134                       open_set_hash.add(neighbor)
    80                                                             
    81    109.9 MiB      0.0 MiB        3779           if draw is not None:
    82                                                     draw()
    83                                         
    84    109.9 MiB      0.0 MiB        3779           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    112.2 MiB    112.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    112.2 MiB  -1579.2 MiB         257       for row in grid:
    32    112.2 MiB -404941.4 MiB       65792           for spot in row:
    33    112.2 MiB -403367.3 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    105.3 MiB     -6.9 MiB           1       count = 0
    36    105.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    105.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    105.3 MiB      0.0 MiB           1       came_from = {}
    39    108.6 MiB   -676.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    108.6 MiB     -0.0 MiB           1       g_score[start] = 0
    41    111.6 MiB -16421.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    108.0 MiB     -3.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    108.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    108.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    108.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    108.0 MiB -55266.1 MiB        7980       while not open_set.empty():
    49    108.0 MiB -55266.2 MiB        7980           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    108.0 MiB -55266.4 MiB        7980           current = open_set.get()[2]
    55    108.0 MiB -55266.5 MiB        7980           open_set_hash.remove(current)
    56                                         
    57    108.0 MiB -55266.7 MiB        7980           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    108.0 MiB -55266.8 MiB        7980           if current == end:
    62    100.6 MiB     -7.4 MiB           1               if draw:
    63                                                         end.make_end()
    64    100.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    108.0 MiB -497354.6 MiB       71811           for neighbor in current.neighbors:
    67    108.0 MiB -442090.7 MiB       63832               if current.row != neighbor.row and current.col != neighbor.col:
    68    108.0 MiB -221053.9 MiB       31916                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    108.0 MiB -221038.9 MiB       31916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    108.0 MiB -442092.9 MiB       63832               if temp_g_score < g_score[neighbor]:
    73    108.0 MiB -58098.5 MiB        8492                   came_from[neighbor] = current
    74    108.0 MiB -58098.6 MiB        8492                   g_score[neighbor] = temp_g_score
    75    108.0 MiB -58098.3 MiB        8492                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    108.0 MiB -58098.5 MiB        8492                   if neighbor not in open_set_hash:
    77    108.0 MiB -58098.6 MiB        8492                       count += 1
    78    108.0 MiB -58098.9 MiB        8492                       open_set.put((f_score[neighbor], count, neighbor))
    79    108.0 MiB -58099.0 MiB        8492                       open_set_hash.add(neighbor)
    80                                                             
    81    108.0 MiB -55265.9 MiB        7979           if draw is not None:
    82                                                     draw()
    83                                         
    84    108.0 MiB -55265.9 MiB        7979           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    101.3 MiB    101.3 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    101.3 MiB      0.0 MiB         257       for row in grid:
    32    101.3 MiB      0.0 MiB       65792           for spot in row:
    33    101.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    101.3 MiB      0.0 MiB           1       count = 0
    36    101.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    101.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    101.3 MiB      0.0 MiB           1       came_from = {}
    39    102.6 MiB      1.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    102.6 MiB      0.0 MiB           1       g_score[start] = 0
    41    107.0 MiB      4.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    107.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    107.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    107.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    107.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    107.0 MiB      0.0 MiB        6032       while not open_set.empty():
    49    107.0 MiB      0.0 MiB        6032           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    107.0 MiB      0.0 MiB        6032           current = open_set.get()[2]
    55    107.0 MiB      0.0 MiB        6032           open_set_hash.remove(current)
    56                                         
    57    107.0 MiB      0.0 MiB        6032           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    107.0 MiB      0.0 MiB        6032           if current == end:
    62    107.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    107.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    107.0 MiB      0.0 MiB       54279           for neighbor in current.neighbors:
    67    107.0 MiB      0.0 MiB       48248               if current.row != neighbor.row and current.col != neighbor.col:
    68    107.0 MiB      0.0 MiB       24124                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    107.0 MiB      0.0 MiB       24124                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    107.0 MiB      0.0 MiB       48248               if temp_g_score < g_score[neighbor]:
    73    107.0 MiB      0.0 MiB        6470                   came_from[neighbor] = current
    74    107.0 MiB      0.0 MiB        6470                   g_score[neighbor] = temp_g_score
    75    107.0 MiB      0.0 MiB        6470                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    107.0 MiB      0.0 MiB        6470                   if neighbor not in open_set_hash:
    77    107.0 MiB      0.0 MiB        6470                       count += 1
    78    107.0 MiB      0.0 MiB        6470                       open_set.put((f_score[neighbor], count, neighbor))
    79    107.0 MiB      0.0 MiB        6470                       open_set_hash.add(neighbor)
    80                                                             
    81    107.0 MiB      0.0 MiB        6031           if draw is not None:
    82                                                     draw()
    83                                         
    84    107.0 MiB      0.0 MiB        6031           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    107.0 MiB    107.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    107.0 MiB      0.0 MiB         257       for row in grid:
    32    107.0 MiB      0.0 MiB       65792           for spot in row:
    33    107.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    107.0 MiB      0.0 MiB           1       count = 0
    36    107.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    107.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    107.0 MiB      0.0 MiB           1       came_from = {}
    39    107.8 MiB      0.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    107.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    108.2 MiB      0.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    108.2 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    108.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    108.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46    108.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    108.4 MiB      0.0 MiB        7056       while not open_set.empty():
    49    108.4 MiB      0.0 MiB        7056           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    108.4 MiB      0.0 MiB        7056           current = open_set.get()[2]
    55    108.4 MiB      0.0 MiB        7056           open_set_hash.remove(current)
    56                                         
    57    108.4 MiB      0.0 MiB        7056           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    108.4 MiB      0.0 MiB        7056           if current == end:
    62    108.4 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    108.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    108.4 MiB      0.0 MiB       63495           for neighbor in current.neighbors:
    67    108.4 MiB      0.0 MiB       56440               if current.row != neighbor.row and current.col != neighbor.col:
    68    108.4 MiB      0.0 MiB       28220                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    108.4 MiB      0.0 MiB       28220                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    108.4 MiB      0.0 MiB       56440               if temp_g_score < g_score[neighbor]:
    73    108.4 MiB      0.1 MiB        7538                   came_from[neighbor] = current
    74    108.4 MiB      0.0 MiB        7538                   g_score[neighbor] = temp_g_score
    75    108.4 MiB      0.0 MiB        7538                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    108.4 MiB      0.0 MiB        7538                   if neighbor not in open_set_hash:
    77    108.4 MiB      0.0 MiB        7538                       count += 1
    78    108.4 MiB      0.0 MiB        7538                       open_set.put((f_score[neighbor], count, neighbor))
    79    108.4 MiB      0.0 MiB        7538                       open_set_hash.add(neighbor)
    80                                                             
    81    108.4 MiB      0.0 MiB        7055           if draw is not None:
    82                                                     draw()
    83                                         
    84    108.4 MiB      0.0 MiB        7055           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    108.4 MiB    108.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    108.4 MiB      0.0 MiB         257       for row in grid:
    32    108.4 MiB      0.0 MiB       65792           for spot in row:
    33    108.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    108.4 MiB      0.0 MiB           1       count = 0
    36    108.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    108.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    108.4 MiB      0.0 MiB           1       came_from = {}
    39    108.4 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    108.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    112.0 MiB      3.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    112.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    112.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    112.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    112.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    112.0 MiB      0.0 MiB         574       while not open_set.empty():
    49    112.0 MiB      0.0 MiB         574           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    112.0 MiB      0.0 MiB         574           current = open_set.get()[2]
    55    112.0 MiB      0.0 MiB         574           open_set_hash.remove(current)
    56                                         
    57    112.0 MiB      0.0 MiB         574           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    112.0 MiB      0.0 MiB         574           if current == end:
    62    112.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    112.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    112.0 MiB      0.0 MiB        5157           for neighbor in current.neighbors:
    67    112.0 MiB      0.0 MiB        4584               if current.row != neighbor.row and current.col != neighbor.col:
    68    112.0 MiB      0.0 MiB        2292                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    112.0 MiB      0.0 MiB        2292                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    112.0 MiB      0.0 MiB        4584               if temp_g_score < g_score[neighbor]:
    73    112.0 MiB      0.0 MiB         764                   came_from[neighbor] = current
    74    112.0 MiB      0.0 MiB         764                   g_score[neighbor] = temp_g_score
    75    112.0 MiB      0.0 MiB         764                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    112.0 MiB      0.0 MiB         764                   if neighbor not in open_set_hash:
    77    112.0 MiB      0.0 MiB         764                       count += 1
    78    112.0 MiB      0.0 MiB         764                       open_set.put((f_score[neighbor], count, neighbor))
    79    112.0 MiB      0.0 MiB         764                       open_set_hash.add(neighbor)
    80                                                             
    81    112.0 MiB      0.0 MiB         573           if draw is not None:
    82                                                     draw()
    83                                         
    84    112.0 MiB      0.0 MiB         573           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    112.1 MiB    112.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    112.1 MiB      0.0 MiB         257       for row in grid:
    32    112.1 MiB      0.0 MiB       65792           for spot in row:
    33    112.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    112.1 MiB      0.0 MiB           1       count = 0
    36    112.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    112.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    112.1 MiB      0.0 MiB           1       came_from = {}
    39    113.4 MiB      1.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    113.4 MiB      0.0 MiB           1       g_score[start] = 0
    41    113.6 MiB      0.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    113.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    113.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    113.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    113.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    113.6 MiB      0.0 MiB        4500       while not open_set.empty():
    49    113.6 MiB      0.0 MiB        4500           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    113.6 MiB      0.0 MiB        4500           current = open_set.get()[2]
    55    113.6 MiB      0.0 MiB        4500           open_set_hash.remove(current)
    56                                         
    57    113.6 MiB      0.0 MiB        4500           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    113.6 MiB      0.0 MiB        4500           if current == end:
    62    113.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    113.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    113.6 MiB      0.0 MiB       40491           for neighbor in current.neighbors:
    67    113.6 MiB      0.0 MiB       35992               if current.row != neighbor.row and current.col != neighbor.col:
    68    113.6 MiB      0.0 MiB       17996                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    113.6 MiB      0.0 MiB       17996                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    113.6 MiB      0.0 MiB       35992               if temp_g_score < g_score[neighbor]:
    73    113.6 MiB      0.0 MiB        4878                   came_from[neighbor] = current
    74    113.6 MiB      0.0 MiB        4878                   g_score[neighbor] = temp_g_score
    75    113.6 MiB      0.0 MiB        4878                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    113.6 MiB      0.0 MiB        4878                   if neighbor not in open_set_hash:
    77    113.6 MiB      0.0 MiB        4878                       count += 1
    78    113.6 MiB      0.0 MiB        4878                       open_set.put((f_score[neighbor], count, neighbor))
    79    113.6 MiB      0.0 MiB        4878                       open_set_hash.add(neighbor)
    80                                                             
    81    113.6 MiB      0.0 MiB        4499           if draw is not None:
    82                                                     draw()
    83                                         
    84    113.6 MiB      0.0 MiB        4499           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    113.6 MiB    113.6 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    113.6 MiB      0.0 MiB         257       for row in grid:
    32    113.6 MiB      0.0 MiB       65792           for spot in row:
    33    113.6 MiB     -0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    113.6 MiB      0.0 MiB           1       count = 0
    36    113.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    113.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    113.6 MiB      0.0 MiB           1       came_from = {}
    39    116.1 MiB      2.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    116.1 MiB      0.0 MiB           1       g_score[start] = 0
    41    116.1 MiB  -8949.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    114.1 MiB     -2.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    114.1 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    114.1 MiB      0.0 MiB           1       cost_diagonal = 14
    46    114.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    114.1 MiB      0.0 MiB          88       while not open_set.empty():
    49    114.1 MiB      0.0 MiB          88           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    114.1 MiB      0.0 MiB          88           current = open_set.get()[2]
    55    114.1 MiB      0.0 MiB          88           open_set_hash.remove(current)
    56                                         
    57    114.1 MiB      0.0 MiB          88           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    114.1 MiB      0.0 MiB          88           if current == end:
    62    114.1 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    114.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    114.1 MiB      0.0 MiB         783           for neighbor in current.neighbors:
    67    114.1 MiB      0.0 MiB         696               if current.row != neighbor.row and current.col != neighbor.col:
    68    114.1 MiB      0.0 MiB         348                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    114.1 MiB      0.0 MiB         348                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    114.1 MiB      0.0 MiB         696               if temp_g_score < g_score[neighbor]:
    73    114.1 MiB      0.0 MiB         182                   came_from[neighbor] = current
    74    114.1 MiB      0.0 MiB         182                   g_score[neighbor] = temp_g_score
    75    114.1 MiB      0.0 MiB         182                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    114.1 MiB      0.0 MiB         182                   if neighbor not in open_set_hash:
    77    114.1 MiB      0.0 MiB         182                       count += 1
    78    114.1 MiB      0.0 MiB         182                       open_set.put((f_score[neighbor], count, neighbor))
    79    114.1 MiB      0.0 MiB         182                       open_set_hash.add(neighbor)
    80                                                             
    81    114.1 MiB      0.0 MiB          87           if draw is not None:
    82                                                     draw()
    83                                         
    84    114.1 MiB      0.0 MiB          87           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    114.2 MiB    114.2 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    114.2 MiB -14324.3 MiB         257       for row in grid:
    32    114.2 MiB -3673932.8 MiB       65792           for spot in row:
    33    114.2 MiB -3659641.8 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35     56.5 MiB    -57.7 MiB           1       count = 0
    36     56.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     56.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     56.5 MiB      0.0 MiB           1       came_from = {}
    39     62.7 MiB   -209.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40     62.7 MiB      0.0 MiB           1       g_score[start] = 0
    41     66.4 MiB      3.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42     66.6 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43     66.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45     66.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46     66.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48     66.8 MiB -16282.1 MiB        6700       while not open_set.empty():
    49     66.8 MiB -16282.2 MiB        6700           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54     66.8 MiB -16282.3 MiB        6700           current = open_set.get()[2]
    55     66.8 MiB -16282.6 MiB        6700           open_set_hash.remove(current)
    56                                         
    57     66.8 MiB -16282.7 MiB        6700           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61     66.8 MiB -16282.7 MiB        6700           if current == end:
    62     63.0 MiB     -3.8 MiB           1               if draw:
    63                                                         end.make_end()
    64     63.1 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66     66.8 MiB -146525.4 MiB       60291           for neighbor in current.neighbors:
    67     66.8 MiB -130244.0 MiB       53592               if current.row != neighbor.row and current.col != neighbor.col:
    68     66.8 MiB -65125.5 MiB       26796                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70     66.8 MiB -65119.2 MiB       26796                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72     66.8 MiB -130245.5 MiB       53592               if temp_g_score < g_score[neighbor]:
    73     66.8 MiB -17135.3 MiB        7166                   came_from[neighbor] = current
    74     66.8 MiB -17135.3 MiB        7166                   g_score[neighbor] = temp_g_score
    75     66.8 MiB -17135.4 MiB        7166                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76     66.8 MiB -17135.5 MiB        7166                   if neighbor not in open_set_hash:
    77     66.8 MiB -17135.5 MiB        7166                       count += 1
    78     66.8 MiB -17135.7 MiB        7166                       open_set.put((f_score[neighbor], count, neighbor))
    79     66.8 MiB -17135.7 MiB        7166                       open_set_hash.add(neighbor)
    80                                                             
    81     66.8 MiB -16282.0 MiB        6699           if draw is not None:
    82                                                     draw()
    83                                         
    84     66.8 MiB -16282.1 MiB        6699           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28     95.7 MiB     95.7 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31     95.7 MiB      0.0 MiB         257       for row in grid:
    32     95.7 MiB      0.0 MiB       65792           for spot in row:
    33     95.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35     95.7 MiB      0.0 MiB           1       count = 0
    36     95.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37     95.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38     95.7 MiB      0.0 MiB           1       came_from = {}
    39     98.8 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40     98.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    101.7 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    101.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    101.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    101.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46    101.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    101.7 MiB      0.0 MiB        2262       while not open_set.empty():
    49    101.7 MiB      0.0 MiB        2262           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    101.7 MiB      0.0 MiB        2262           current = open_set.get()[2]
    55    101.7 MiB      0.0 MiB        2262           open_set_hash.remove(current)
    56                                         
    57    101.7 MiB      0.0 MiB        2262           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    101.7 MiB      0.0 MiB        2262           if current == end:
    62    101.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    101.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    101.7 MiB      0.0 MiB       20349           for neighbor in current.neighbors:
    67    101.7 MiB      0.0 MiB       18088               if current.row != neighbor.row and current.col != neighbor.col:
    68    101.7 MiB      0.0 MiB        9044                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    101.7 MiB      0.0 MiB        9044                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    101.7 MiB      0.0 MiB       18088               if temp_g_score < g_score[neighbor]:
    73    101.7 MiB      0.0 MiB        2570                   came_from[neighbor] = current
    74    101.7 MiB      0.0 MiB        2570                   g_score[neighbor] = temp_g_score
    75    101.7 MiB      0.0 MiB        2570                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    101.7 MiB      0.0 MiB        2570                   if neighbor not in open_set_hash:
    77    101.7 MiB      0.0 MiB        2570                       count += 1
    78    101.7 MiB      0.0 MiB        2570                       open_set.put((f_score[neighbor], count, neighbor))
    79    101.7 MiB      0.0 MiB        2570                       open_set_hash.add(neighbor)
    80                                                             
    81    101.7 MiB      0.0 MiB        2261           if draw is not None:
    82                                                     draw()
    83                                         
    84    101.7 MiB      0.0 MiB        2261           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    105.5 MiB    105.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    105.8 MiB      0.0 MiB         257       for row in grid:
    32    105.8 MiB      0.0 MiB       65792           for spot in row:
    33    105.8 MiB      0.3 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    105.8 MiB      0.0 MiB           1       count = 0
    36    105.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    105.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    105.8 MiB      0.0 MiB           1       came_from = {}
    39    105.8 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    105.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    106.3 MiB      0.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    106.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    106.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    106.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46    106.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    106.3 MiB      0.0 MiB         711       while not open_set.empty():
    49    106.3 MiB      0.0 MiB         711           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    106.3 MiB      0.0 MiB         711           current = open_set.get()[2]
    55    106.3 MiB      0.0 MiB         711           open_set_hash.remove(current)
    56                                         
    57    106.3 MiB      0.0 MiB         711           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    106.3 MiB      0.0 MiB         711           if current == end:
    62    106.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    106.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    106.3 MiB      0.0 MiB        6390           for neighbor in current.neighbors:
    67    106.3 MiB      0.0 MiB        5680               if current.row != neighbor.row and current.col != neighbor.col:
    68    106.3 MiB      0.0 MiB        2840                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    106.3 MiB      0.0 MiB        2840                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    106.3 MiB      0.0 MiB        5680               if temp_g_score < g_score[neighbor]:
    73    106.3 MiB      0.0 MiB        1043                   came_from[neighbor] = current
    74    106.3 MiB      0.0 MiB        1043                   g_score[neighbor] = temp_g_score
    75    106.3 MiB      0.0 MiB        1043                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    106.3 MiB      0.0 MiB        1043                   if neighbor not in open_set_hash:
    77    106.3 MiB      0.0 MiB        1043                       count += 1
    78    106.3 MiB      0.0 MiB        1043                       open_set.put((f_score[neighbor], count, neighbor))
    79    106.3 MiB      0.0 MiB        1043                       open_set_hash.add(neighbor)
    80                                                             
    81    106.3 MiB      0.0 MiB         710           if draw is not None:
    82                                                     draw()
    83                                         
    84    106.3 MiB      0.0 MiB         710           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    106.4 MiB    106.4 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    106.4 MiB      0.0 MiB         257       for row in grid:
    32    106.4 MiB      0.0 MiB       65792           for spot in row:
    33    106.4 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    106.4 MiB      0.0 MiB           1       count = 0
    36    106.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    106.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    106.4 MiB      0.0 MiB           1       came_from = {}
    39    109.6 MiB      3.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    109.6 MiB      0.0 MiB           1       g_score[start] = 0
    41    113.3 MiB      3.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    113.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    113.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    113.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46    113.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    113.5 MiB      0.0 MiB        1952       while not open_set.empty():
    49    113.5 MiB      0.0 MiB        1952           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    113.5 MiB      0.0 MiB        1952           current = open_set.get()[2]
    55    113.5 MiB      0.0 MiB        1952           open_set_hash.remove(current)
    56                                         
    57    113.5 MiB      0.0 MiB        1952           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    113.5 MiB      0.0 MiB        1952           if current == end:
    62    113.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    113.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    113.5 MiB      0.0 MiB       17559           for neighbor in current.neighbors:
    67    113.5 MiB      0.0 MiB       15608               if current.row != neighbor.row and current.col != neighbor.col:
    68    113.5 MiB      0.0 MiB        7804                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    113.5 MiB      0.0 MiB        7804                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    113.5 MiB      0.0 MiB       15608               if temp_g_score < g_score[neighbor]:
    73    113.5 MiB      0.1 MiB        2200                   came_from[neighbor] = current
    74    113.5 MiB      0.0 MiB        2200                   g_score[neighbor] = temp_g_score
    75    113.5 MiB      0.0 MiB        2200                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    113.5 MiB      0.0 MiB        2200                   if neighbor not in open_set_hash:
    77    113.5 MiB      0.0 MiB        2200                       count += 1
    78    113.5 MiB      0.0 MiB        2200                       open_set.put((f_score[neighbor], count, neighbor))
    79    113.5 MiB      0.0 MiB        2200                       open_set_hash.add(neighbor)
    80                                                             
    81    113.5 MiB      0.0 MiB        1951           if draw is not None:
    82                                                     draw()
    83                                         
    84    113.5 MiB      0.0 MiB        1951           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    113.7 MiB    113.7 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    113.7 MiB      0.0 MiB         257       for row in grid:
    32    113.7 MiB      0.0 MiB       65792           for spot in row:
    33    113.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    113.7 MiB      0.0 MiB           1       count = 0
    36    113.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    113.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    113.7 MiB      0.0 MiB           1       came_from = {}
    39    114.6 MiB      0.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    114.6 MiB      0.0 MiB           1       g_score[start] = 0
    41    114.6 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    114.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    114.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    114.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    114.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    114.6 MiB      0.0 MiB        8686       while not open_set.empty():
    49    114.6 MiB      0.0 MiB        8686           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    114.6 MiB      0.0 MiB        8686           current = open_set.get()[2]
    55    114.6 MiB      0.0 MiB        8686           open_set_hash.remove(current)
    56                                         
    57    114.6 MiB      0.0 MiB        8686           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    114.6 MiB      0.0 MiB        8686           if current == end:
    62    114.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    114.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    114.6 MiB      0.0 MiB       78165           for neighbor in current.neighbors:
    67    114.6 MiB      0.0 MiB       69480               if current.row != neighbor.row and current.col != neighbor.col:
    68    114.6 MiB      0.0 MiB       34740                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    114.6 MiB      0.0 MiB       34740                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    114.6 MiB      0.0 MiB       69480               if temp_g_score < g_score[neighbor]:
    73    114.6 MiB      0.0 MiB        9230                   came_from[neighbor] = current
    74    114.6 MiB      0.0 MiB        9230                   g_score[neighbor] = temp_g_score
    75    114.6 MiB      0.0 MiB        9230                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    114.6 MiB      0.0 MiB        9230                   if neighbor not in open_set_hash:
    77    114.6 MiB      0.0 MiB        9230                       count += 1
    78    114.6 MiB      0.0 MiB        9230                       open_set.put((f_score[neighbor], count, neighbor))
    79    114.6 MiB      0.0 MiB        9230                       open_set_hash.add(neighbor)
    80                                                             
    81    114.6 MiB      0.0 MiB        8685           if draw is not None:
    82                                                     draw()
    83                                         
    84    114.6 MiB      0.0 MiB        8685           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    114.6 MiB    114.6 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    114.6 MiB      0.0 MiB         257       for row in grid:
    32    114.6 MiB      0.0 MiB       65792           for spot in row:
    33    114.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    114.6 MiB      0.0 MiB           1       count = 0
    36    114.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    114.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    114.6 MiB      0.0 MiB           1       came_from = {}
    39    114.6 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    114.6 MiB      0.0 MiB           1       g_score[start] = 0
    41    114.6 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    114.6 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    114.6 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    114.6 MiB      0.0 MiB           1       cost_diagonal = 14
    46    114.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    114.6 MiB      0.0 MiB        6370       while not open_set.empty():
    49    114.6 MiB      0.0 MiB        6370           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    114.6 MiB      0.0 MiB        6370           current = open_set.get()[2]
    55    114.6 MiB      0.0 MiB        6370           open_set_hash.remove(current)
    56                                         
    57    114.6 MiB      0.0 MiB        6370           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    114.6 MiB      0.0 MiB        6370           if current == end:
    62    114.6 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    114.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    114.6 MiB      0.0 MiB       57321           for neighbor in current.neighbors:
    67    114.6 MiB      0.0 MiB       50952               if current.row != neighbor.row and current.col != neighbor.col:
    68    114.6 MiB      0.0 MiB       25476                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    114.6 MiB      0.0 MiB       25476                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    114.6 MiB      0.0 MiB       50952               if temp_g_score < g_score[neighbor]:
    73    114.6 MiB      0.0 MiB        6872                   came_from[neighbor] = current
    74    114.6 MiB      0.0 MiB        6872                   g_score[neighbor] = temp_g_score
    75    114.6 MiB      0.0 MiB        6872                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    114.6 MiB      0.0 MiB        6872                   if neighbor not in open_set_hash:
    77    114.6 MiB      0.0 MiB        6872                       count += 1
    78    114.6 MiB      0.0 MiB        6872                       open_set.put((f_score[neighbor], count, neighbor))
    79    114.6 MiB      0.0 MiB        6872                       open_set_hash.add(neighbor)
    80                                                             
    81    114.6 MiB      0.0 MiB        6369           if draw is not None:
    82                                                     draw()
    83                                         
    84    114.6 MiB      0.0 MiB        6369           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    114.6 MiB    114.6 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    114.6 MiB      0.0 MiB         257       for row in grid:
    32    114.6 MiB      0.0 MiB       65792           for spot in row:
    33    114.6 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    114.6 MiB      0.0 MiB           1       count = 0
    36    114.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    114.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    114.6 MiB      0.0 MiB           1       came_from = {}
    39    114.7 MiB      0.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    114.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    114.7 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    114.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    114.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    114.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46    114.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    114.7 MiB      0.0 MiB        2064       while not open_set.empty():
    49    114.7 MiB      0.0 MiB        2064           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    114.7 MiB      0.0 MiB        2064           current = open_set.get()[2]
    55    114.7 MiB      0.0 MiB        2064           open_set_hash.remove(current)
    56                                         
    57    114.7 MiB      0.0 MiB        2064           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    114.7 MiB      0.0 MiB        2064           if current == end:
    62    114.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    114.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    114.7 MiB      0.0 MiB       18567           for neighbor in current.neighbors:
    67    114.7 MiB      0.0 MiB       16504               if current.row != neighbor.row and current.col != neighbor.col:
    68    114.7 MiB      0.0 MiB        8252                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    114.7 MiB      0.0 MiB        8252                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    114.7 MiB      0.0 MiB       16504               if temp_g_score < g_score[neighbor]:
    73    114.7 MiB      0.0 MiB        2340                   came_from[neighbor] = current
    74    114.7 MiB      0.0 MiB        2340                   g_score[neighbor] = temp_g_score
    75    114.7 MiB      0.0 MiB        2340                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    114.7 MiB      0.0 MiB        2340                   if neighbor not in open_set_hash:
    77    114.7 MiB      0.0 MiB        2340                       count += 1
    78    114.7 MiB      0.0 MiB        2340                       open_set.put((f_score[neighbor], count, neighbor))
    79    114.7 MiB      0.0 MiB        2340                       open_set_hash.add(neighbor)
    80                                                             
    81    114.7 MiB      0.0 MiB        2063           if draw is not None:
    82                                                     draw()
    83                                         
    84    114.7 MiB      0.0 MiB        2063           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    114.7 MiB    114.7 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    114.7 MiB      0.0 MiB         257       for row in grid:
    32    114.7 MiB      0.0 MiB       65792           for spot in row:
    33    114.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    114.7 MiB      0.0 MiB           1       count = 0
    36    114.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    114.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    114.7 MiB      0.0 MiB           1       came_from = {}
    39    114.7 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    114.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    114.7 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    114.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    114.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    114.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46    114.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    114.7 MiB      0.0 MiB        9271       while not open_set.empty():
    49    114.7 MiB      0.0 MiB        9271           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    114.7 MiB      0.0 MiB        9271           current = open_set.get()[2]
    55    114.7 MiB      0.0 MiB        9271           open_set_hash.remove(current)
    56                                         
    57    114.7 MiB      0.0 MiB        9271           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    114.7 MiB      0.0 MiB        9271           if current == end:
    62    114.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    114.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    114.7 MiB      0.0 MiB       83430           for neighbor in current.neighbors:
    67    114.7 MiB      0.0 MiB       74160               if current.row != neighbor.row and current.col != neighbor.col:
    68    114.7 MiB      0.0 MiB       37080                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    114.7 MiB      0.0 MiB       37080                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    114.7 MiB      0.0 MiB       74160               if temp_g_score < g_score[neighbor]:
    73    114.7 MiB      0.0 MiB        9815                   came_from[neighbor] = current
    74    114.7 MiB      0.0 MiB        9815                   g_score[neighbor] = temp_g_score
    75    114.7 MiB      0.0 MiB        9815                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    114.7 MiB      0.0 MiB        9815                   if neighbor not in open_set_hash:
    77    114.7 MiB      0.0 MiB        9815                       count += 1
    78    114.7 MiB      0.0 MiB        9815                       open_set.put((f_score[neighbor], count, neighbor))
    79    114.7 MiB      0.0 MiB        9815                       open_set_hash.add(neighbor)
    80                                                             
    81    114.7 MiB      0.0 MiB        9270           if draw is not None:
    82                                                     draw()
    83                                         
    84    114.7 MiB      0.0 MiB        9270           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    115.1 MiB    115.1 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    115.1 MiB      0.0 MiB         257       for row in grid:
    32    115.1 MiB      0.0 MiB       65792           for spot in row:
    33    115.1 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    115.1 MiB      0.0 MiB           1       count = 0
    36    115.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    115.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    115.1 MiB      0.0 MiB           1       came_from = {}
    39    115.8 MiB      0.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    115.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    116.0 MiB -537210.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    105.2 MiB    -10.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    105.2 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    105.2 MiB      0.0 MiB           1       cost_diagonal = 14
    46    105.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    105.2 MiB -13436.3 MiB        4524       while not open_set.empty():
    49    105.2 MiB -13436.4 MiB        4524           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    105.2 MiB -13436.5 MiB        4524           current = open_set.get()[2]
    55    105.2 MiB -13436.6 MiB        4524           open_set_hash.remove(current)
    56                                         
    57    105.2 MiB -13436.6 MiB        4524           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    105.2 MiB -13436.8 MiB        4524           if current == end:
    62    100.6 MiB     -4.5 MiB           1               if draw:
    63                                                         end.make_end()
    64    100.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    105.2 MiB -120911.3 MiB       40707           for neighbor in current.neighbors:
    67    105.2 MiB -107475.8 MiB       36184               if current.row != neighbor.row and current.col != neighbor.col:
    68    105.2 MiB -53740.6 MiB       18092                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    105.2 MiB -53735.9 MiB       18092                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    105.2 MiB -107477.4 MiB       36184               if temp_g_score < g_score[neighbor]:
    73    105.2 MiB -14518.8 MiB        4950                   came_from[neighbor] = current
    74    105.2 MiB -14518.9 MiB        4950                   g_score[neighbor] = temp_g_score
    75    105.2 MiB -14519.1 MiB        4950                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    105.2 MiB -14519.2 MiB        4950                   if neighbor not in open_set_hash:
    77    105.2 MiB -14519.3 MiB        4950                       count += 1
    78    105.2 MiB -14519.3 MiB        4950                       open_set.put((f_score[neighbor], count, neighbor))
    79    105.2 MiB -14519.4 MiB        4950                       open_set_hash.add(neighbor)
    80                                                             
    81    105.2 MiB -13436.2 MiB        4523           if draw is not None:
    82                                                     draw()
    83                                         
    84    105.2 MiB -13436.3 MiB        4523           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    100.7 MiB    100.7 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    100.7 MiB      0.0 MiB         257       for row in grid:
    32    100.7 MiB      0.0 MiB       65792           for spot in row:
    33    100.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    100.7 MiB      0.0 MiB           1       count = 0
    36    100.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    100.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    100.7 MiB      0.0 MiB           1       came_from = {}
    39    101.8 MiB      1.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    101.8 MiB      0.0 MiB           1       g_score[start] = 0
    41    103.0 MiB      1.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    103.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    103.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    103.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    103.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    103.0 MiB      0.0 MiB        3287       while not open_set.empty():
    49    103.0 MiB      0.0 MiB        3287           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    103.0 MiB      0.0 MiB        3287           current = open_set.get()[2]
    55    103.0 MiB      0.0 MiB        3287           open_set_hash.remove(current)
    56                                         
    57    103.0 MiB      0.0 MiB        3287           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    103.0 MiB      0.0 MiB        3287           if current == end:
    62    103.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    103.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    103.0 MiB      0.0 MiB       29574           for neighbor in current.neighbors:
    67    103.0 MiB      0.0 MiB       26288               if current.row != neighbor.row and current.col != neighbor.col:
    68    103.0 MiB      0.0 MiB       13144                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    103.0 MiB      0.0 MiB       13144                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    103.0 MiB      0.0 MiB       26288               if temp_g_score < g_score[neighbor]:
    73    103.0 MiB      0.0 MiB        3707                   came_from[neighbor] = current
    74    103.0 MiB      0.0 MiB        3707                   g_score[neighbor] = temp_g_score
    75    103.0 MiB      0.0 MiB        3707                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    103.0 MiB      0.0 MiB        3707                   if neighbor not in open_set_hash:
    77    103.0 MiB      0.0 MiB        3707                       count += 1
    78    103.0 MiB      0.0 MiB        3707                       open_set.put((f_score[neighbor], count, neighbor))
    79    103.0 MiB      0.0 MiB        3707                       open_set_hash.add(neighbor)
    80                                                             
    81    103.0 MiB      0.0 MiB        3286           if draw is not None:
    82                                                     draw()
    83                                         
    84    103.0 MiB      0.0 MiB        3286           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    103.0 MiB    103.0 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    103.0 MiB      0.0 MiB         257       for row in grid:
    32    103.0 MiB      0.0 MiB       65792           for spot in row:
    33    103.0 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    103.0 MiB      0.0 MiB           1       count = 0
    36    103.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    103.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    103.0 MiB      0.0 MiB           1       came_from = {}
    39    104.5 MiB      1.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    104.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    107.5 MiB      3.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    107.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    107.5 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    107.5 MiB      0.0 MiB           1       cost_diagonal = 14
    46    107.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    107.5 MiB      0.0 MiB         110       while not open_set.empty():
    49    107.5 MiB      0.0 MiB         110           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    107.5 MiB      0.0 MiB         110           current = open_set.get()[2]
    55    107.5 MiB      0.0 MiB         110           open_set_hash.remove(current)
    56                                         
    57    107.5 MiB      0.0 MiB         110           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    107.5 MiB      0.0 MiB         110           if current == end:
    62    107.5 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    107.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    107.5 MiB      0.0 MiB         981           for neighbor in current.neighbors:
    67    107.5 MiB      0.0 MiB         872               if current.row != neighbor.row and current.col != neighbor.col:
    68    107.5 MiB      0.0 MiB         436                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    107.5 MiB      0.0 MiB         436                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    107.5 MiB      0.0 MiB         872               if temp_g_score < g_score[neighbor]:
    73    107.5 MiB      0.0 MiB         206                   came_from[neighbor] = current
    74    107.5 MiB      0.0 MiB         206                   g_score[neighbor] = temp_g_score
    75    107.5 MiB      0.0 MiB         206                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    107.5 MiB      0.0 MiB         206                   if neighbor not in open_set_hash:
    77    107.5 MiB      0.0 MiB         206                       count += 1
    78    107.5 MiB      0.0 MiB         206                       open_set.put((f_score[neighbor], count, neighbor))
    79    107.5 MiB      0.0 MiB         206                       open_set_hash.add(neighbor)
    80                                                             
    81    107.5 MiB      0.0 MiB         109           if draw is not None:
    82                                                     draw()
    83                                         
    84    107.5 MiB      0.0 MiB         109           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    107.5 MiB    107.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    107.5 MiB      0.0 MiB         257       for row in grid:
    32    107.5 MiB      0.0 MiB       65792           for spot in row:
    33    107.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    107.5 MiB      0.0 MiB           1       count = 0
    36    107.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    107.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    107.5 MiB      0.0 MiB           1       came_from = {}
    39    107.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    107.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    110.0 MiB      2.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    110.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    110.0 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    110.0 MiB      0.0 MiB           1       cost_diagonal = 14
    46    110.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    110.0 MiB      0.0 MiB        3422       while not open_set.empty():
    49    110.0 MiB      0.0 MiB        3422           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    110.0 MiB      0.0 MiB        3422           current = open_set.get()[2]
    55    110.0 MiB      0.0 MiB        3422           open_set_hash.remove(current)
    56                                         
    57    110.0 MiB      0.0 MiB        3422           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    110.0 MiB      0.0 MiB        3422           if current == end:
    62    110.0 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    110.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    110.0 MiB      0.0 MiB       30789           for neighbor in current.neighbors:
    67    110.0 MiB      0.0 MiB       27368               if current.row != neighbor.row and current.col != neighbor.col:
    68    110.0 MiB      0.0 MiB       13684                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    110.0 MiB      0.0 MiB       13684                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    110.0 MiB      0.0 MiB       27368               if temp_g_score < g_score[neighbor]:
    73    110.0 MiB      0.0 MiB        3770                   came_from[neighbor] = current
    74    110.0 MiB      0.0 MiB        3770                   g_score[neighbor] = temp_g_score
    75    110.0 MiB      0.0 MiB        3770                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    110.0 MiB      0.0 MiB        3770                   if neighbor not in open_set_hash:
    77    110.0 MiB      0.0 MiB        3770                       count += 1
    78    110.0 MiB      0.0 MiB        3770                       open_set.put((f_score[neighbor], count, neighbor))
    79    110.0 MiB      0.0 MiB        3770                       open_set_hash.add(neighbor)
    80                                                             
    81    110.0 MiB      0.0 MiB        3421           if draw is not None:
    82                                                     draw()
    83                                         
    84    110.0 MiB      0.0 MiB        3421           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    110.5 MiB    110.5 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    110.5 MiB      0.0 MiB         257       for row in grid:
    32    110.5 MiB      0.0 MiB       65792           for spot in row:
    33    110.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    110.5 MiB      0.0 MiB           1       count = 0
    36    110.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    110.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    110.5 MiB      0.0 MiB           1       came_from = {}
    39    110.5 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    110.5 MiB      0.0 MiB           1       g_score[start] = 0
    41    111.8 MiB      1.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    111.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    111.8 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    111.8 MiB      0.0 MiB           1       cost_diagonal = 14
    46    111.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    111.8 MiB      0.0 MiB        4797       while not open_set.empty():
    49    111.8 MiB      0.0 MiB        4797           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    111.8 MiB      0.0 MiB        4797           current = open_set.get()[2]
    55    111.8 MiB      0.0 MiB        4797           open_set_hash.remove(current)
    56                                         
    57    111.8 MiB      0.0 MiB        4797           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    111.8 MiB      0.0 MiB        4797           if current == end:
    62    111.8 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    111.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    111.8 MiB      0.0 MiB       43164           for neighbor in current.neighbors:
    67    111.8 MiB      0.0 MiB       38368               if current.row != neighbor.row and current.col != neighbor.col:
    68    111.8 MiB      0.0 MiB       19184                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    111.8 MiB      0.0 MiB       19184                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    111.8 MiB      0.0 MiB       38368               if temp_g_score < g_score[neighbor]:
    73    111.8 MiB      0.0 MiB        5193                   came_from[neighbor] = current
    74    111.8 MiB      0.0 MiB        5193                   g_score[neighbor] = temp_g_score
    75    111.8 MiB      0.0 MiB        5193                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    111.8 MiB      0.0 MiB        5193                   if neighbor not in open_set_hash:
    77    111.8 MiB      0.0 MiB        5193                       count += 1
    78    111.8 MiB      0.0 MiB        5193                       open_set.put((f_score[neighbor], count, neighbor))
    79    111.8 MiB      0.0 MiB        5193                       open_set_hash.add(neighbor)
    80                                                             
    81    111.8 MiB      0.0 MiB        4796           if draw is not None:
    82                                                     draw()
    83                                         
    84    111.8 MiB      0.0 MiB        4796           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    111.8 MiB    111.8 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    111.8 MiB      0.0 MiB         257       for row in grid:
    32    111.8 MiB      0.0 MiB       65792           for spot in row:
    33    111.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    111.8 MiB      0.0 MiB           1       count = 0
    36    111.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    111.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    111.8 MiB      0.0 MiB           1       came_from = {}
    39    112.7 MiB      0.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    112.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    112.7 MiB      0.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    112.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    112.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    112.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46    112.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    112.7 MiB      0.0 MiB        2744       while not open_set.empty():
    49    112.7 MiB      0.0 MiB        2744           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    112.7 MiB      0.0 MiB        2744           current = open_set.get()[2]
    55    112.7 MiB      0.0 MiB        2744           open_set_hash.remove(current)
    56                                         
    57    112.7 MiB      0.0 MiB        2744           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    112.7 MiB      0.0 MiB        2744           if current == end:
    62    112.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    112.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    112.7 MiB      0.0 MiB       24687           for neighbor in current.neighbors:
    67    112.7 MiB      0.0 MiB       21944               if current.row != neighbor.row and current.col != neighbor.col:
    68    112.7 MiB      0.0 MiB       10972                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    112.7 MiB      0.0 MiB       10972                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    112.7 MiB      0.0 MiB       21944               if temp_g_score < g_score[neighbor]:
    73    112.7 MiB      0.0 MiB        3190                   came_from[neighbor] = current
    74    112.7 MiB      0.0 MiB        3190                   g_score[neighbor] = temp_g_score
    75    112.7 MiB      0.0 MiB        3190                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    112.7 MiB      0.0 MiB        3190                   if neighbor not in open_set_hash:
    77    112.7 MiB      0.0 MiB        3190                       count += 1
    78    112.7 MiB      0.0 MiB        3190                       open_set.put((f_score[neighbor], count, neighbor))
    79    112.7 MiB      0.0 MiB        3190                       open_set_hash.add(neighbor)
    80                                                             
    81    112.7 MiB      0.0 MiB        2743           if draw is not None:
    82                                                     draw()
    83                                         
    84    112.7 MiB      0.0 MiB        2743           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    112.7 MiB    112.7 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    112.7 MiB      0.0 MiB         257       for row in grid:
    32    112.7 MiB      0.0 MiB       65792           for spot in row:
    33    112.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    112.7 MiB      0.0 MiB           1       count = 0
    36    112.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    112.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    112.7 MiB      0.0 MiB           1       came_from = {}
    39    112.7 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    112.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    112.7 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    112.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    112.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    112.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46    112.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    112.7 MiB      0.0 MiB        1372       while not open_set.empty():
    49    112.7 MiB      0.0 MiB        1372           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    112.7 MiB      0.0 MiB        1372           current = open_set.get()[2]
    55    112.7 MiB      0.0 MiB        1372           open_set_hash.remove(current)
    56                                         
    57    112.7 MiB      0.0 MiB        1372           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    112.7 MiB      0.0 MiB        1372           if current == end:
    62    112.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    112.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    112.7 MiB      0.0 MiB       12192           for neighbor in current.neighbors:
    67    112.7 MiB      0.0 MiB       10821               if current.row != neighbor.row and current.col != neighbor.col:
    68    112.7 MiB      0.0 MiB        5386                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    112.7 MiB      0.0 MiB        5435                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    112.7 MiB      0.0 MiB       10821               if temp_g_score < g_score[neighbor]:
    73    112.7 MiB      0.0 MiB        1529                   came_from[neighbor] = current
    74    112.7 MiB      0.0 MiB        1529                   g_score[neighbor] = temp_g_score
    75    112.7 MiB      0.0 MiB        1529                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    112.7 MiB      0.0 MiB        1529                   if neighbor not in open_set_hash:
    77    112.7 MiB      0.0 MiB        1529                       count += 1
    78    112.7 MiB      0.0 MiB        1529                       open_set.put((f_score[neighbor], count, neighbor))
    79    112.7 MiB      0.0 MiB        1529                       open_set_hash.add(neighbor)
    80                                                             
    81    112.7 MiB      0.0 MiB        1371           if draw is not None:
    82                                                     draw()
    83                                         
    84    112.7 MiB      0.0 MiB        1371           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    112.7 MiB    112.7 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    112.7 MiB      0.0 MiB         257       for row in grid:
    32    112.7 MiB      0.0 MiB       65792           for spot in row:
    33    112.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    112.7 MiB      0.0 MiB           1       count = 0
    36    112.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    112.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    112.7 MiB      0.0 MiB           1       came_from = {}
    39    112.7 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    112.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    112.7 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    112.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    112.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    112.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46    112.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    112.7 MiB      0.0 MiB         636       while not open_set.empty():
    49    112.7 MiB      0.0 MiB         636           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    112.7 MiB      0.0 MiB         636           current = open_set.get()[2]
    55    112.7 MiB      0.0 MiB         636           open_set_hash.remove(current)
    56                                         
    57    112.7 MiB      0.0 MiB         636           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    112.7 MiB      0.0 MiB         636           if current == end:
    62    112.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    112.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    112.7 MiB      0.0 MiB        5715           for neighbor in current.neighbors:
    67    112.7 MiB      0.0 MiB        5080               if current.row != neighbor.row and current.col != neighbor.col:
    68    112.7 MiB      0.0 MiB        2540                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    112.7 MiB      0.0 MiB        2540                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    112.7 MiB      0.0 MiB        5080               if temp_g_score < g_score[neighbor]:
    73    112.7 MiB      0.0 MiB         870                   came_from[neighbor] = current
    74    112.7 MiB      0.0 MiB         870                   g_score[neighbor] = temp_g_score
    75    112.7 MiB      0.0 MiB         870                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    112.7 MiB      0.0 MiB         870                   if neighbor not in open_set_hash:
    77    112.7 MiB      0.0 MiB         870                       count += 1
    78    112.7 MiB      0.0 MiB         870                       open_set.put((f_score[neighbor], count, neighbor))
    79    112.7 MiB      0.0 MiB         870                       open_set_hash.add(neighbor)
    80                                                             
    81    112.7 MiB      0.0 MiB         635           if draw is not None:
    82                                                     draw()
    83                                         
    84    112.7 MiB      0.0 MiB         635           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    112.7 MiB    112.7 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    112.7 MiB      0.0 MiB         257       for row in grid:
    32    112.7 MiB      0.0 MiB       65792           for spot in row:
    33    112.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    112.7 MiB      0.0 MiB           1       count = 0
    36    112.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    112.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    112.7 MiB      0.0 MiB           1       came_from = {}
    39    112.7 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    112.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    112.7 MiB      0.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    112.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    112.7 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    112.7 MiB      0.0 MiB           1       cost_diagonal = 14
    46    112.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    112.7 MiB      0.0 MiB        3726       while not open_set.empty():
    49    112.7 MiB      0.0 MiB        3726           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    112.7 MiB      0.0 MiB        3726           current = open_set.get()[2]
    55    112.7 MiB      0.0 MiB        3726           open_set_hash.remove(current)
    56                                         
    57    112.7 MiB      0.0 MiB        3726           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    112.7 MiB      0.0 MiB        3726           if current == end:
    62    112.7 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    112.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    112.7 MiB      0.0 MiB       33525           for neighbor in current.neighbors:
    67    112.7 MiB      0.0 MiB       29800               if current.row != neighbor.row and current.col != neighbor.col:
    68    112.7 MiB      0.0 MiB       14900                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    112.7 MiB      0.0 MiB       14900                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    112.7 MiB      0.0 MiB       29800               if temp_g_score < g_score[neighbor]:
    73    112.7 MiB      0.0 MiB        4210                   came_from[neighbor] = current
    74    112.7 MiB      0.0 MiB        4210                   g_score[neighbor] = temp_g_score
    75    112.7 MiB      0.0 MiB        4210                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    112.7 MiB      0.0 MiB        4210                   if neighbor not in open_set_hash:
    77    112.7 MiB      0.0 MiB        4210                       count += 1
    78    112.7 MiB      0.0 MiB        4210                       open_set.put((f_score[neighbor], count, neighbor))
    79    112.7 MiB      0.0 MiB        4210                       open_set_hash.add(neighbor)
    80                                                             
    81    112.7 MiB      0.0 MiB        3725           if draw is not None:
    82                                                     draw()
    83                                         
    84    112.7 MiB      0.0 MiB        3725           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    112.7 MiB    112.7 MiB           1   @profile(stream=open('logs/A*/grid_size/256.txt', 'w+'))
    29                                         def algorithm(grid, start, end, draw=None, debug=False):
    30                                             
    31    112.7 MiB      0.0 MiB         257       for row in grid:
    32    112.7 MiB      0.0 MiB       65792           for spot in row:
    33    112.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    34                                             
    35    112.7 MiB      0.0 MiB           1       count = 0
    36    112.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    37    112.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    38    112.7 MiB      0.0 MiB           1       came_from = {}
    39    112.7 MiB      0.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    40    112.7 MiB      0.0 MiB           1       g_score[start] = 0
    41    113.3 MiB      0.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    42    113.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    43    113.3 MiB      0.0 MiB           1       open_set_hash = {start}
    44                                         
    45    113.3 MiB      0.0 MiB           1       cost_diagonal = 14
    46    113.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    47                                         
    48    113.3 MiB      0.0 MiB         648       while not open_set.empty():
    49    113.3 MiB      0.0 MiB         648           if draw: #if there is draw that means algorithm is called when the game is running 
    50                                                     for event in pygame.event.get():
    51                                                         if event.type == pygame.QUIT:
    52                                                             pygame.quit()
    53                                         
    54    113.3 MiB      0.0 MiB         648           current = open_set.get()[2]
    55    113.3 MiB      0.0 MiB         648           open_set_hash.remove(current)
    56                                         
    57    113.3 MiB      0.0 MiB         648           if debug:
    58                                                     if not current.is_blank():
    59                                                         print(current.color)
    60                                                   
    61    113.3 MiB      0.0 MiB         648           if current == end:
    62    113.3 MiB      0.0 MiB           1               if draw:
    63                                                         end.make_end()
    64    113.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    65                                         
    66    113.3 MiB      0.0 MiB        5823           for neighbor in current.neighbors:
    67    113.3 MiB      0.0 MiB        5176               if current.row != neighbor.row and current.col != neighbor.col:
    68    113.3 MiB      0.0 MiB        2588                   temp_g_score = g_score[current] + cost_diagonal
    69                                                     else:
    70    113.3 MiB      0.0 MiB        2588                   temp_g_score = g_score[current] + cost_vertical_horizontal
    71                                         
    72    113.3 MiB      0.0 MiB        5176               if temp_g_score < g_score[neighbor]:
    73    113.3 MiB      0.0 MiB         790                   came_from[neighbor] = current
    74    113.3 MiB      0.0 MiB         790                   g_score[neighbor] = temp_g_score
    75    113.3 MiB      0.0 MiB         790                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    76    113.3 MiB      0.0 MiB         790                   if neighbor not in open_set_hash:
    77    113.3 MiB      0.0 MiB         790                       count += 1
    78    113.3 MiB      0.0 MiB         790                       open_set.put((f_score[neighbor], count, neighbor))
    79    113.3 MiB      0.0 MiB         790                       open_set_hash.add(neighbor)
    80                                                             
    81    113.3 MiB      0.0 MiB         647           if draw is not None:
    82                                                     draw()
    83                                         
    84    113.3 MiB      0.0 MiB         647           if current != start and draw:
    85                                                     current.make_closed()
    86                                         
    87                                             print("No path found")
    88                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    15                                         def h(p1, p2):
    16                                             x1, y1 = p1
    17                                             x2, y2 = p2
    18                                         
    19                                             D = 10
    20                                             D2 = 14
    21                                             
    22                                             dx = abs(x1 - x2)
    23                                             dy = abs(y1 - y2)
    24                                         
    25                                             return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)


