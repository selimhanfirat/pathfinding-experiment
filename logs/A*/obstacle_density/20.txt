Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.6 MiB     67.6 MiB           1   @profile(stream=open('logs/A*/obstacle_density/20.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     69.2 MiB  -1714.8 MiB         257       for row in grid:
    30     69.2 MiB -438211.5 MiB       65792           for spot in row:
    31     69.2 MiB -436493.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     57.0 MiB    -12.2 MiB           1       count = 0
    34     57.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     57.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     57.0 MiB      0.0 MiB           1       came_from = {}
    37     61.6 MiB -34698.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     60.5 MiB     -1.0 MiB           1       g_score[start] = 0
    39     65.8 MiB -37229.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.9 MiB     -0.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     69.4 MiB  -1642.5 MiB        3689       while not open_set.empty():
    47     69.4 MiB  -1642.5 MiB        3689           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     69.4 MiB  -1642.5 MiB        3689           current = open_set.get()[2]
    53     69.4 MiB  -1642.5 MiB        3689           open_set_hash.remove(current)
    54                                         
    55     69.4 MiB  -1642.5 MiB        3689           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     69.4 MiB  -1642.5 MiB        3689           if current == end:
    60     66.9 MiB     -2.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     66.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     69.4 MiB -12028.8 MiB       27141           for neighbor in current.neighbors:
    65     69.4 MiB -10389.2 MiB       23453               if current.row != neighbor.row and current.col != neighbor.col:
    66     69.4 MiB  -5094.2 MiB       11485                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     69.4 MiB  -5295.3 MiB       11968                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     69.4 MiB -10386.3 MiB       23453               if temp_g_score < g_score[neighbor]:
    71     69.4 MiB  -2515.7 MiB        5294                   came_from[neighbor] = current
    72     69.4 MiB  -2516.0 MiB        5294                   g_score[neighbor] = temp_g_score
    73     69.4 MiB  -2515.8 MiB        5294                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     69.4 MiB  -2516.0 MiB        5294                   if neighbor not in open_set_hash:
    75     69.4 MiB  -1988.2 MiB        4263                       count += 1
    76     69.4 MiB  -1988.2 MiB        4263                       open_set.put((f_score[neighbor], count, neighbor))
    77     69.4 MiB  -1988.1 MiB        4263                       open_set_hash.add(neighbor)
    78                                                             
    79     69.4 MiB  -1643.2 MiB        3688           if draw is not None:
    80                                                     draw()
    81                                         
    82     69.4 MiB  -1642.5 MiB        3688           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.0 MiB     92.0 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.0 MiB   -983.2 MiB         257       for row in grid:
    30     92.0 MiB -251583.4 MiB       65792           for spot in row:
    31     92.0 MiB -250598.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     87.0 MiB     -5.1 MiB           1       count = 0
    34     87.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     87.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     87.0 MiB      0.0 MiB           1       came_from = {}
    37     90.6 MiB  -7887.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     90.1 MiB     -0.5 MiB           1       g_score[start] = 0
    39     96.3 MiB      6.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     96.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     96.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     96.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     96.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     96.3 MiB  -9326.8 MiB        2403       while not open_set.empty():
    47     96.3 MiB  -9326.8 MiB        2403           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     96.3 MiB  -9326.8 MiB        2403           current = open_set.get()[2]
    53     96.3 MiB  -9326.8 MiB        2403           open_set_hash.remove(current)
    54                                         
    55     96.3 MiB  -9326.9 MiB        2403           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     96.3 MiB  -9327.0 MiB        2403           if current == end:
    60     92.6 MiB     -3.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     92.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     96.3 MiB -69660.3 MiB       17791           for neighbor in current.neighbors:
    65     96.3 MiB -60334.7 MiB       15389               if current.row != neighbor.row and current.col != neighbor.col:
    66     96.3 MiB -29606.0 MiB        7531                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     96.3 MiB -30728.9 MiB        7858                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     96.3 MiB -60336.0 MiB       15389               if temp_g_score < g_score[neighbor]:
    71     96.3 MiB -14472.8 MiB        3723                   came_from[neighbor] = current
    72     96.3 MiB -14473.0 MiB        3723                   g_score[neighbor] = temp_g_score
    73     96.3 MiB -14472.9 MiB        3723                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     96.3 MiB -14472.9 MiB        3723                   if neighbor not in open_set_hash:
    75     96.3 MiB -11608.4 MiB        3016                       count += 1
    76     96.3 MiB -11606.9 MiB        3016                       open_set.put((f_score[neighbor], count, neighbor))
    77     96.3 MiB -11606.9 MiB        3016                       open_set_hash.add(neighbor)
    78                                                             
    79     96.3 MiB  -9326.8 MiB        2402           if draw is not None:
    80                                                     draw()
    81                                         
    82     96.3 MiB  -9326.8 MiB        2402           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     95.8 MiB     95.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.8 MiB      0.0 MiB         257       for row in grid:
    30     95.8 MiB      0.0 MiB       65792           for spot in row:
    31     95.8 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.8 MiB      0.0 MiB           1       count = 0
    34     95.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.8 MiB      0.0 MiB           1       came_from = {}
    37    101.3 MiB      5.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.9 MiB -248099.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     94.7 MiB     -7.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     94.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     94.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     94.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     95.2 MiB -45531.0 MiB        3659       while not open_set.empty():
    47     95.2 MiB -45531.1 MiB        3659           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     95.2 MiB -45531.2 MiB        3659           current = open_set.get()[2]
    53     95.2 MiB -45531.6 MiB        3659           open_set_hash.remove(current)
    54                                         
    55     95.2 MiB -45531.7 MiB        3659           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     95.2 MiB -45532.0 MiB        3659           if current == end:
    60     69.9 MiB    -25.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     69.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     95.2 MiB -333016.2 MiB       26951           for neighbor in current.neighbors:
    65     95.2 MiB -287489.5 MiB       23293               if current.row != neighbor.row and current.col != neighbor.col:
    66     95.2 MiB -140783.0 MiB       11394                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     95.2 MiB -146720.9 MiB       11899                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     95.2 MiB -287504.7 MiB       23293               if temp_g_score < g_score[neighbor]:
    71     95.2 MiB -58740.3 MiB        4837                   came_from[neighbor] = current
    72     95.2 MiB -58740.6 MiB        4837                   g_score[neighbor] = temp_g_score
    73     95.2 MiB -58740.9 MiB        4837                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     95.2 MiB -58741.8 MiB        4837                   if neighbor not in open_set_hash:
    75     95.2 MiB -45274.4 MiB        4185                       count += 1
    76     95.2 MiB -45271.0 MiB        4185                       open_set.put((f_score[neighbor], count, neighbor))
    77     95.2 MiB -45272.6 MiB        4185                       open_set_hash.add(neighbor)
    78                                                             
    79     95.2 MiB -45530.9 MiB        3658           if draw is not None:
    80                                                     draw()
    81                                         
    82     95.2 MiB -45530.9 MiB        3658           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.7 MiB    102.7 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.7 MiB    -92.4 MiB         257       for row in grid:
    30    102.7 MiB -23609.9 MiB       65792           for spot in row:
    31    102.7 MiB -23519.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.0 MiB     -3.7 MiB           1       count = 0
    34     99.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.0 MiB      0.0 MiB           1       came_from = {}
    37    100.0 MiB -228920.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.3 MiB     -5.7 MiB           1       g_score[start] = 0
    39     98.0 MiB -11045.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     97.8 MiB     -0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     97.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     97.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     97.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.5 MiB   -360.2 MiB        1040       while not open_set.empty():
    47     98.5 MiB   -360.2 MiB        1040           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.5 MiB   -360.2 MiB        1040           current = open_set.get()[2]
    53     98.5 MiB   -360.2 MiB        1040           open_set_hash.remove(current)
    54                                         
    55     98.5 MiB   -360.2 MiB        1040           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.5 MiB   -360.2 MiB        1040           if current == end:
    60     98.1 MiB     -0.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.5 MiB  -2643.2 MiB        7695           for neighbor in current.neighbors:
    65     98.5 MiB  -2282.7 MiB        6656               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.5 MiB  -1118.8 MiB        3265                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.5 MiB  -1164.5 MiB        3391                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.5 MiB  -2283.7 MiB        6656               if temp_g_score < g_score[neighbor]:
    71     98.5 MiB   -509.5 MiB        1503                   came_from[neighbor] = current
    72     98.5 MiB   -509.5 MiB        1503                   g_score[neighbor] = temp_g_score
    73     98.5 MiB   -509.5 MiB        1503                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.5 MiB   -509.5 MiB        1503                   if neighbor not in open_set_hash:
    75     98.5 MiB   -409.9 MiB        1268                       count += 1
    76     98.5 MiB   -409.9 MiB        1268                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.5 MiB   -409.9 MiB        1268                       open_set_hash.add(neighbor)
    78                                                             
    79     98.5 MiB   -360.2 MiB        1039           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.5 MiB   -360.2 MiB        1039           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.3 MiB    104.3 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.3 MiB   -160.8 MiB         257       for row in grid:
    30    104.3 MiB -41040.5 MiB       65792           for spot in row:
    31    104.3 MiB -40881.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.8 MiB     -1.5 MiB           1       count = 0
    34    102.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.8 MiB      0.0 MiB           1       came_from = {}
    37    105.8 MiB -75880.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.8 MiB     -4.0 MiB           1       g_score[start] = 0
    39    104.4 MiB      2.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.4 MiB -72182.1 MiB        4566       while not open_set.empty():
    47    104.4 MiB -72182.2 MiB        4566           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.4 MiB -72182.2 MiB        4566           current = open_set.get()[2]
    53    104.4 MiB -72182.3 MiB        4566           open_set_hash.remove(current)
    54                                         
    55    104.4 MiB -72182.3 MiB        4566           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.4 MiB -72182.4 MiB        4566           if current == end:
    60     72.4 MiB    -32.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     72.5 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.4 MiB -525039.2 MiB       33279           for neighbor in current.neighbors:
    65    104.4 MiB -452860.5 MiB       28714               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.4 MiB -221642.8 MiB       14051                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.4 MiB -231218.1 MiB       14663                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.4 MiB -452874.3 MiB       28714               if temp_g_score < g_score[neighbor]:
    71    104.4 MiB -102849.9 MiB        6291                   came_from[neighbor] = current
    72    104.4 MiB -102850.0 MiB        6291                   g_score[neighbor] = temp_g_score
    73    104.4 MiB -102850.1 MiB        6291                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.4 MiB -102850.1 MiB        6291                   if neighbor not in open_set_hash:
    75    104.4 MiB -73296.6 MiB        4947                       count += 1
    76    104.4 MiB -73311.0 MiB        4947                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.4 MiB -73311.2 MiB        4947                       open_set_hash.add(neighbor)
    78                                                             
    79    104.4 MiB -72182.1 MiB        4565           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.4 MiB -72182.1 MiB        4565           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.5 MiB    102.5 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.5 MiB      0.0 MiB         257       for row in grid:
    30    102.5 MiB      0.0 MiB       65792           for spot in row:
    31    102.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.5 MiB      0.0 MiB           1       count = 0
    34    102.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.5 MiB      0.0 MiB           1       came_from = {}
    37    105.1 MiB -16660.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.2 MiB     -0.9 MiB           1       g_score[start] = 0
    39    107.7 MiB  -5380.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.7 MiB  -6963.2 MiB        1822       while not open_set.empty():
    47    107.7 MiB  -6963.2 MiB        1822           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.7 MiB  -6963.2 MiB        1822           current = open_set.get()[2]
    53    107.7 MiB  -6963.2 MiB        1822           open_set_hash.remove(current)
    54                                         
    55    107.7 MiB  -6963.2 MiB        1822           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.7 MiB  -6963.2 MiB        1822           if current == end:
    60     95.2 MiB    -12.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     95.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.7 MiB -51263.9 MiB       13377           for neighbor in current.neighbors:
    65    107.7 MiB -44302.7 MiB       11556               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.7 MiB -21841.9 MiB        5672                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.7 MiB -22462.1 MiB        5884                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.7 MiB -44310.8 MiB       11556               if temp_g_score < g_score[neighbor]:
    71    107.7 MiB -11027.2 MiB        2844                   came_from[neighbor] = current
    72    107.7 MiB -11027.3 MiB        2844                   g_score[neighbor] = temp_g_score
    73    107.7 MiB -11027.5 MiB        2844                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.7 MiB -11029.6 MiB        2844                   if neighbor not in open_set_hash:
    75    107.7 MiB  -8352.3 MiB        2186                       count += 1
    76    107.7 MiB  -8352.3 MiB        2186                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.7 MiB  -8352.3 MiB        2186                       open_set_hash.add(neighbor)
    78                                                             
    79    107.7 MiB  -6963.2 MiB        1821           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.7 MiB  -6963.2 MiB        1821           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.0 MiB    107.0 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.0 MiB  -1113.2 MiB         257       for row in grid:
    30    107.0 MiB -284733.7 MiB       65792           for spot in row:
    31    107.0 MiB -283627.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.4 MiB     -8.6 MiB           1       count = 0
    34     98.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.4 MiB      0.0 MiB           1       came_from = {}
    37    103.7 MiB   -346.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.9 MiB -117555.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.8 MiB    -28.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.5 MiB -66526.0 MiB        3961       while not open_set.empty():
    47     76.5 MiB -66527.2 MiB        3961           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.5 MiB -66527.4 MiB        3961           current = open_set.get()[2]
    53     76.5 MiB -66528.0 MiB        3961           open_set_hash.remove(current)
    54                                         
    55     76.5 MiB -66528.3 MiB        3961           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.5 MiB -66528.5 MiB        3961           if current == end:
    60     39.8 MiB    -36.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     39.9 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.5 MiB -478454.7 MiB       28732           for neighbor in current.neighbors:
    65     76.5 MiB -411939.5 MiB       24772               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.5 MiB -200552.4 MiB       12076                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.5 MiB -211389.8 MiB       12696                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.5 MiB -411944.5 MiB       24772               if temp_g_score < g_score[neighbor]:
    71     76.5 MiB -92423.5 MiB        5725                   came_from[neighbor] = current
    72     76.5 MiB -92425.2 MiB        5725                   g_score[neighbor] = temp_g_score
    73     76.5 MiB -92426.6 MiB        5725                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.5 MiB -92428.0 MiB        5725                   if neighbor not in open_set_hash:
    75     76.5 MiB -72944.2 MiB        4499                       count += 1
    76     76.5 MiB -72946.8 MiB        4499                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.5 MiB -72948.1 MiB        4499                       open_set_hash.add(neighbor)
    78                                                             
    79     76.5 MiB -66524.7 MiB        3960           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.5 MiB -66526.0 MiB        3960           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.9 MiB     96.9 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.9 MiB     -5.8 MiB         257       for row in grid:
    30     96.9 MiB  -1488.6 MiB       65792           for spot in row:
    31     96.9 MiB  -1482.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.8 MiB     -0.1 MiB           1       count = 0
    34     96.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.8 MiB      0.0 MiB           1       came_from = {}
    37    101.7 MiB  -1376.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    104.6 MiB -38892.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.5 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.5 MiB     -0.3 MiB         415       while not open_set.empty():
    47    104.5 MiB     -0.3 MiB         415           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.5 MiB     -0.3 MiB         415           current = open_set.get()[2]
    53    104.5 MiB     -0.3 MiB         415           open_set_hash.remove(current)
    54                                         
    55    104.5 MiB     -0.3 MiB         415           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.5 MiB     -0.3 MiB         415           if current == end:
    60    104.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    104.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.5 MiB     -2.6 MiB        3197           for neighbor in current.neighbors:
    65    104.5 MiB     -2.2 MiB        2783               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.5 MiB     -1.1 MiB        1368                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.5 MiB     -1.1 MiB        1415                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.5 MiB     -2.2 MiB        2783               if temp_g_score < g_score[neighbor]:
    71    104.5 MiB     -0.4 MiB         627                   came_from[neighbor] = current
    72    104.5 MiB     -0.4 MiB         627                   g_score[neighbor] = temp_g_score
    73    104.5 MiB     -0.4 MiB         627                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.5 MiB     -0.4 MiB         627                   if neighbor not in open_set_hash:
    75    104.5 MiB     -0.4 MiB         621                       count += 1
    76    104.5 MiB     -0.4 MiB         621                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.5 MiB     -0.4 MiB         621                       open_set_hash.add(neighbor)
    78                                                             
    79    104.5 MiB     -0.3 MiB         414           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.5 MiB     -0.3 MiB         414           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.0 MiB    107.0 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.0 MiB     -1.0 MiB         257       for row in grid:
    30    107.0 MiB   -262.3 MiB       65792           for spot in row:
    31    107.0 MiB   -261.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.0 MiB     -0.0 MiB           1       count = 0
    34    107.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.0 MiB      0.0 MiB           1       came_from = {}
    37    110.1 MiB  -3267.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.2 MiB -14167.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.8 MiB     -0.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.8 MiB  -4525.1 MiB        1521       while not open_set.empty():
    47    111.8 MiB  -4525.1 MiB        1521           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.8 MiB  -4529.0 MiB        1521           current = open_set.get()[2]
    53    111.8 MiB  -4529.0 MiB        1521           open_set_hash.remove(current)
    54                                         
    55    111.8 MiB  -4529.0 MiB        1521           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.8 MiB  -4529.0 MiB        1521           if current == end:
    60    107.9 MiB     -3.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.8 MiB -33499.1 MiB       11303           for neighbor in current.neighbors:
    65    111.8 MiB -28974.0 MiB        9783               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.8 MiB -14153.0 MiB        4793                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.8 MiB -14821.0 MiB        4990                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.8 MiB -28974.0 MiB        9783               if temp_g_score < g_score[neighbor]:
    71    111.8 MiB  -5734.0 MiB        1978                   came_from[neighbor] = current
    72    111.8 MiB  -5734.0 MiB        1978                   g_score[neighbor] = temp_g_score
    73    111.8 MiB  -5734.0 MiB        1978                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.8 MiB  -5734.0 MiB        1978                   if neighbor not in open_set_hash:
    75    111.8 MiB  -5277.4 MiB        1857                       count += 1
    76    111.8 MiB  -5277.4 MiB        1857                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.8 MiB  -5277.4 MiB        1857                       open_set_hash.add(neighbor)
    78                                                             
    79    111.8 MiB  -4525.1 MiB        1520           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.8 MiB  -4525.1 MiB        1520           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.9 MiB    106.9 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.9 MiB   -700.7 MiB         257       for row in grid:
    30    106.9 MiB -179407.2 MiB       65792           for spot in row:
    31    106.9 MiB -178709.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.7 MiB     -5.2 MiB           1       count = 0
    34    101.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.7 MiB      0.0 MiB           1       came_from = {}
    37    105.1 MiB      3.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.1 MiB      4.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.1 MiB  -2827.3 MiB        3222       while not open_set.empty():
    47    109.1 MiB  -2827.3 MiB        3222           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.1 MiB  -2827.3 MiB        3222           current = open_set.get()[2]
    53    109.1 MiB  -2827.3 MiB        3222           open_set_hash.remove(current)
    54                                         
    55    109.1 MiB  -2827.3 MiB        3222           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.1 MiB  -2827.3 MiB        3222           if current == end:
    60    108.1 MiB     -1.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.1 MiB -20714.6 MiB       23657           for neighbor in current.neighbors:
    65    109.1 MiB -17887.6 MiB       20436               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.1 MiB  -8746.2 MiB        9995                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.1 MiB  -9141.9 MiB       10441                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.1 MiB -17888.1 MiB       20436               if temp_g_score < g_score[neighbor]:
    71    109.1 MiB  -3853.1 MiB        4415                   came_from[neighbor] = current
    72    109.1 MiB  -3853.1 MiB        4415                   g_score[neighbor] = temp_g_score
    73    109.1 MiB  -3853.1 MiB        4415                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.1 MiB  -3853.1 MiB        4415                   if neighbor not in open_set_hash:
    75    109.1 MiB  -3496.8 MiB        4044                       count += 1
    76    109.1 MiB  -3496.8 MiB        4044                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.1 MiB  -3496.8 MiB        4044                       open_set_hash.add(neighbor)
    78                                                             
    79    109.1 MiB  -2827.3 MiB        3221           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.1 MiB  -2827.3 MiB        3221           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.6 MiB    108.6 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.6 MiB   -839.1 MiB         257       for row in grid:
    30    108.6 MiB -214783.9 MiB       65792           for spot in row:
    31    108.6 MiB -213954.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.0 MiB    -11.5 MiB           1       count = 0
    34     97.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.0 MiB      0.0 MiB           1       came_from = {}
    37    100.1 MiB      3.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.5 MiB      3.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.5 MiB  -2125.6 MiB        3199       while not open_set.empty():
    47    103.5 MiB  -2125.6 MiB        3199           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.5 MiB  -2125.6 MiB        3199           current = open_set.get()[2]
    53    103.5 MiB  -2125.6 MiB        3199           open_set_hash.remove(current)
    54                                         
    55    103.5 MiB  -2125.6 MiB        3199           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.5 MiB  -2125.6 MiB        3199           if current == end:
    60     97.5 MiB     -6.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     97.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.5 MiB -15163.0 MiB       23679           for neighbor in current.neighbors:
    65    103.5 MiB -13039.8 MiB       20481               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.5 MiB  -6359.3 MiB       10062                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.5 MiB  -6681.0 MiB       10419                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.5 MiB -13041.0 MiB       20481               if temp_g_score < g_score[neighbor]:
    71    103.5 MiB  -2704.8 MiB        4207                   came_from[neighbor] = current
    72    103.5 MiB  -2705.6 MiB        4207                   g_score[neighbor] = temp_g_score
    73    103.5 MiB  -2705.7 MiB        4207                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.5 MiB  -2705.7 MiB        4207                   if neighbor not in open_set_hash:
    75    103.5 MiB  -2244.6 MiB        3964                       count += 1
    76    103.5 MiB  -2244.7 MiB        3964                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.5 MiB  -2244.9 MiB        3964                       open_set_hash.add(neighbor)
    78                                                             
    79    103.5 MiB  -2125.2 MiB        3198           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.5 MiB  -2125.6 MiB        3198           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.4 MiB    101.4 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.4 MiB   -270.4 MiB         257       for row in grid:
    30    101.4 MiB -69048.0 MiB       65792           for spot in row:
    31    101.4 MiB -68779.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.4 MiB     -2.1 MiB           1       count = 0
    34     99.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.4 MiB      0.0 MiB           1       came_from = {}
    37    104.3 MiB   -201.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.9 MiB  -3812.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    108.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    108.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    108.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    108.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    108.9 MiB  -2190.5 MiB        2992       while not open_set.empty():
    47    108.9 MiB  -2190.5 MiB        2992           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    108.9 MiB  -2190.5 MiB        2992           current = open_set.get()[2]
    53    108.9 MiB  -2190.5 MiB        2992           open_set_hash.remove(current)
    54                                         
    55    108.9 MiB  -2190.5 MiB        2992           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    108.9 MiB  -2191.2 MiB        2992           if current == end:
    60    108.2 MiB     -0.7 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    108.9 MiB -16272.0 MiB       22371           for neighbor in current.neighbors:
    65    108.9 MiB -14081.6 MiB       19380               if current.row != neighbor.row and current.col != neighbor.col:
    66    108.9 MiB  -6916.9 MiB        9524                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    108.9 MiB  -7164.7 MiB        9856                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    108.9 MiB -14081.7 MiB       19380               if temp_g_score < g_score[neighbor]:
    71    108.9 MiB  -2832.0 MiB        3911                   came_from[neighbor] = current
    72    108.9 MiB  -2832.1 MiB        3911                   g_score[neighbor] = temp_g_score
    73    108.9 MiB  -2832.1 MiB        3911                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    108.9 MiB  -2832.1 MiB        3911                   if neighbor not in open_set_hash:
    75    108.9 MiB  -2773.8 MiB        3839                       count += 1
    76    108.9 MiB  -2773.6 MiB        3839                       open_set.put((f_score[neighbor], count, neighbor))
    77    108.9 MiB  -2773.5 MiB        3839                       open_set_hash.add(neighbor)
    78                                                             
    79    108.9 MiB  -2190.5 MiB        2991           if draw is not None:
    80                                                     draw()
    81                                         
    82    108.9 MiB  -2190.5 MiB        2991           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.6 MiB    109.6 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.6 MiB  -1016.7 MiB         257       for row in grid:
    30    109.6 MiB -260274.8 MiB       65792           for spot in row:
    31    109.6 MiB -259263.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.1 MiB     -8.5 MiB           1       count = 0
    34    101.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.1 MiB      0.0 MiB           1       came_from = {}
    37    104.5 MiB      3.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    107.4 MiB      2.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.4 MiB      0.0 MiB         979       while not open_set.empty():
    47    107.4 MiB      0.0 MiB         979           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.4 MiB      0.0 MiB         979           current = open_set.get()[2]
    53    107.4 MiB      0.0 MiB         979           open_set_hash.remove(current)
    54                                         
    55    107.4 MiB      0.0 MiB         979           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.4 MiB      0.0 MiB         979           if current == end:
    60    107.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.4 MiB      0.0 MiB        7105           for neighbor in current.neighbors:
    65    107.4 MiB      0.0 MiB        6127               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.4 MiB      0.0 MiB        2991                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.4 MiB      0.0 MiB        3136                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.4 MiB      0.0 MiB        6127               if temp_g_score < g_score[neighbor]:
    71    107.4 MiB      0.0 MiB        1531                   came_from[neighbor] = current
    72    107.4 MiB      0.0 MiB        1531                   g_score[neighbor] = temp_g_score
    73    107.4 MiB      0.0 MiB        1531                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.4 MiB      0.0 MiB        1531                   if neighbor not in open_set_hash:
    75    107.4 MiB      0.0 MiB        1244                       count += 1
    76    107.4 MiB      0.0 MiB        1244                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.4 MiB      0.0 MiB        1244                       open_set_hash.add(neighbor)
    78                                                             
    79    107.4 MiB      0.0 MiB         978           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.4 MiB      0.0 MiB         978           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.1 MiB    108.1 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.1 MiB   -652.2 MiB         257       for row in grid:
    30    108.1 MiB -167286.0 MiB       65792           for spot in row:
    31    108.1 MiB -166636.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.1 MiB     -2.9 MiB           1       count = 0
    34    105.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.1 MiB      0.0 MiB           1       came_from = {}
    37    107.2 MiB -58373.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.8 MiB     -4.4 MiB           1       g_score[start] = 0
    39    106.0 MiB   -287.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.2 MiB   -102.0 MiB        1784       while not open_set.empty():
    47    106.2 MiB   -102.0 MiB        1784           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.2 MiB   -102.0 MiB        1784           current = open_set.get()[2]
    53    106.2 MiB   -102.0 MiB        1784           open_set_hash.remove(current)
    54                                         
    55    106.2 MiB   -102.0 MiB        1784           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.2 MiB   -102.0 MiB        1784           if current == end:
    60    105.9 MiB     -0.3 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.2 MiB   -759.8 MiB       13361           for neighbor in current.neighbors:
    65    106.2 MiB   -657.9 MiB       11578               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.2 MiB   -324.7 MiB        5687                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.2 MiB   -333.4 MiB        5891                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.2 MiB   -658.1 MiB       11578               if temp_g_score < g_score[neighbor]:
    71    106.2 MiB   -136.1 MiB        2289                   came_from[neighbor] = current
    72    106.2 MiB   -136.2 MiB        2289                   g_score[neighbor] = temp_g_score
    73    106.2 MiB   -136.2 MiB        2289                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.2 MiB   -136.2 MiB        2289                   if neighbor not in open_set_hash:
    75    106.2 MiB   -133.8 MiB        2242                       count += 1
    76    106.2 MiB   -133.8 MiB        2242                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.2 MiB   -133.9 MiB        2242                       open_set_hash.add(neighbor)
    78                                                             
    79    106.2 MiB   -102.0 MiB        1783           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.2 MiB   -102.0 MiB        1783           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.8 MiB    106.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.8 MiB   -533.7 MiB         257       for row in grid:
    30    106.8 MiB -136339.1 MiB       65792           for spot in row:
    31    106.8 MiB -135808.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.6 MiB     -5.2 MiB           1       count = 0
    34    101.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.6 MiB      0.0 MiB           1       came_from = {}
    37    104.8 MiB -20476.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.5 MiB     -0.2 MiB           1       g_score[start] = 0
    39    104.6 MiB -1531850.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     69.4 MiB    -35.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     69.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     69.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     69.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     71.3 MiB   -153.0 MiB        1786       while not open_set.empty():
    47     71.3 MiB   -153.0 MiB        1786           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     71.3 MiB   -153.0 MiB        1786           current = open_set.get()[2]
    53     71.3 MiB   -153.0 MiB        1786           open_set_hash.remove(current)
    54                                         
    55     71.3 MiB   -153.0 MiB        1786           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     71.3 MiB   -153.3 MiB        1786           if current == end:
    60     70.6 MiB     -0.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     71.3 MiB  -1197.5 MiB       13381           for neighbor in current.neighbors:
    65     71.3 MiB  -1043.0 MiB       11596               if current.row != neighbor.row and current.col != neighbor.col:
    66     71.3 MiB   -515.1 MiB        5687                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     71.3 MiB   -529.1 MiB        5909                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     71.3 MiB  -1044.2 MiB       11596               if temp_g_score < g_score[neighbor]:
    71     71.3 MiB   -178.5 MiB        2284                   came_from[neighbor] = current
    72     71.3 MiB   -178.6 MiB        2284                   g_score[neighbor] = temp_g_score
    73     71.3 MiB   -178.6 MiB        2284                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     71.3 MiB   -178.6 MiB        2284                   if neighbor not in open_set_hash:
    75     71.3 MiB   -177.3 MiB        2243                       count += 1
    76     71.3 MiB   -177.2 MiB        2243                       open_set.put((f_score[neighbor], count, neighbor))
    77     71.3 MiB   -177.3 MiB        2243                       open_set_hash.add(neighbor)
    78                                                             
    79     71.3 MiB   -153.0 MiB        1785           if draw is not None:
    80                                                     draw()
    81                                         
    82     71.3 MiB   -153.0 MiB        1785           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.9 MiB    102.9 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.9 MiB   -799.1 MiB         257       for row in grid:
    30    102.9 MiB -205142.4 MiB       65792           for spot in row:
    31    102.9 MiB -204348.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.5 MiB     -6.4 MiB           1       count = 0
    34     96.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.5 MiB      0.0 MiB           1       came_from = {}
    37     98.8 MiB -29854.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     98.6 MiB     -0.2 MiB           1       g_score[start] = 0
    39    101.8 MiB      3.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.0 MiB -100568.0 MiB        8623       while not open_set.empty():
    47    102.0 MiB -100568.1 MiB        8623           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.0 MiB -100568.1 MiB        8623           current = open_set.get()[2]
    53    102.0 MiB -100568.7 MiB        8623           open_set_hash.remove(current)
    54                                         
    55    102.0 MiB -100569.6 MiB        8623           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.0 MiB -100570.4 MiB        8623           if current == end:
    60     61.7 MiB    -40.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.8 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.0 MiB -736436.7 MiB       62857           for neighbor in current.neighbors:
    65    102.0 MiB -635882.3 MiB       54235               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.0 MiB -310618.0 MiB       26484                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.0 MiB -325264.9 MiB       27751                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.0 MiB -635887.2 MiB       54235               if temp_g_score < g_score[neighbor]:
    71    102.0 MiB -133134.6 MiB       11554                   came_from[neighbor] = current
    72    102.0 MiB -133134.7 MiB       11554                   g_score[neighbor] = temp_g_score
    73    102.0 MiB -133134.7 MiB       11554                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.0 MiB -133134.8 MiB       11554                   if neighbor not in open_set_hash:
    75    102.0 MiB -107448.5 MiB        9254                       count += 1
    76    102.0 MiB -107442.6 MiB        9254                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.0 MiB -107465.8 MiB        9254                       open_set_hash.add(neighbor)
    78                                                             
    79    102.0 MiB -100554.2 MiB        8622           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.0 MiB -100568.0 MiB        8622           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.7 MiB     96.7 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.7 MiB    -48.0 MiB         257       for row in grid:
    30     96.7 MiB -12313.2 MiB       65792           for spot in row:
    31     96.7 MiB -12265.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.5 MiB     -0.2 MiB           1       count = 0
    34     96.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.5 MiB      0.0 MiB           1       came_from = {}
    37    101.5 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.5 MiB      0.0 MiB           1       g_score[start] = 0
    39    105.4 MiB  -4241.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.3 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.4 MiB      0.0 MiB         722       while not open_set.empty():
    47    105.4 MiB      0.0 MiB         722           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.4 MiB      0.0 MiB         722           current = open_set.get()[2]
    53    105.4 MiB      0.0 MiB         722           open_set_hash.remove(current)
    54                                         
    55    105.4 MiB      0.0 MiB         722           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.4 MiB      0.0 MiB         722           if current == end:
    60    105.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    105.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.4 MiB      0.0 MiB        5422           for neighbor in current.neighbors:
    65    105.4 MiB      0.0 MiB        4701               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.4 MiB      0.0 MiB        2304                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.4 MiB      0.0 MiB        2397                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.4 MiB      0.0 MiB        4701               if temp_g_score < g_score[neighbor]:
    71    105.4 MiB      0.0 MiB        1019                   came_from[neighbor] = current
    72    105.4 MiB      0.0 MiB        1019                   g_score[neighbor] = temp_g_score
    73    105.4 MiB      0.0 MiB        1019                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.4 MiB      0.0 MiB        1019                   if neighbor not in open_set_hash:
    75    105.4 MiB      0.0 MiB        1002                       count += 1
    76    105.4 MiB      0.0 MiB        1002                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.4 MiB      0.0 MiB        1002                       open_set_hash.add(neighbor)
    78                                                             
    79    105.4 MiB      0.0 MiB         721           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.4 MiB      0.0 MiB         721           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.1 MiB    106.1 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.1 MiB  -1130.5 MiB         257       for row in grid:
    30    106.1 MiB -290117.3 MiB       65792           for spot in row:
    31    106.1 MiB -288993.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.1 MiB     -9.0 MiB           1       count = 0
    34     97.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.1 MiB      0.0 MiB           1       came_from = {}
    37     99.9 MiB -11531.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.7 MiB -187993.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     85.6 MiB    -17.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     85.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     85.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     85.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     87.7 MiB -105057.3 MiB        3628       while not open_set.empty():
    47     87.7 MiB -105057.7 MiB        3628           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     87.7 MiB -105058.1 MiB        3628           current = open_set.get()[2]
    53     87.7 MiB -105058.2 MiB        3628           open_set_hash.remove(current)
    54                                         
    55     87.7 MiB -105058.4 MiB        3628           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     87.7 MiB -105058.7 MiB        3628           if current == end:
    60     46.1 MiB    -41.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     46.2 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     87.7 MiB -757767.0 MiB       26117           for neighbor in current.neighbors:
    65     87.7 MiB -652711.1 MiB       22490               if current.row != neighbor.row and current.col != neighbor.col:
    66     87.7 MiB -317692.6 MiB       10940                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     87.7 MiB -335019.4 MiB       11550                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     87.7 MiB -652710.6 MiB       22490               if temp_g_score < g_score[neighbor]:
    71     87.7 MiB -142056.8 MiB        5026                   came_from[neighbor] = current
    72     87.7 MiB -142056.8 MiB        5026                   g_score[neighbor] = temp_g_score
    73     87.7 MiB -142093.6 MiB        5026                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     87.7 MiB -142093.6 MiB        5026                   if neighbor not in open_set_hash:
    75     87.7 MiB -110111.8 MiB        3958                       count += 1
    76     87.7 MiB -110112.2 MiB        3958                       open_set.put((f_score[neighbor], count, neighbor))
    77     87.7 MiB -110112.2 MiB        3958                       open_set_hash.add(neighbor)
    78                                                             
    79     87.7 MiB -105056.9 MiB        3627           if draw is not None:
    80                                                     draw()
    81                                         
    82     87.7 MiB -105056.9 MiB        3627           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.7 MiB     98.7 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.7 MiB   -509.7 MiB         257       for row in grid:
    30     98.7 MiB -130609.1 MiB       65792           for spot in row:
    31     98.7 MiB -130101.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.8 MiB     -3.0 MiB           1       count = 0
    34     95.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.8 MiB      0.0 MiB           1       came_from = {}
    37     97.8 MiB      2.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.8 MiB -34027.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.9 MiB   -505.1 MiB        1059       while not open_set.empty():
    47    100.9 MiB   -505.1 MiB        1059           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.9 MiB   -505.1 MiB        1059           current = open_set.get()[2]
    53    100.9 MiB   -505.1 MiB        1059           open_set_hash.remove(current)
    54                                         
    55    100.9 MiB   -505.1 MiB        1059           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.9 MiB   -505.1 MiB        1059           if current == end:
    60    100.2 MiB     -0.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.9 MiB  -3742.8 MiB        7869           for neighbor in current.neighbors:
    65    100.9 MiB  -3237.9 MiB        6811               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.9 MiB  -1588.2 MiB        3340                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.9 MiB  -1649.7 MiB        3471                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.9 MiB  -3238.1 MiB        6811               if temp_g_score < g_score[neighbor]:
    71    100.9 MiB   -696.0 MiB        1454                   came_from[neighbor] = current
    72    100.9 MiB   -696.0 MiB        1454                   g_score[neighbor] = temp_g_score
    73    100.9 MiB   -696.0 MiB        1454                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.9 MiB   -696.0 MiB        1454                   if neighbor not in open_set_hash:
    75    100.9 MiB   -640.0 MiB        1359                       count += 1
    76    100.9 MiB   -640.0 MiB        1359                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.9 MiB   -640.0 MiB        1359                       open_set_hash.add(neighbor)
    78                                                             
    79    100.9 MiB   -505.1 MiB        1058           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.9 MiB   -505.1 MiB        1058           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.6 MiB    102.6 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.6 MiB  -1134.1 MiB         257       for row in grid:
    30    102.6 MiB -290549.4 MiB       65792           for spot in row:
    31    102.6 MiB -289417.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.7 MiB     -5.9 MiB           1       count = 0
    34     96.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.7 MiB      0.0 MiB           1       came_from = {}
    37     97.2 MiB -1249399.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     53.4 MiB    -43.8 MiB           1       g_score[start] = 0
    39     58.3 MiB -118821.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     49.2 MiB     -9.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     49.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     49.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     49.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     52.2 MiB  -2886.2 MiB        1654       while not open_set.empty():
    47     52.2 MiB  -2886.3 MiB        1654           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     52.2 MiB  -2886.2 MiB        1654           current = open_set.get()[2]
    53     52.2 MiB  -2886.3 MiB        1654           open_set_hash.remove(current)
    54                                         
    55     52.2 MiB  -2886.3 MiB        1654           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     52.2 MiB  -2886.3 MiB        1654           if current == end:
    60     52.0 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     52.1 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     52.2 MiB -21367.2 MiB       12187           for neighbor in current.neighbors:
    65     52.2 MiB -18479.5 MiB       10534               if current.row != neighbor.row and current.col != neighbor.col:
    66     52.2 MiB  -9104.7 MiB        5176                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     52.2 MiB  -9376.0 MiB        5358                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     52.2 MiB -18479.4 MiB       10534               if temp_g_score < g_score[neighbor]:
    71     52.2 MiB  -4054.2 MiB        2359                   came_from[neighbor] = current
    72     52.2 MiB  -4054.2 MiB        2359                   g_score[neighbor] = temp_g_score
    73     52.2 MiB  -4054.3 MiB        2359                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     52.2 MiB  -4056.2 MiB        2359                   if neighbor not in open_set_hash:
    75     52.2 MiB  -3405.1 MiB        2009                       count += 1
    76     52.2 MiB  -3405.0 MiB        2009                       open_set.put((f_score[neighbor], count, neighbor))
    77     52.2 MiB  -3404.9 MiB        2009                       open_set_hash.add(neighbor)
    78                                                             
    79     52.2 MiB  -2886.0 MiB        1653           if draw is not None:
    80                                                     draw()
    81                                         
    82     52.2 MiB  -2886.2 MiB        1653           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.6 MiB     98.6 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.6 MiB   -186.4 MiB         257       for row in grid:
    30     98.6 MiB -47262.9 MiB       65792           for spot in row:
    31     98.6 MiB -47079.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.0 MiB     -4.7 MiB           1       count = 0
    34     94.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.0 MiB      0.0 MiB           1       came_from = {}
    37     98.8 MiB -59535.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.3 MiB     -3.4 MiB           1       g_score[start] = 0
    39     95.6 MiB -530570.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     51.5 MiB    -44.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     51.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     51.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     51.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     55.6 MiB     -1.6 MiB         641       while not open_set.empty():
    47     55.6 MiB     -1.8 MiB         641           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     55.6 MiB     -1.7 MiB         641           current = open_set.get()[2]
    53     55.6 MiB     -1.8 MiB         641           open_set_hash.remove(current)
    54                                         
    55     55.6 MiB     -1.8 MiB         641           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     55.6 MiB     -1.8 MiB         641           if current == end:
    60     55.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     55.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     55.6 MiB    -11.6 MiB        4731           for neighbor in current.neighbors:
    65     55.6 MiB     -9.3 MiB        4091               if current.row != neighbor.row and current.col != neighbor.col:
    66     55.6 MiB     -5.5 MiB        2012                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     55.6 MiB     -5.5 MiB        2079                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     55.6 MiB    -10.4 MiB        4091               if temp_g_score < g_score[neighbor]:
    71     55.6 MiB     -2.1 MiB         938                   came_from[neighbor] = current
    72     55.6 MiB     -2.3 MiB         938                   g_score[neighbor] = temp_g_score
    73     55.6 MiB     -2.3 MiB         938                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     55.6 MiB     -2.3 MiB         938                   if neighbor not in open_set_hash:
    75     55.6 MiB     -1.9 MiB         837                       count += 1
    76     55.6 MiB     -1.7 MiB         837                       open_set.put((f_score[neighbor], count, neighbor))
    77     55.6 MiB     -1.8 MiB         837                       open_set_hash.add(neighbor)
    78                                                             
    79     55.6 MiB     -1.7 MiB         640           if draw is not None:
    80                                                     draw()
    81                                         
    82     55.6 MiB     -1.8 MiB         640           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.4 MiB    103.4 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.4 MiB   -574.7 MiB         257       for row in grid:
    30    103.4 MiB -147033.0 MiB       65792           for spot in row:
    31    103.4 MiB -146462.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.0 MiB     -7.4 MiB           1       count = 0
    34     96.1 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     96.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.1 MiB      0.0 MiB           1       came_from = {}
    37     99.1 MiB -41723.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.7 MiB     -1.4 MiB           1       g_score[start] = 0
    39     98.3 MiB -260076.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     93.4 MiB     -4.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     93.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     93.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     93.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     93.9 MiB  -4035.6 MiB         763       while not open_set.empty():
    47     93.9 MiB  -4035.6 MiB         763           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     93.9 MiB  -4035.5 MiB         763           current = open_set.get()[2]
    53     93.9 MiB  -4035.6 MiB         763           open_set_hash.remove(current)
    54                                         
    55     93.9 MiB  -4035.6 MiB         763           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     93.9 MiB  -4035.6 MiB         763           if current == end:
    60     80.9 MiB    -13.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     80.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     93.9 MiB -30479.4 MiB        5694           for neighbor in current.neighbors:
    65     93.9 MiB -26443.7 MiB        4932               if current.row != neighbor.row and current.col != neighbor.col:
    66     93.9 MiB -13012.1 MiB        2421                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     93.9 MiB -13431.7 MiB        2511                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     93.9 MiB -26457.0 MiB        4932               if temp_g_score < g_score[neighbor]:
    71     93.9 MiB  -5737.0 MiB        1087                   came_from[neighbor] = current
    72     93.9 MiB  -5737.1 MiB        1087                   g_score[neighbor] = temp_g_score
    73     93.9 MiB  -5737.1 MiB        1087                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     93.9 MiB  -5737.1 MiB        1087                   if neighbor not in open_set_hash:
    75     93.9 MiB  -5618.9 MiB        1065                       count += 1
    76     93.9 MiB  -5618.9 MiB        1065                       open_set.put((f_score[neighbor], count, neighbor))
    77     93.9 MiB  -5618.8 MiB        1065                       open_set_hash.add(neighbor)
    78                                                             
    79     93.9 MiB  -4035.6 MiB         762           if draw is not None:
    80                                                     draw()
    81                                         
    82     93.9 MiB  -4035.6 MiB         762           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.3 MiB    101.3 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.3 MiB   -403.7 MiB         257       for row in grid:
    30    101.3 MiB -103061.5 MiB       65792           for spot in row:
    31    101.3 MiB -102660.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.0 MiB     -4.3 MiB           1       count = 0
    34     97.1 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     97.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.1 MiB      0.0 MiB           1       came_from = {}
    37     99.0 MiB -24011.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.1 MiB     -1.9 MiB           1       g_score[start] = 0
    39     99.6 MiB -353958.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     69.5 MiB    -30.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     69.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     69.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     69.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.0 MiB -37758.8 MiB        1780       while not open_set.empty():
    47     70.0 MiB -37759.0 MiB        1780           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.0 MiB -37759.1 MiB        1780           current = open_set.get()[2]
    53     70.0 MiB -37759.1 MiB        1780           open_set_hash.remove(current)
    54                                         
    55     70.0 MiB -37759.2 MiB        1780           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.0 MiB -37759.2 MiB        1780           if current == end:
    60     48.1 MiB    -22.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     48.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.0 MiB -276632.6 MiB       13043           for neighbor in current.neighbors:
    65     70.0 MiB -238872.7 MiB       11264               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.0 MiB -116782.1 MiB        5505                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.0 MiB -122094.1 MiB        5759                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.0 MiB -238878.5 MiB       11264               if temp_g_score < g_score[neighbor]:
    71     70.0 MiB -50689.2 MiB        2428                   came_from[neighbor] = current
    72     70.0 MiB -50690.2 MiB        2428                   g_score[neighbor] = temp_g_score
    73     70.0 MiB -50699.5 MiB        2428                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.0 MiB -50700.4 MiB        2428                   if neighbor not in open_set_hash:
    75     70.0 MiB -46643.8 MiB        2235                       count += 1
    76     70.0 MiB -46645.3 MiB        2235                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.0 MiB -46645.9 MiB        2235                       open_set_hash.add(neighbor)
    78                                                             
    79     70.0 MiB -37758.3 MiB        1779           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.0 MiB -37758.6 MiB        1779           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.7 MiB     99.7 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.7 MiB      0.0 MiB         257       for row in grid:
    30     99.7 MiB      0.0 MiB       65792           for spot in row:
    31     99.7 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.7 MiB      0.0 MiB           1       count = 0
    34     99.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.7 MiB      0.0 MiB           1       came_from = {}
    37    104.0 MiB  -7410.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.0 MiB -95568.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.2 MiB     -7.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    100.6 MiB      0.1 MiB         100       while not open_set.empty():
    47    100.6 MiB      0.0 MiB         100           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    100.6 MiB      0.1 MiB         100           current = open_set.get()[2]
    53    100.6 MiB      0.0 MiB         100           open_set_hash.remove(current)
    54                                         
    55    100.6 MiB      0.0 MiB         100           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    100.6 MiB      0.0 MiB         100           if current == end:
    60    100.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    100.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    100.6 MiB      0.0 MiB         742           for neighbor in current.neighbors:
    65    100.6 MiB      0.0 MiB         643               if current.row != neighbor.row and current.col != neighbor.col:
    66    100.6 MiB      0.0 MiB         313                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    100.6 MiB      0.0 MiB         330                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    100.6 MiB      0.0 MiB         643               if temp_g_score < g_score[neighbor]:
    71    100.6 MiB      0.0 MiB         170                   came_from[neighbor] = current
    72    100.6 MiB      0.0 MiB         170                   g_score[neighbor] = temp_g_score
    73    100.6 MiB      0.0 MiB         170                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    100.6 MiB      0.0 MiB         170                   if neighbor not in open_set_hash:
    75    100.6 MiB      0.0 MiB         161                       count += 1
    76    100.6 MiB      0.1 MiB         161                       open_set.put((f_score[neighbor], count, neighbor))
    77    100.6 MiB      0.0 MiB         161                       open_set_hash.add(neighbor)
    78                                                             
    79    100.6 MiB      0.0 MiB          99           if draw is not None:
    80                                                     draw()
    81                                         
    82    100.6 MiB      0.0 MiB          99           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.1 MiB    107.1 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.1 MiB  -1158.2 MiB         257       for row in grid:
    30    107.1 MiB -295817.3 MiB       65792           for spot in row:
    31    107.1 MiB -294663.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.1 MiB     -9.0 MiB           1       count = 0
    34     98.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.1 MiB      0.0 MiB           1       came_from = {}
    37    100.3 MiB -37835.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.0 MiB     -1.3 MiB           1       g_score[start] = 0
    39    101.1 MiB -1514999.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     64.8 MiB    -36.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     64.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     64.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     64.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     71.8 MiB -26324.5 MiB        3799       while not open_set.empty():
    47     71.8 MiB -26324.5 MiB        3799           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     71.8 MiB -26323.7 MiB        3799           current = open_set.get()[2]
    53     71.8 MiB -26324.0 MiB        3799           open_set_hash.remove(current)
    54                                         
    55     71.8 MiB -26325.4 MiB        3799           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     71.8 MiB -26325.6 MiB        3799           if current == end:
    60     53.1 MiB    -18.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     53.3 MiB      0.3 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     71.8 MiB -190491.2 MiB       27998           for neighbor in current.neighbors:
    65     71.8 MiB -164176.7 MiB       24200               if current.row != neighbor.row and current.col != neighbor.col:
    66     71.8 MiB -80088.8 MiB       11859                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     71.8 MiB -84091.1 MiB       12341                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     71.8 MiB -164183.9 MiB       24200               if temp_g_score < g_score[neighbor]:
    71     71.8 MiB -32448.6 MiB        4829                   came_from[neighbor] = current
    72     71.8 MiB -32448.9 MiB        4829                   g_score[neighbor] = temp_g_score
    73     71.8 MiB -32448.8 MiB        4829                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     71.8 MiB -32449.0 MiB        4829                   if neighbor not in open_set_hash:
    75     71.8 MiB -26923.6 MiB        4499                       count += 1
    76     71.8 MiB -26917.3 MiB        4499                       open_set.put((f_score[neighbor], count, neighbor))
    77     71.8 MiB -26923.0 MiB        4499                       open_set_hash.add(neighbor)
    78                                                             
    79     71.8 MiB -26336.5 MiB        3798           if draw is not None:
    80                                                     draw()
    81                                         
    82     71.8 MiB -26324.3 MiB        3798           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.1 MiB     96.1 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     96.1 MiB   -826.4 MiB         257       for row in grid:
    30     96.1 MiB -211573.2 MiB       65792           for spot in row:
    31     96.1 MiB -210752.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     89.6 MiB     -6.5 MiB           1       count = 0
    34     89.8 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     89.9 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     89.9 MiB      0.0 MiB           1       came_from = {}
    37     94.0 MiB  -2177.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     93.8 MiB     -0.3 MiB           1       g_score[start] = 0
    39     94.5 MiB -115319.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     94.5 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     94.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     94.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     94.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     94.6 MiB      0.0 MiB         307       while not open_set.empty():
    47     94.6 MiB      0.0 MiB         307           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     94.6 MiB      0.0 MiB         307           current = open_set.get()[2]
    53     94.6 MiB      0.0 MiB         307           open_set_hash.remove(current)
    54                                         
    55     94.6 MiB      0.0 MiB         307           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     94.6 MiB      0.0 MiB         307           if current == end:
    60     94.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     94.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     94.6 MiB      0.0 MiB        2252           for neighbor in current.neighbors:
    65     94.6 MiB      0.0 MiB        1946               if current.row != neighbor.row and current.col != neighbor.col:
    66     94.6 MiB      0.0 MiB         951                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     94.6 MiB      0.0 MiB         995                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     94.6 MiB      0.0 MiB        1946               if temp_g_score < g_score[neighbor]:
    71     94.6 MiB      0.0 MiB         442                   came_from[neighbor] = current
    72     94.6 MiB      0.0 MiB         442                   g_score[neighbor] = temp_g_score
    73     94.6 MiB      0.0 MiB         442                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     94.6 MiB      0.0 MiB         442                   if neighbor not in open_set_hash:
    75     94.6 MiB      0.0 MiB         436                       count += 1
    76     94.6 MiB      0.0 MiB         436                       open_set.put((f_score[neighbor], count, neighbor))
    77     94.6 MiB      0.0 MiB         436                       open_set_hash.add(neighbor)
    78                                                             
    79     94.6 MiB      0.0 MiB         306           if draw is not None:
    80                                                     draw()
    81                                         
    82     94.6 MiB      0.0 MiB         306           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.0 MiB    102.0 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.0 MiB  -5041.6 MiB         257       for row in grid:
    30    102.0 MiB -1289137.9 MiB       65792           for spot in row:
    31    102.0 MiB -1284138.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     16.0 MiB    -86.0 MiB           1       count = 0
    34     16.3 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     16.5 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     16.6 MiB      0.0 MiB           1       came_from = {}
    37     24.0 MiB -292840.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     18.0 MiB     -5.9 MiB           1       g_score[start] = 0
    39     21.0 MiB -203799.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     18.2 MiB     -2.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     18.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     18.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     18.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     53.2 MiB -84101.6 MiB        4914       while not open_set.empty():
    47     53.2 MiB -84102.6 MiB        4914           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     53.2 MiB -84101.9 MiB        4914           current = open_set.get()[2]
    53     53.2 MiB -84104.1 MiB        4914           open_set_hash.remove(current)
    54                                         
    55     53.2 MiB -84105.2 MiB        4914           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     53.2 MiB -84105.4 MiB        4914           if current == end:
    60     25.7 MiB    -27.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     25.8 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     53.2 MiB -614341.2 MiB       36188           for neighbor in current.neighbors:
    65     53.2 MiB -530263.8 MiB       31275               if current.row != neighbor.row and current.col != neighbor.col:
    66     53.2 MiB -260309.0 MiB       15321                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     53.2 MiB -269959.5 MiB       15954                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     53.2 MiB -530262.7 MiB       31275               if temp_g_score < g_score[neighbor]:
    71     53.2 MiB -109378.2 MiB        6463                   came_from[neighbor] = current
    72     53.2 MiB -109377.8 MiB        6463                   g_score[neighbor] = temp_g_score
    73     53.2 MiB -109373.2 MiB        6463                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     53.2 MiB -109374.2 MiB        6463                   if neighbor not in open_set_hash:
    75     53.2 MiB -94706.4 MiB        5921                       count += 1
    76     53.2 MiB -94676.8 MiB        5921                       open_set.put((f_score[neighbor], count, neighbor))
    77     53.2 MiB -94709.0 MiB        5921                       open_set_hash.add(neighbor)
    78                                                             
    79     53.2 MiB -84070.2 MiB        4913           if draw is not None:
    80                                                     draw()
    81                                         
    82     53.2 MiB -84100.9 MiB        4913           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     87.5 MiB     87.5 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     87.5 MiB -11093.3 MiB         257       for row in grid:
    30     87.5 MiB -2841318.1 MiB       65792           for spot in row:
    31     87.5 MiB -2830255.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     29.4 MiB    -58.2 MiB           1       count = 0
    34     29.7 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     29.9 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     29.9 MiB      0.0 MiB           1       came_from = {}
    37     40.5 MiB -138600.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     35.4 MiB     -5.1 MiB           1       g_score[start] = 0
    39     35.4 MiB -1002446.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     20.4 MiB    -15.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     20.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     20.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     20.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     54.3 MiB -22290.5 MiB        4603       while not open_set.empty():
    47     54.3 MiB -22290.7 MiB        4603           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     54.3 MiB -22290.7 MiB        4603           current = open_set.get()[2]
    53     54.3 MiB -22291.0 MiB        4603           open_set_hash.remove(current)
    54                                         
    55     54.3 MiB -22291.1 MiB        4603           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     54.3 MiB -22291.1 MiB        4603           if current == end:
    60     27.6 MiB    -26.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     27.7 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     54.3 MiB -162075.6 MiB       33720           for neighbor in current.neighbors:
    65     54.3 MiB -139781.2 MiB       29118               if current.row != neighbor.row and current.col != neighbor.col:
    66     54.3 MiB -68458.3 MiB       14247                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     54.3 MiB -71355.5 MiB       14871                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     54.3 MiB -139800.9 MiB       29118               if temp_g_score < g_score[neighbor]:
    71     54.3 MiB -26298.2 MiB        5910                   came_from[neighbor] = current
    72     54.3 MiB -26299.1 MiB        5910                   g_score[neighbor] = temp_g_score
    73     54.3 MiB -26298.8 MiB        5910                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     54.3 MiB -26300.2 MiB        5910                   if neighbor not in open_set_hash:
    75     54.3 MiB -20776.2 MiB        5250                       count += 1
    76     54.3 MiB -20752.0 MiB        5250                       open_set.put((f_score[neighbor], count, neighbor))
    77     54.3 MiB -20776.6 MiB        5250                       open_set_hash.add(neighbor)
    78                                                             
    79     54.3 MiB -22293.4 MiB        4602           if draw is not None:
    80                                                     draw()
    81                                         
    82     54.3 MiB -22290.6 MiB        4602           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     85.6 MiB     85.6 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     85.6 MiB  -7908.5 MiB         257       for row in grid:
    30     85.6 MiB -2028673.2 MiB       65792           for spot in row:
    31     85.6 MiB -2020777.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     34.7 MiB    -50.9 MiB           1       count = 0
    34     35.0 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     35.2 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     35.3 MiB      0.0 MiB           1       came_from = {}
    37     38.8 MiB -179383.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     38.0 MiB     -0.8 MiB           1       g_score[start] = 0
    39     38.8 MiB -206497.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     34.5 MiB     -4.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     34.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     34.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     34.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     41.9 MiB  -4186.8 MiB        2214       while not open_set.empty():
    47     41.9 MiB  -4187.0 MiB        2214           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     41.9 MiB  -4186.8 MiB        2214           current = open_set.get()[2]
    53     41.9 MiB  -4187.1 MiB        2214           open_set_hash.remove(current)
    54                                         
    55     41.9 MiB  -4187.1 MiB        2214           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     41.9 MiB  -4187.1 MiB        2214           if current == end:
    60     37.2 MiB     -4.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     37.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     41.9 MiB -30806.3 MiB       16487           for neighbor in current.neighbors:
    65     41.9 MiB -26618.5 MiB       14274               if current.row != neighbor.row and current.col != neighbor.col:
    66     41.9 MiB -13110.1 MiB        7035                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     41.9 MiB -13513.5 MiB        7239                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     41.9 MiB -26624.4 MiB       14274               if temp_g_score < g_score[neighbor]:
    71     41.9 MiB  -5904.0 MiB        2999                   came_from[neighbor] = current
    72     41.9 MiB  -5904.7 MiB        2999                   g_score[neighbor] = temp_g_score
    73     41.9 MiB  -5904.7 MiB        2999                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     41.9 MiB  -5907.0 MiB        2999                   if neighbor not in open_set_hash:
    75     41.9 MiB  -4709.7 MiB        2655                       count += 1
    76     41.9 MiB  -4709.5 MiB        2655                       open_set.put((f_score[neighbor], count, neighbor))
    77     41.9 MiB  -4709.5 MiB        2655                       open_set_hash.add(neighbor)
    78                                                             
    79     41.9 MiB  -4186.0 MiB        2213           if draw is not None:
    80                                                     draw()
    81                                         
    82     41.9 MiB  -4187.0 MiB        2213           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     88.4 MiB     88.4 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     88.4 MiB -10919.3 MiB         257       for row in grid:
    30     88.4 MiB -2797894.7 MiB       65792           for spot in row:
    31     88.4 MiB -2787017.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     38.5 MiB    -49.9 MiB           1       count = 0
    34     38.8 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     39.0 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     39.0 MiB      0.0 MiB           1       came_from = {}
    37     49.9 MiB -31057.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     48.0 MiB     -1.9 MiB           1       g_score[start] = 0
    39     49.0 MiB -141179.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     45.0 MiB     -4.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     45.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     45.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     45.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     46.7 MiB   -272.3 MiB         409       while not open_set.empty():
    47     46.7 MiB   -272.4 MiB         409           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     46.7 MiB   -272.4 MiB         409           current = open_set.get()[2]
    53     46.7 MiB   -274.1 MiB         409           open_set_hash.remove(current)
    54                                         
    55     46.7 MiB   -274.1 MiB         409           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     46.7 MiB   -274.1 MiB         409           if current == end:
    60     46.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     46.7 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     46.7 MiB  -1997.6 MiB        3068           for neighbor in current.neighbors:
    65     46.7 MiB  -1723.9 MiB        2660               if current.row != neighbor.row and current.col != neighbor.col:
    66     46.7 MiB   -837.8 MiB        1303                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     46.7 MiB   -886.9 MiB        1357                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     46.7 MiB  -1724.7 MiB        2660               if temp_g_score < g_score[neighbor]:
    71     46.7 MiB   -382.5 MiB         635                   came_from[neighbor] = current
    72     46.7 MiB   -382.5 MiB         635                   g_score[neighbor] = temp_g_score
    73     46.7 MiB   -382.5 MiB         635                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     46.7 MiB   -382.5 MiB         635                   if neighbor not in open_set_hash:
    75     46.7 MiB   -362.6 MiB         620                       count += 1
    76     46.7 MiB   -362.5 MiB         620                       open_set.put((f_score[neighbor], count, neighbor))
    77     46.7 MiB   -362.4 MiB         620                       open_set_hash.add(neighbor)
    78                                                             
    79     46.7 MiB   -272.4 MiB         408           if draw is not None:
    80                                                     draw()
    81                                         
    82     46.7 MiB   -272.4 MiB         408           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.4 MiB     92.4 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.4 MiB  -6613.3 MiB         257       for row in grid:
    30     92.4 MiB -1695562.8 MiB       65792           for spot in row:
    31     92.4 MiB -1688966.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     34.3 MiB    -58.1 MiB           1       count = 0
    34     34.7 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     34.9 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     34.9 MiB      0.0 MiB           1       came_from = {}
    37     47.7 MiB   -317.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     47.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     54.5 MiB   -620.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     54.7 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     54.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     54.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     54.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     55.2 MiB  -3321.8 MiB        1151       while not open_set.empty():
    47     55.2 MiB  -3321.8 MiB        1151           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     55.2 MiB  -3322.5 MiB        1151           current = open_set.get()[2]
    53     55.2 MiB  -3323.1 MiB        1151           open_set_hash.remove(current)
    54                                         
    55     55.2 MiB  -3323.6 MiB        1151           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     55.2 MiB  -3323.9 MiB        1151           if current == end:
    60     47.5 MiB     -7.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     47.6 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     55.2 MiB -24094.2 MiB        8232           for neighbor in current.neighbors:
    65     55.2 MiB -20776.4 MiB        7082               if current.row != neighbor.row and current.col != neighbor.col:
    66     55.2 MiB -10244.4 MiB        3466                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     55.2 MiB -10532.7 MiB        3616                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     55.2 MiB -20777.8 MiB        7082               if temp_g_score < g_score[neighbor]:
    71     55.2 MiB  -4935.0 MiB        1717                   came_from[neighbor] = current
    72     55.2 MiB  -4935.2 MiB        1717                   g_score[neighbor] = temp_g_score
    73     55.2 MiB  -4935.3 MiB        1717                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     55.2 MiB  -4935.3 MiB        1717                   if neighbor not in open_set_hash:
    75     55.2 MiB  -4222.0 MiB        1525                       count += 1
    76     55.2 MiB  -4221.9 MiB        1525                       open_set.put((f_score[neighbor], count, neighbor))
    77     55.2 MiB  -4222.0 MiB        1525                       open_set_hash.add(neighbor)
    78                                                             
    79     55.2 MiB  -3321.2 MiB        1150           if draw is not None:
    80                                                     draw()
    81                                         
    82     55.2 MiB  -3321.8 MiB        1150           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     91.9 MiB     91.9 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     91.9 MiB  -2374.8 MiB         257       for row in grid:
    30     91.9 MiB -604732.6 MiB       65792           for spot in row:
    31     91.9 MiB -602402.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     28.0 MiB    -63.9 MiB           1       count = 0
    34     28.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     28.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     28.1 MiB      0.0 MiB           1       came_from = {}
    37     38.3 MiB -35075.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     37.8 MiB     -0.5 MiB           1       g_score[start] = 0
    39     38.9 MiB -808701.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     23.6 MiB    -15.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     23.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     23.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     23.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     52.1 MiB  -1204.8 MiB        2059       while not open_set.empty():
    47     52.1 MiB  -1205.0 MiB        2059           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     52.1 MiB  -1204.9 MiB        2059           current = open_set.get()[2]
    53     52.1 MiB  -1205.5 MiB        2059           open_set_hash.remove(current)
    54                                         
    55     52.1 MiB  -1205.6 MiB        2059           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     52.1 MiB  -1205.8 MiB        2059           if current == end:
    60     47.5 MiB     -4.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     47.5 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     52.1 MiB  -8871.8 MiB       15533           for neighbor in current.neighbors:
    65     52.1 MiB  -7668.4 MiB       13475               if current.row != neighbor.row and current.col != neighbor.col:
    66     52.1 MiB  -3760.8 MiB        6620                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     52.1 MiB  -3911.9 MiB        6855                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     52.1 MiB  -7674.4 MiB       13475               if temp_g_score < g_score[neighbor]:
    71     52.1 MiB  -1587.1 MiB        2739                   came_from[neighbor] = current
    72     52.1 MiB  -1587.4 MiB        2739                   g_score[neighbor] = temp_g_score
    73     52.1 MiB  -1587.6 MiB        2739                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     52.1 MiB  -1587.8 MiB        2739                   if neighbor not in open_set_hash:
    75     52.1 MiB  -1574.9 MiB        2701                       count += 1
    76     52.1 MiB  -1549.2 MiB        2701                       open_set.put((f_score[neighbor], count, neighbor))
    77     52.1 MiB  -1568.8 MiB        2701                       open_set_hash.add(neighbor)
    78                                                             
    79     52.1 MiB  -1201.6 MiB        2058           if draw is not None:
    80                                                     draw()
    81                                         
    82     52.1 MiB  -1202.0 MiB        2058           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     82.7 MiB     82.7 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     82.7 MiB  -7840.4 MiB         257       for row in grid:
    30     82.7 MiB -2010371.4 MiB       65792           for spot in row:
    31     82.7 MiB -2002560.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     28.6 MiB    -54.1 MiB           1       count = 0
    34     28.9 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     29.1 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     29.1 MiB      0.0 MiB           1       came_from = {}
    37     44.2 MiB    -24.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     44.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     46.4 MiB -72075.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     44.2 MiB     -2.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     44.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     44.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     44.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     44.5 MiB   -355.3 MiB         137       while not open_set.empty():
    47     44.5 MiB   -356.2 MiB         137           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     44.5 MiB   -356.1 MiB         137           current = open_set.get()[2]
    53     44.5 MiB   -356.2 MiB         137           open_set_hash.remove(current)
    54                                         
    55     44.5 MiB   -356.2 MiB         137           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     44.5 MiB   -356.2 MiB         137           if current == end:
    60     40.7 MiB     -3.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     40.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     44.5 MiB  -2604.7 MiB        1017           for neighbor in current.neighbors:
    65     44.5 MiB  -2249.2 MiB         881               if current.row != neighbor.row and current.col != neighbor.col:
    66     44.5 MiB  -1103.8 MiB         433                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     44.5 MiB  -1145.6 MiB         448                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     44.5 MiB  -2249.4 MiB         881               if temp_g_score < g_score[neighbor]:
    71     44.5 MiB   -537.6 MiB         219                   came_from[neighbor] = current
    72     44.5 MiB   -537.6 MiB         219                   g_score[neighbor] = temp_g_score
    73     44.5 MiB   -538.8 MiB         219                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     44.5 MiB   -538.8 MiB         219                   if neighbor not in open_set_hash:
    75     44.5 MiB   -499.0 MiB         204                       count += 1
    76     44.5 MiB   -499.0 MiB         204                       open_set.put((f_score[neighbor], count, neighbor))
    77     44.5 MiB   -501.1 MiB         204                       open_set_hash.add(neighbor)
    78                                                             
    79     44.5 MiB   -355.3 MiB         136           if draw is not None:
    80                                                     draw()
    81                                         
    82     44.5 MiB   -355.3 MiB         136           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     91.8 MiB     91.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     91.8 MiB  -2158.1 MiB         257       for row in grid:
    30     91.8 MiB -553135.2 MiB       65792           for spot in row:
    31     91.8 MiB -550986.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     80.8 MiB    -11.0 MiB           1       count = 0
    34     80.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     80.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     80.8 MiB      0.0 MiB           1       came_from = {}
    37     86.4 MiB  -8388.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     85.5 MiB     -0.9 MiB           1       g_score[start] = 0
    39     85.9 MiB -2640397.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     32.5 MiB    -53.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     32.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     32.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     32.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     55.5 MiB  -2612.8 MiB        3407       while not open_set.empty():
    47     55.5 MiB  -2613.0 MiB        3407           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     55.5 MiB  -2612.7 MiB        3407           current = open_set.get()[2]
    53     55.5 MiB  -2613.0 MiB        3407           open_set_hash.remove(current)
    54                                         
    55     55.5 MiB  -2613.0 MiB        3407           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     55.5 MiB  -2613.1 MiB        3407           if current == end:
    60     53.6 MiB     -1.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     53.8 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     55.5 MiB -19256.8 MiB       25298           for neighbor in current.neighbors:
    65     55.5 MiB -16641.5 MiB       21892               if current.row != neighbor.row and current.col != neighbor.col:
    66     55.5 MiB  -8208.6 MiB       10706                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     55.5 MiB  -8439.2 MiB       11186                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     55.5 MiB -16645.1 MiB       21892               if temp_g_score < g_score[neighbor]:
    71     55.5 MiB  -3484.7 MiB        4687                   came_from[neighbor] = current
    72     55.5 MiB  -3485.0 MiB        4687                   g_score[neighbor] = temp_g_score
    73     55.5 MiB  -3484.8 MiB        4687                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     55.5 MiB  -3484.8 MiB        4687                   if neighbor not in open_set_hash:
    75     55.5 MiB  -2983.4 MiB        4262                       count += 1
    76     55.5 MiB  -2965.2 MiB        4262                       open_set.put((f_score[neighbor], count, neighbor))
    77     55.5 MiB  -2975.7 MiB        4262                       open_set_hash.add(neighbor)
    78                                                             
    79     55.5 MiB  -2612.7 MiB        3406           if draw is not None:
    80                                                     draw()
    81                                         
    82     55.5 MiB  -2613.0 MiB        3406           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     86.7 MiB     86.7 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     86.7 MiB  -6744.0 MiB         257       for row in grid:
    30     86.7 MiB -1727649.8 MiB       65792           for spot in row:
    31     86.7 MiB -1720934.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     37.9 MiB    -48.8 MiB           1       count = 0
    34     38.2 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     38.5 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     38.5 MiB      0.0 MiB           1       came_from = {}
    37     50.3 MiB -31369.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     41.6 MiB     -8.7 MiB           1       g_score[start] = 0
    39     41.8 MiB -1018415.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     25.3 MiB    -16.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     25.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     25.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     25.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     30.8 MiB  -3377.0 MiB         997       while not open_set.empty():
    47     30.8 MiB  -3378.8 MiB         997           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     30.8 MiB  -3378.8 MiB         997           current = open_set.get()[2]
    53     30.8 MiB  -3379.1 MiB         997           open_set_hash.remove(current)
    54                                         
    55     30.8 MiB  -3379.4 MiB         997           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     30.8 MiB  -3379.5 MiB         997           if current == end:
    60     23.3 MiB     -7.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     23.4 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     30.8 MiB -24471.5 MiB        7061           for neighbor in current.neighbors:
    65     30.8 MiB -21104.4 MiB        6065               if current.row != neighbor.row and current.col != neighbor.col:
    66     30.8 MiB -10261.8 MiB        2943                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     30.8 MiB -10845.6 MiB        3122                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     30.8 MiB -21077.1 MiB        6065               if temp_g_score < g_score[neighbor]:
    71     30.8 MiB  -5815.7 MiB        1727                   came_from[neighbor] = current
    72     30.8 MiB  -5816.0 MiB        1727                   g_score[neighbor] = temp_g_score
    73     30.8 MiB  -5816.5 MiB        1727                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     30.8 MiB  -5817.4 MiB        1727                   if neighbor not in open_set_hash:
    75     30.8 MiB  -4299.5 MiB        1318                       count += 1
    76     30.8 MiB  -4299.8 MiB        1318                       open_set.put((f_score[neighbor], count, neighbor))
    77     30.8 MiB  -4300.0 MiB        1318                       open_set_hash.add(neighbor)
    78                                                             
    79     30.8 MiB  -3387.0 MiB         996           if draw is not None:
    80                                                     draw()
    81                                         
    82     30.8 MiB  -3377.2 MiB         996           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     86.1 MiB     86.1 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     86.1 MiB -10265.2 MiB         257       for row in grid:
    30     86.1 MiB -2631360.6 MiB       65792           for spot in row:
    31     86.1 MiB -2621115.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     44.2 MiB    -41.9 MiB           1       count = 0
    34     44.5 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     44.7 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     44.7 MiB      0.0 MiB           1       came_from = {}
    37     52.2 MiB -166711.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     44.3 MiB     -7.9 MiB           1       g_score[start] = 0
    39     50.5 MiB   -779.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     50.7 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     50.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     50.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     50.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     51.9 MiB    -11.8 MiB         293       while not open_set.empty():
    47     51.9 MiB    -11.8 MiB         293           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     51.9 MiB    -11.8 MiB         293           current = open_set.get()[2]
    53     51.9 MiB    -11.8 MiB         293           open_set_hash.remove(current)
    54                                         
    55     51.9 MiB    -11.8 MiB         293           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     51.9 MiB    -12.0 MiB         293           if current == end:
    60     50.6 MiB     -1.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     50.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     51.9 MiB    -77.8 MiB        2131           for neighbor in current.neighbors:
    65     51.9 MiB    -65.9 MiB        1839               if current.row != neighbor.row and current.col != neighbor.col:
    66     51.9 MiB    -32.4 MiB         897                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     51.9 MiB    -34.4 MiB         942                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     51.9 MiB    -66.9 MiB        1839               if temp_g_score < g_score[neighbor]:
    71     51.9 MiB    -21.3 MiB         452                   came_from[neighbor] = current
    72     51.9 MiB    -21.4 MiB         452                   g_score[neighbor] = temp_g_score
    73     51.9 MiB    -21.5 MiB         452                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     51.9 MiB    -21.5 MiB         452                   if neighbor not in open_set_hash:
    75     51.9 MiB    -21.5 MiB         416                       count += 1
    76     51.9 MiB    -21.4 MiB         416                       open_set.put((f_score[neighbor], count, neighbor))
    77     51.9 MiB    -21.5 MiB         416                       open_set_hash.add(neighbor)
    78                                                             
    79     51.9 MiB    -11.7 MiB         292           if draw is not None:
    80                                                     draw()
    81                                         
    82     51.9 MiB    -11.8 MiB         292           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     88.3 MiB     88.3 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     88.3 MiB  -9102.8 MiB         257       for row in grid:
    30     88.3 MiB -2329970.3 MiB       65792           for spot in row:
    31     88.3 MiB -2320900.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     38.2 MiB    -50.1 MiB           1       count = 0
    34     38.6 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     38.8 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     38.8 MiB      0.0 MiB           1       came_from = {}
    37     50.8 MiB -10865.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     49.2 MiB     -1.6 MiB           1       g_score[start] = 0
    39     54.2 MiB -56864.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     49.2 MiB     -5.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     49.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     49.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     49.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     87.1 MiB  -5919.6 MiB        2308       while not open_set.empty():
    47     87.1 MiB  -5919.7 MiB        2308           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     87.1 MiB  -5919.6 MiB        2308           current = open_set.get()[2]
    53     87.1 MiB  -5919.7 MiB        2308           open_set_hash.remove(current)
    54                                         
    55     87.1 MiB  -5919.7 MiB        2308           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     87.1 MiB  -5919.7 MiB        2308           if current == end:
    60     85.2 MiB     -1.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     85.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     87.1 MiB -44469.6 MiB       17285           for neighbor in current.neighbors:
    65     87.1 MiB -38554.0 MiB       14978               if current.row != neighbor.row and current.col != neighbor.col:
    66     87.1 MiB -18978.1 MiB        7366                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     87.1 MiB -19577.3 MiB        7612                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     87.1 MiB -38555.3 MiB       14978               if temp_g_score < g_score[neighbor]:
    71     87.1 MiB  -7770.7 MiB        3096                   came_from[neighbor] = current
    72     87.1 MiB  -7771.1 MiB        3096                   g_score[neighbor] = temp_g_score
    73     87.1 MiB  -7773.3 MiB        3096                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     87.1 MiB  -7773.3 MiB        3096                   if neighbor not in open_set_hash:
    75     87.1 MiB  -7652.4 MiB        3049                       count += 1
    76     87.1 MiB  -7611.0 MiB        3049                       open_set.put((f_score[neighbor], count, neighbor))
    77     87.1 MiB  -7648.3 MiB        3049                       open_set_hash.add(neighbor)
    78                                                             
    79     87.1 MiB  -5917.0 MiB        2307           if draw is not None:
    80                                                     draw()
    81                                         
    82     87.1 MiB  -5917.0 MiB        2307           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     86.7 MiB     86.7 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     86.7 MiB   -546.7 MiB         257       for row in grid:
    30     86.7 MiB -139835.7 MiB       65792           for spot in row:
    31     86.7 MiB -139292.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     81.2 MiB     -5.5 MiB           1       count = 0
    34     81.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     81.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     81.2 MiB      0.0 MiB           1       came_from = {}
    37     82.3 MiB -771944.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     45.6 MiB    -36.7 MiB           1       g_score[start] = 0
    39     46.4 MiB -549976.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     32.1 MiB    -14.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     32.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     32.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     32.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     36.2 MiB   -519.1 MiB         472       while not open_set.empty():
    47     36.2 MiB   -519.3 MiB         472           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     36.2 MiB   -519.5 MiB         472           current = open_set.get()[2]
    53     36.2 MiB   -519.8 MiB         472           open_set_hash.remove(current)
    54                                         
    55     36.2 MiB   -519.8 MiB         472           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     36.2 MiB   -519.8 MiB         472           if current == end:
    60     34.1 MiB     -2.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     34.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     36.2 MiB  -4052.1 MiB        3618           for neighbor in current.neighbors:
    65     36.2 MiB  -3531.4 MiB        3147               if current.row != neighbor.row and current.col != neighbor.col:
    66     36.2 MiB  -1746.8 MiB        1553                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     36.2 MiB  -1786.1 MiB        1594                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     36.2 MiB  -3532.0 MiB        3147               if temp_g_score < g_score[neighbor]:
    71     36.2 MiB   -684.2 MiB         673                   came_from[neighbor] = current
    72     36.2 MiB   -684.5 MiB         673                   g_score[neighbor] = temp_g_score
    73     36.2 MiB   -685.6 MiB         673                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     36.2 MiB   -685.7 MiB         673                   if neighbor not in open_set_hash:
    75     36.2 MiB   -682.3 MiB         668                       count += 1
    76     36.2 MiB   -682.3 MiB         668                       open_set.put((f_score[neighbor], count, neighbor))
    77     36.2 MiB   -682.3 MiB         668                       open_set_hash.add(neighbor)
    78                                                             
    79     36.2 MiB   -521.9 MiB         471           if draw is not None:
    80                                                     draw()
    81                                         
    82     36.2 MiB   -519.2 MiB         471           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     87.1 MiB     87.1 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     87.1 MiB   -586.2 MiB         257       for row in grid:
    30     87.1 MiB -149851.3 MiB       65792           for spot in row:
    31     87.1 MiB -149266.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     81.7 MiB     -5.4 MiB           1       count = 0
    34     81.9 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     82.1 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     82.1 MiB      0.0 MiB           1       came_from = {}
    37     82.9 MiB -1821131.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     40.7 MiB    -42.2 MiB           1       g_score[start] = 0
    39     47.0 MiB  -1372.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     47.2 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     47.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     47.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     47.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     48.2 MiB    -62.8 MiB         347       while not open_set.empty():
    47     48.2 MiB    -62.8 MiB         347           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     48.2 MiB    -62.7 MiB         347           current = open_set.get()[2]
    53     48.2 MiB    -62.8 MiB         347           open_set_hash.remove(current)
    54                                         
    55     48.2 MiB    -62.8 MiB         347           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     48.2 MiB    -62.8 MiB         347           if current == end:
    60     48.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     48.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     48.2 MiB   -450.8 MiB        2529           for neighbor in current.neighbors:
    65     48.2 MiB   -387.7 MiB        2183               if current.row != neighbor.row and current.col != neighbor.col:
    66     48.2 MiB   -191.5 MiB        1073                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     48.2 MiB   -197.0 MiB        1110                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     48.2 MiB   -388.4 MiB        2183               if temp_g_score < g_score[neighbor]:
    71     48.2 MiB    -83.6 MiB         492                   came_from[neighbor] = current
    72     48.2 MiB    -83.7 MiB         492                   g_score[neighbor] = temp_g_score
    73     48.2 MiB    -83.7 MiB         492                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     48.2 MiB    -83.7 MiB         492                   if neighbor not in open_set_hash:
    75     48.2 MiB    -82.3 MiB         486                       count += 1
    76     48.2 MiB    -82.2 MiB         486                       open_set.put((f_score[neighbor], count, neighbor))
    77     48.2 MiB    -82.2 MiB         486                       open_set_hash.add(neighbor)
    78                                                             
    79     48.2 MiB    -62.8 MiB         346           if draw is not None:
    80                                                     draw()
    81                                         
    82     48.2 MiB    -62.8 MiB         346           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     95.2 MiB     95.2 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.2 MiB   -896.3 MiB         257       for row in grid:
    30     95.2 MiB -229487.3 MiB       65792           for spot in row:
    31     95.2 MiB -228594.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     89.3 MiB     -5.9 MiB           1       count = 0
    34     89.5 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     89.7 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     89.7 MiB      0.0 MiB           1       came_from = {}
    37     92.7 MiB -1225384.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     31.1 MiB    -61.6 MiB           1       g_score[start] = 0
    39     41.8 MiB   -130.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     42.0 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     42.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     42.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     42.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     60.3 MiB   -117.2 MiB        2605       while not open_set.empty():
    47     60.3 MiB   -117.2 MiB        2605           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     60.3 MiB   -117.2 MiB        2605           current = open_set.get()[2]
    53     60.3 MiB   -117.3 MiB        2605           open_set_hash.remove(current)
    54                                         
    55     60.3 MiB   -114.3 MiB        2605           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     60.3 MiB   -114.3 MiB        2605           if current == end:
    60     60.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     60.5 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     60.3 MiB   -858.6 MiB       19655           for neighbor in current.neighbors:
    65     60.3 MiB   -742.3 MiB       17051               if current.row != neighbor.row and current.col != neighbor.col:
    66     60.3 MiB   -365.6 MiB        8376                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     60.3 MiB   -380.9 MiB        8675                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     60.3 MiB   -746.7 MiB       17051               if temp_g_score < g_score[neighbor]:
    71     60.3 MiB   -143.0 MiB        3366                   came_from[neighbor] = current
    72     60.3 MiB   -143.3 MiB        3366                   g_score[neighbor] = temp_g_score
    73     60.3 MiB   -143.3 MiB        3366                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     60.3 MiB   -143.3 MiB        3366                   if neighbor not in open_set_hash:
    75     60.3 MiB   -140.1 MiB        3303                       count += 1
    76     60.3 MiB   -129.2 MiB        3303                       open_set.put((f_score[neighbor], count, neighbor))
    77     60.3 MiB   -140.1 MiB        3303                       open_set_hash.add(neighbor)
    78                                                             
    79     60.3 MiB   -117.1 MiB        2604           if draw is not None:
    80                                                     draw()
    81                                         
    82     60.3 MiB   -117.2 MiB        2604           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.0 MiB     92.0 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.0 MiB  -3667.7 MiB         257       for row in grid:
    30     92.0 MiB -931117.0 MiB       65792           for spot in row:
    31     92.0 MiB -927510.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     22.6 MiB    -69.4 MiB           1       count = 0
    34     22.9 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     23.1 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     23.1 MiB      0.0 MiB           1       came_from = {}
    37     39.0 MiB  -3845.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     39.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     45.8 MiB    -16.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     46.0 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     46.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     46.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     46.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     46.3 MiB      0.0 MiB          74       while not open_set.empty():
    47     46.3 MiB      0.0 MiB          74           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     46.3 MiB      0.0 MiB          74           current = open_set.get()[2]
    53     46.3 MiB      0.0 MiB          74           open_set_hash.remove(current)
    54                                         
    55     46.3 MiB      0.0 MiB          74           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     46.3 MiB      0.0 MiB          74           if current == end:
    60     46.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     46.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     46.3 MiB      0.0 MiB         548           for neighbor in current.neighbors:
    65     46.3 MiB      0.0 MiB         475               if current.row != neighbor.row and current.col != neighbor.col:
    66     46.3 MiB      0.0 MiB         233                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     46.3 MiB      0.0 MiB         242                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     46.3 MiB      0.0 MiB         475               if temp_g_score < g_score[neighbor]:
    71     46.3 MiB      0.1 MiB         126                   came_from[neighbor] = current
    72     46.3 MiB      0.0 MiB         126                   g_score[neighbor] = temp_g_score
    73     46.3 MiB      0.0 MiB         126                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     46.3 MiB      0.0 MiB         126                   if neighbor not in open_set_hash:
    75     46.3 MiB      0.0 MiB         123                       count += 1
    76     46.3 MiB      0.0 MiB         123                       open_set.put((f_score[neighbor], count, neighbor))
    77     46.3 MiB      0.1 MiB         123                       open_set_hash.add(neighbor)
    78                                                             
    79     46.3 MiB      0.0 MiB          73           if draw is not None:
    80                                                     draw()
    81                                         
    82     46.3 MiB      0.0 MiB          73           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.0 MiB     93.0 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.0 MiB  -3475.6 MiB         257       for row in grid:
    30     93.0 MiB -890554.9 MiB       65792           for spot in row:
    31     93.0 MiB -887092.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     73.0 MiB    -20.0 MiB           1       count = 0
    34     73.3 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     73.5 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     73.5 MiB      0.0 MiB           1       came_from = {}
    37     74.3 MiB -1791144.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     49.3 MiB    -25.0 MiB           1       g_score[start] = 0
    39     54.4 MiB -33036.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     54.6 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     54.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     54.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     54.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     55.1 MiB      0.1 MiB         308       while not open_set.empty():
    47     55.1 MiB      0.0 MiB         308           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     55.1 MiB      0.0 MiB         308           current = open_set.get()[2]
    53     55.1 MiB      0.0 MiB         308           open_set_hash.remove(current)
    54                                         
    55     55.1 MiB      0.0 MiB         308           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     55.1 MiB      0.0 MiB         308           if current == end:
    60     55.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     55.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     55.1 MiB      0.0 MiB        2363           for neighbor in current.neighbors:
    65     55.1 MiB      0.1 MiB        2056               if current.row != neighbor.row and current.col != neighbor.col:
    66     55.1 MiB      0.0 MiB        1015                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     55.1 MiB      0.0 MiB        1041                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     55.1 MiB      0.0 MiB        2056               if temp_g_score < g_score[neighbor]:
    71     55.1 MiB      0.1 MiB         456                   came_from[neighbor] = current
    72     55.1 MiB      0.0 MiB         456                   g_score[neighbor] = temp_g_score
    73     55.1 MiB      0.0 MiB         456                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     55.1 MiB      0.0 MiB         456                   if neighbor not in open_set_hash:
    75     55.1 MiB      0.0 MiB         428                       count += 1
    76     55.1 MiB      0.1 MiB         428                       open_set.put((f_score[neighbor], count, neighbor))
    77     55.1 MiB      0.1 MiB         428                       open_set_hash.add(neighbor)
    78                                                             
    79     55.1 MiB      0.0 MiB         307           if draw is not None:
    80                                                     draw()
    81                                         
    82     55.1 MiB      0.0 MiB         307           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.1 MiB     93.1 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.1 MiB  -1008.1 MiB         257       for row in grid:
    30     93.1 MiB -257978.0 MiB       65792           for spot in row:
    31     93.1 MiB -256976.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     79.4 MiB    -13.6 MiB           1       count = 0
    34     79.8 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     80.0 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     80.0 MiB      0.0 MiB           1       came_from = {}
    37     80.3 MiB -593453.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     71.7 MiB     -8.7 MiB           1       g_score[start] = 0
    39     75.0 MiB -21674.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     74.6 MiB     -0.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     74.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     74.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     74.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.9 MiB -61520.4 MiB        2227       while not open_set.empty():
    47     75.9 MiB -61522.3 MiB        2227           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.9 MiB -61523.7 MiB        2227           current = open_set.get()[2]
    53     75.9 MiB -61524.4 MiB        2227           open_set_hash.remove(current)
    54                                         
    55     75.9 MiB -61525.3 MiB        2227           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.9 MiB -61525.7 MiB        2227           if current == end:
    60     45.2 MiB    -30.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     45.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.9 MiB -442464.3 MiB       16010           for neighbor in current.neighbors:
    65     75.9 MiB -380947.4 MiB       13784               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.9 MiB -185983.8 MiB        6733                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.9 MiB -194970.3 MiB        7051                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.9 MiB -380958.3 MiB       13784               if temp_g_score < g_score[neighbor]:
    71     75.9 MiB -84515.7 MiB        3083                   came_from[neighbor] = current
    72     75.9 MiB -84518.4 MiB        3083                   g_score[neighbor] = temp_g_score
    73     75.9 MiB -84519.3 MiB        3083                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.9 MiB -84520.6 MiB        3083                   if neighbor not in open_set_hash:
    75     75.9 MiB -70207.0 MiB        2607                       count += 1
    76     75.9 MiB -70208.4 MiB        2607                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.9 MiB -70209.2 MiB        2607                       open_set_hash.add(neighbor)
    78                                                             
    79     75.9 MiB -61519.0 MiB        2226           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.9 MiB -61519.6 MiB        2226           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     89.2 MiB     89.2 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     89.2 MiB  -4793.0 MiB         257       for row in grid:
    30     89.2 MiB -1223777.6 MiB       65792           for spot in row:
    31     89.2 MiB -1219017.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     22.7 MiB    -66.5 MiB           1       count = 0
    34     23.1 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     23.3 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     23.3 MiB      0.0 MiB           1       came_from = {}
    37     39.0 MiB   -510.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     39.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     42.7 MiB -35347.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     42.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     42.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     42.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     42.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     45.2 MiB  -1288.5 MiB        1134       while not open_set.empty():
    47     45.2 MiB  -1288.8 MiB        1134           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     45.2 MiB  -1289.9 MiB        1134           current = open_set.get()[2]
    53     45.2 MiB  -1289.9 MiB        1134           open_set_hash.remove(current)
    54                                         
    55     45.2 MiB  -1289.9 MiB        1134           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     45.2 MiB  -1289.9 MiB        1134           if current == end:
    60     44.0 MiB     -1.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     44.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     45.2 MiB  -9434.2 MiB        8373           for neighbor in current.neighbors:
    65     45.2 MiB  -8144.9 MiB        7240               if current.row != neighbor.row and current.col != neighbor.col:
    66     45.2 MiB  -3987.8 MiB        3548                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     45.2 MiB  -4158.6 MiB        3692                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     45.2 MiB  -8146.5 MiB        7240               if temp_g_score < g_score[neighbor]:
    71     45.2 MiB  -1780.2 MiB        1640                   came_from[neighbor] = current
    72     45.2 MiB  -1780.3 MiB        1640                   g_score[neighbor] = temp_g_score
    73     45.2 MiB  -1780.7 MiB        1640                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     45.2 MiB  -1780.7 MiB        1640                   if neighbor not in open_set_hash:
    75     45.2 MiB  -1465.3 MiB        1380                       count += 1
    76     45.2 MiB  -1465.3 MiB        1380                       open_set.put((f_score[neighbor], count, neighbor))
    77     45.2 MiB  -1465.3 MiB        1380                       open_set_hash.add(neighbor)
    78                                                             
    79     45.2 MiB  -1288.5 MiB        1133           if draw is not None:
    80                                                     draw()
    81                                         
    82     45.2 MiB  -1288.5 MiB        1133           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     90.2 MiB     90.2 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     90.2 MiB -14437.6 MiB         257       for row in grid:
    30     90.2 MiB -3697186.4 MiB       65792           for spot in row:
    31     90.2 MiB -3682762.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     27.5 MiB    -62.7 MiB           1       count = 0
    34     27.9 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     28.1 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     28.1 MiB      0.0 MiB           1       came_from = {}
    37     42.9 MiB -170312.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     30.5 MiB    -12.5 MiB           1       g_score[start] = 0
    39     31.0 MiB -199403.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     26.7 MiB     -4.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     26.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     26.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     26.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     54.4 MiB  -1232.8 MiB        2379       while not open_set.empty():
    47     54.4 MiB  -1233.0 MiB        2379           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     54.4 MiB  -1234.7 MiB        2379           current = open_set.get()[2]
    53     54.4 MiB  -1235.0 MiB        2379           open_set_hash.remove(current)
    54                                         
    55     54.4 MiB  -1235.0 MiB        2379           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     54.4 MiB  -1235.0 MiB        2379           if current == end:
    60     54.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     54.5 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     54.4 MiB  -9234.8 MiB       17795           for neighbor in current.neighbors:
    65     54.4 MiB  -8000.4 MiB       15417               if current.row != neighbor.row and current.col != neighbor.col:
    66     54.4 MiB  -3930.1 MiB        7577                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     54.4 MiB  -4073.2 MiB        7840                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     54.4 MiB  -7999.3 MiB       15417               if temp_g_score < g_score[neighbor]:
    71     54.4 MiB  -1602.9 MiB        3179                   came_from[neighbor] = current
    72     54.4 MiB  -1603.5 MiB        3179                   g_score[neighbor] = temp_g_score
    73     54.4 MiB  -1603.1 MiB        3179                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     54.4 MiB  -1604.7 MiB        3179                   if neighbor not in open_set_hash:
    75     54.4 MiB  -1488.0 MiB        2992                       count += 1
    76     54.4 MiB  -1469.1 MiB        2992                       open_set.put((f_score[neighbor], count, neighbor))
    77     54.4 MiB  -1488.5 MiB        2992                       open_set_hash.add(neighbor)
    78                                                             
    79     54.4 MiB  -1233.3 MiB        2378           if draw is not None:
    80                                                     draw()
    81                                         
    82     54.4 MiB  -1232.9 MiB        2378           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     85.4 MiB     85.4 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     85.4 MiB   -874.2 MiB         257       for row in grid:
    30     85.4 MiB -223254.4 MiB       65792           for spot in row:
    31     85.4 MiB -222385.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     78.0 MiB     -7.4 MiB           1       count = 0
    34     78.2 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     78.4 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     78.4 MiB      0.0 MiB           1       came_from = {}
    37     82.0 MiB -22422.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     82.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     86.7 MiB -46526.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     69.1 MiB    -17.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     69.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     69.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     69.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     71.4 MiB -64002.1 MiB        3096       while not open_set.empty():
    47     71.4 MiB -64002.8 MiB        3096           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     71.4 MiB -64004.1 MiB        3096           current = open_set.get()[2]
    53     71.4 MiB -64004.7 MiB        3096           open_set_hash.remove(current)
    54                                         
    55     71.4 MiB -64005.7 MiB        3096           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     71.4 MiB -64006.4 MiB        3096           if current == end:
    60     57.0 MiB    -14.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     57.1 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     71.4 MiB -473026.5 MiB       23018           for neighbor in current.neighbors:
    65     71.4 MiB -409026.7 MiB       19923               if current.row != neighbor.row and current.col != neighbor.col:
    66     71.4 MiB -200092.6 MiB        9759                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     71.4 MiB -208942.5 MiB       10164                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     71.4 MiB -409038.2 MiB       19923               if temp_g_score < g_score[neighbor]:
    71     71.4 MiB -89078.8 MiB        4272                   came_from[neighbor] = current
    72     71.4 MiB -89079.4 MiB        4272                   g_score[neighbor] = temp_g_score
    73     71.4 MiB -89080.8 MiB        4272                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     71.4 MiB -89081.0 MiB        4272                   if neighbor not in open_set_hash:
    75     71.4 MiB -77808.3 MiB        3779                       count += 1
    76     71.4 MiB -77793.2 MiB        3779                       open_set.put((f_score[neighbor], count, neighbor))
    77     71.4 MiB -77796.0 MiB        3779                       open_set_hash.add(neighbor)
    78                                                             
    79     71.4 MiB -64002.0 MiB        3095           if draw is not None:
    80                                                     draw()
    81                                         
    82     71.4 MiB -64002.0 MiB        3095           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     90.7 MiB     90.7 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     90.7 MiB   -502.3 MiB         257       for row in grid:
    30     90.7 MiB -128367.3 MiB       65792           for spot in row:
    31     90.7 MiB -127868.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     86.9 MiB     -3.8 MiB           1       count = 0
    34     86.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     86.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     86.9 MiB      0.0 MiB           1       came_from = {}
    37     93.0 MiB   -354.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     93.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     99.5 MiB    -87.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.6 MiB  -1162.9 MiB         962       while not open_set.empty():
    47     99.6 MiB  -1163.2 MiB         962           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.6 MiB  -1163.2 MiB         962           current = open_set.get()[2]
    53     99.6 MiB  -1163.2 MiB         962           open_set_hash.remove(current)
    54                                         
    55     99.6 MiB  -1163.2 MiB         962           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.6 MiB  -1163.2 MiB         962           if current == end:
    60     94.7 MiB     -4.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     94.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.6 MiB  -8740.0 MiB        7051           for neighbor in current.neighbors:
    65     99.6 MiB  -7579.1 MiB        6090               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.6 MiB  -3711.6 MiB        2979                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.6 MiB  -3868.1 MiB        3111                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.6 MiB  -7579.7 MiB        6090               if temp_g_score < g_score[neighbor]:
    71     99.6 MiB  -1739.7 MiB        1375                   came_from[neighbor] = current
    72     99.6 MiB  -1740.1 MiB        1375                   g_score[neighbor] = temp_g_score
    73     99.6 MiB  -1740.3 MiB        1375                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.6 MiB  -1740.6 MiB        1375                   if neighbor not in open_set_hash:
    75     99.6 MiB  -1686.5 MiB        1281                       count += 1
    76     99.6 MiB  -1686.8 MiB        1281                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.6 MiB  -1687.3 MiB        1281                       open_set_hash.add(neighbor)
    78                                                             
    79     99.6 MiB  -1161.7 MiB         961           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.6 MiB  -1162.2 MiB         961           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.8 MiB     98.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.8 MiB  -8646.5 MiB         257       for row in grid:
    30     98.8 MiB -2216529.7 MiB       65792           for spot in row:
    31     98.8 MiB -2207903.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     48.8 MiB    -50.1 MiB           1       count = 0
    34     49.0 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     49.3 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     49.3 MiB      0.0 MiB           1       came_from = {}
    37     53.6 MiB -438831.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     39.4 MiB    -14.2 MiB           1       g_score[start] = 0
    39     43.7 MiB -18166.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     44.0 MiB      0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     44.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     44.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     44.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     55.4 MiB  -3968.0 MiB        4989       while not open_set.empty():
    47     55.4 MiB  -3968.0 MiB        4989           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     55.4 MiB  -3968.0 MiB        4989           current = open_set.get()[2]
    53     55.4 MiB  -3968.1 MiB        4989           open_set_hash.remove(current)
    54                                         
    55     55.4 MiB  -3968.1 MiB        4989           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     55.4 MiB  -3968.2 MiB        4989           if current == end:
    60     55.3 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     55.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     55.4 MiB -29479.6 MiB       36436           for neighbor in current.neighbors:
    65     55.4 MiB -25510.7 MiB       31448               if current.row != neighbor.row and current.col != neighbor.col:
    66     55.4 MiB -12530.9 MiB       15366                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     55.4 MiB -12982.2 MiB       16082                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     55.4 MiB -25514.2 MiB       31448               if temp_g_score < g_score[neighbor]:
    71     55.4 MiB  -5537.5 MiB        6877                   came_from[neighbor] = current
    72     55.4 MiB  -5537.7 MiB        6877                   g_score[neighbor] = temp_g_score
    73     55.4 MiB  -5537.7 MiB        6877                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     55.4 MiB  -5537.7 MiB        6877                   if neighbor not in open_set_hash:
    75     55.4 MiB  -4439.3 MiB        5585                       count += 1
    76     55.4 MiB  -4426.8 MiB        5585                       open_set.put((f_score[neighbor], count, neighbor))
    77     55.4 MiB  -4436.0 MiB        5585                       open_set_hash.add(neighbor)
    78                                                             
    79     55.4 MiB  -3968.0 MiB        4988           if draw is not None:
    80                                                     draw()
    81                                         
    82     55.4 MiB  -3968.0 MiB        4988           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     90.8 MiB     90.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     90.8 MiB  -3883.0 MiB         257       for row in grid:
    30     90.8 MiB -987522.6 MiB       65792           for spot in row:
    31     90.8 MiB -983688.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     23.1 MiB    -67.7 MiB           1       count = 0
    34     23.4 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     23.6 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     23.6 MiB      0.0 MiB           1       came_from = {}
    37     40.8 MiB   -550.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     40.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     46.4 MiB   -129.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     46.5 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     46.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     46.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     46.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     48.1 MiB      0.0 MiB         287       while not open_set.empty():
    47     48.1 MiB     -0.0 MiB         287           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     48.1 MiB      0.0 MiB         287           current = open_set.get()[2]
    53     48.1 MiB     -0.0 MiB         287           open_set_hash.remove(current)
    54                                         
    55     48.1 MiB     -0.0 MiB         287           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     48.1 MiB     -0.0 MiB         287           if current == end:
    60     48.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     48.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     48.1 MiB      0.5 MiB        2136           for neighbor in current.neighbors:
    65     48.1 MiB      0.6 MiB        1850               if current.row != neighbor.row and current.col != neighbor.col:
    66     48.1 MiB      0.0 MiB         911                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     48.1 MiB      0.0 MiB         939                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     48.1 MiB      0.0 MiB        1850               if temp_g_score < g_score[neighbor]:
    71     48.1 MiB      0.1 MiB         538                   came_from[neighbor] = current
    72     48.1 MiB     -0.0 MiB         538                   g_score[neighbor] = temp_g_score
    73     48.1 MiB     -0.0 MiB         538                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     48.1 MiB     -0.0 MiB         538                   if neighbor not in open_set_hash:
    75     48.1 MiB     -0.0 MiB         485                       count += 1
    76     48.1 MiB      0.1 MiB         485                       open_set.put((f_score[neighbor], count, neighbor))
    77     48.1 MiB     -0.0 MiB         485                       open_set_hash.add(neighbor)
    78                                                             
    79     48.1 MiB     -0.0 MiB         286           if draw is not None:
    80                                                     draw()
    81                                         
    82     48.1 MiB     -0.0 MiB         286           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.8 MiB     92.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.8 MiB  -3731.2 MiB         257       for row in grid:
    30     92.8 MiB -954992.3 MiB       65792           for spot in row:
    31     92.8 MiB -951275.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     71.5 MiB    -21.3 MiB           1       count = 0
    34     71.8 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     72.0 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     72.0 MiB      0.0 MiB           1       came_from = {}
    37     79.8 MiB  -1067.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     79.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     80.5 MiB -1127613.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     44.4 MiB    -36.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     44.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     44.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     44.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     46.9 MiB  -2294.5 MiB        1202       while not open_set.empty():
    47     46.9 MiB  -2294.7 MiB        1202           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     46.9 MiB  -2294.8 MiB        1202           current = open_set.get()[2]
    53     46.9 MiB  -2294.9 MiB        1202           open_set_hash.remove(current)
    54                                         
    55     46.9 MiB  -2294.9 MiB        1202           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     46.9 MiB  -2294.9 MiB        1202           if current == end:
    60     43.3 MiB     -3.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     43.4 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     46.9 MiB -16537.6 MiB        8741           for neighbor in current.neighbors:
    65     46.9 MiB -14242.5 MiB        7540               if current.row != neighbor.row and current.col != neighbor.col:
    66     46.9 MiB  -6924.6 MiB        3683                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     46.9 MiB  -7319.7 MiB        3857                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     46.9 MiB -14244.8 MiB        7540               if temp_g_score < g_score[neighbor]:
    71     46.9 MiB  -3534.4 MiB        1795                   came_from[neighbor] = current
    72     46.9 MiB  -3534.5 MiB        1795                   g_score[neighbor] = temp_g_score
    73     46.9 MiB  -3534.5 MiB        1795                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     46.9 MiB  -3536.0 MiB        1795                   if neighbor not in open_set_hash:
    75     46.9 MiB  -2887.5 MiB        1598                       count += 1
    76     46.9 MiB  -2887.8 MiB        1598                       open_set.put((f_score[neighbor], count, neighbor))
    77     46.9 MiB  -2887.8 MiB        1598                       open_set_hash.add(neighbor)
    78                                                             
    79     46.9 MiB  -2294.3 MiB        1201           if draw is not None:
    80                                                     draw()
    81                                         
    82     46.9 MiB  -2294.5 MiB        1201           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


