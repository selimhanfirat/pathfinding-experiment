Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.1 MiB     67.1 MiB           1   @profile(stream=open('logs/A*/obstacle_density/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     68.2 MiB   -854.7 MiB         257       for row in grid:
    30     68.2 MiB -220114.7 MiB       65792           for spot in row:
    31     68.2 MiB -219261.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     64.5 MiB     -3.7 MiB           1       count = 0
    34     64.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     64.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     64.5 MiB      0.0 MiB           1       came_from = {}
    37     71.4 MiB      6.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     71.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     76.8 MiB -21055.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     76.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     76.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     76.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     76.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     76.9 MiB      0.0 MiB         603       while not open_set.empty():
    47     76.9 MiB      0.0 MiB         603           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     76.9 MiB      0.0 MiB         603           current = open_set.get()[2]
    53     76.9 MiB      0.0 MiB         603           open_set_hash.remove(current)
    54                                         
    55     76.9 MiB      0.0 MiB         603           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     76.9 MiB      0.0 MiB         603           if current == end:
    60     76.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     76.9 MiB      0.0 MiB        4889           for neighbor in current.neighbors:
    65     76.9 MiB      0.0 MiB        4287               if current.row != neighbor.row and current.col != neighbor.col:
    66     76.9 MiB      0.0 MiB        2128                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     76.9 MiB      0.0 MiB        2159                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     76.9 MiB      0.0 MiB        4287               if temp_g_score < g_score[neighbor]:
    71     76.9 MiB      0.0 MiB         816                   came_from[neighbor] = current
    72     76.9 MiB      0.0 MiB         816                   g_score[neighbor] = temp_g_score
    73     76.9 MiB      0.0 MiB         816                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     76.9 MiB      0.0 MiB         816                   if neighbor not in open_set_hash:
    75     76.9 MiB      0.0 MiB         803                       count += 1
    76     76.9 MiB      0.0 MiB         803                       open_set.put((f_score[neighbor], count, neighbor))
    77     76.9 MiB      0.0 MiB         803                       open_set_hash.add(neighbor)
    78                                                             
    79     76.9 MiB      0.0 MiB         602           if draw is not None:
    80                                                     draw()
    81                                         
    82     76.9 MiB      0.0 MiB         602           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.0 MiB     97.0 MiB           1   @profile(stream=open('logs/A*/obstacle_density/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.0 MiB  -2057.5 MiB         257       for row in grid:
    30     97.0 MiB -527869.7 MiB       65792           for spot in row:
    31     97.0 MiB -525818.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     84.3 MiB    -12.7 MiB           1       count = 0
    34     84.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     84.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     84.3 MiB      0.0 MiB           1       came_from = {}
    37     91.4 MiB   -306.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     91.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     97.0 MiB  -6068.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     97.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     97.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     97.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     97.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     97.5 MiB   -361.1 MiB         188       while not open_set.empty():
    47     97.5 MiB   -361.3 MiB         188           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     97.5 MiB   -361.5 MiB         188           current = open_set.get()[2]
    53     97.5 MiB   -361.6 MiB         188           open_set_hash.remove(current)
    54                                         
    55     97.5 MiB   -361.6 MiB         188           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     97.5 MiB   -361.6 MiB         188           if current == end:
    60     92.2 MiB     -5.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     92.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     97.5 MiB  -2875.0 MiB        1508           for neighbor in current.neighbors:
    65     97.5 MiB  -2518.0 MiB        1321               if current.row != neighbor.row and current.col != neighbor.col:
    66     97.5 MiB  -1275.3 MiB         661                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     97.5 MiB  -1243.1 MiB         660                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     97.5 MiB  -2518.6 MiB        1321               if temp_g_score < g_score[neighbor]:
    71     97.5 MiB   -530.6 MiB         311                   came_from[neighbor] = current
    72     97.5 MiB   -530.6 MiB         311                   g_score[neighbor] = temp_g_score
    73     97.5 MiB   -530.6 MiB         311                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     97.5 MiB   -530.7 MiB         311                   if neighbor not in open_set_hash:
    75     97.5 MiB   -503.8 MiB         294                       count += 1
    76     97.5 MiB   -504.1 MiB         294                       open_set.put((f_score[neighbor], count, neighbor))
    77     97.5 MiB   -504.1 MiB         294                       open_set_hash.add(neighbor)
    78                                                             
    79     97.5 MiB   -357.8 MiB         187           if draw is not None:
    80                                                     draw()
    81                                         
    82     97.5 MiB   -357.8 MiB         187           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.7 MiB    100.7 MiB           1   @profile(stream=open('logs/A*/obstacle_density/20.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.7 MiB  -1407.6 MiB         257       for row in grid:
    30    100.7 MiB -359889.2 MiB       65792           for spot in row:
    31    100.7 MiB -358490.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     88.0 MiB    -12.7 MiB           1       count = 0
    34     88.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     88.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     88.0 MiB      0.0 MiB           1       came_from = {}
    37     93.4 MiB  -6547.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     93.1 MiB     -0.3 MiB           1       g_score[start] = 0
    39     95.8 MiB -152621.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     89.4 MiB     -6.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     89.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     89.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     89.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     89.5 MiB -37116.3 MiB        4290       while not open_set.empty():
    47     89.5 MiB -37116.5 MiB        4290           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     89.5 MiB -37116.9 MiB        4290           current = open_set.get()[2]
    53     89.5 MiB -37117.1 MiB        4290           open_set_hash.remove(current)
    54                                         
    55     89.5 MiB -37117.2 MiB        4290           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     89.5 MiB -37117.2 MiB        4290           if current == end:
    60     77.7 MiB    -11.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     77.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     89.5 MiB -303141.3 MiB       34975           for neighbor in current.neighbors:
    65     89.5 MiB -266026.1 MiB       30686               if current.row != neighbor.row and current.col != neighbor.col:
    66     89.5 MiB -132391.0 MiB       15269                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     89.5 MiB -133636.0 MiB       15417                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     89.5 MiB -266029.1 MiB       30686               if temp_g_score < g_score[neighbor]:
    71     89.5 MiB -41327.9 MiB        4853                   came_from[neighbor] = current
    72     89.5 MiB -41327.9 MiB        4853                   g_score[neighbor] = temp_g_score
    73     89.5 MiB -41328.1 MiB        4853                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     89.5 MiB -41328.1 MiB        4853                   if neighbor not in open_set_hash:
    75     89.5 MiB -40868.9 MiB        4800                       count += 1
    76     89.5 MiB -40870.3 MiB        4800                       open_set.put((f_score[neighbor], count, neighbor))
    77     89.5 MiB -40870.3 MiB        4800                       open_set_hash.add(neighbor)
    78                                                             
    79     89.5 MiB -37116.3 MiB        4289           if draw is not None:
    80                                                     draw()
    81                                         
    82     89.5 MiB -37116.3 MiB        4289           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.1 MiB    103.1 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.1 MiB  -2545.7 MiB         257       for row in grid:
    30    103.1 MiB -649853.8 MiB       65792           for spot in row:
    31    103.1 MiB -647322.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     80.3 MiB    -22.7 MiB           1       count = 0
    34     80.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     80.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     80.4 MiB      0.0 MiB           1       came_from = {}
    37     85.2 MiB -19252.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     85.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     90.5 MiB      5.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     90.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     90.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     90.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     90.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     90.7 MiB    -35.7 MiB         753       while not open_set.empty():
    47     90.7 MiB    -35.7 MiB         753           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     90.7 MiB    -35.7 MiB         753           current = open_set.get()[2]
    53     90.7 MiB    -35.7 MiB         753           open_set_hash.remove(current)
    54                                         
    55     90.7 MiB    -35.7 MiB         753           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     90.7 MiB    -35.7 MiB         753           if current == end:
    60     90.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     90.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     90.7 MiB   -285.3 MiB        6080           for neighbor in current.neighbors:
    65     90.7 MiB   -249.7 MiB        5328               if current.row != neighbor.row and current.col != neighbor.col:
    66     90.7 MiB   -124.1 MiB        2650                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     90.7 MiB   -125.6 MiB        2678                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     90.7 MiB   -249.7 MiB        5328               if temp_g_score < g_score[neighbor]:
    71     90.7 MiB    -43.3 MiB         970                   came_from[neighbor] = current
    72     90.7 MiB    -43.3 MiB         970                   g_score[neighbor] = temp_g_score
    73     90.7 MiB    -43.3 MiB         970                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     90.7 MiB    -43.3 MiB         970                   if neighbor not in open_set_hash:
    75     90.7 MiB    -43.0 MiB         965                       count += 1
    76     90.7 MiB    -42.9 MiB         965                       open_set.put((f_score[neighbor], count, neighbor))
    77     90.7 MiB    -42.9 MiB         965                       open_set_hash.add(neighbor)
    78                                                             
    79     90.7 MiB    -35.6 MiB         752           if draw is not None:
    80                                                     draw()
    81                                         
    82     90.7 MiB    -35.7 MiB         752           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.8 MiB    108.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.8 MiB  -1093.1 MiB         257       for row in grid:
    30    108.8 MiB -277772.7 MiB       65792           for spot in row:
    31    108.8 MiB -276698.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     85.8 MiB    -23.0 MiB           1       count = 0
    34     85.9 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     85.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     85.9 MiB      0.0 MiB           1       came_from = {}
    37     92.2 MiB      6.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     92.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     96.1 MiB -248826.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     81.0 MiB    -15.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     81.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     81.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     81.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     81.8 MiB      0.0 MiB        1167       while not open_set.empty():
    47     81.8 MiB      0.0 MiB        1167           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     81.8 MiB      0.0 MiB        1167           current = open_set.get()[2]
    53     81.8 MiB      0.0 MiB        1167           open_set_hash.remove(current)
    54                                         
    55     81.8 MiB      0.0 MiB        1167           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     81.8 MiB      0.0 MiB        1167           if current == end:
    60     81.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     81.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     81.8 MiB      0.2 MiB        9558           for neighbor in current.neighbors:
    65     81.8 MiB      0.4 MiB        8392               if current.row != neighbor.row and current.col != neighbor.col:
    66     81.8 MiB      0.0 MiB        4191                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     81.8 MiB      0.0 MiB        4201                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     81.8 MiB      0.0 MiB        8392               if temp_g_score < g_score[neighbor]:
    71     81.8 MiB      0.1 MiB        1774                   came_from[neighbor] = current
    72     81.8 MiB      0.0 MiB        1774                   g_score[neighbor] = temp_g_score
    73     81.8 MiB      0.0 MiB        1774                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     81.8 MiB      0.0 MiB        1774                   if neighbor not in open_set_hash:
    75     81.8 MiB      0.0 MiB        1517                       count += 1
    76     81.8 MiB      0.0 MiB        1517                       open_set.put((f_score[neighbor], count, neighbor))
    77     81.8 MiB      0.0 MiB        1517                       open_set_hash.add(neighbor)
    78                                                             
    79     81.8 MiB      0.0 MiB        1166           if draw is not None:
    80                                                     draw()
    81                                         
    82     81.8 MiB      0.0 MiB        1166           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.0 MiB    107.0 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.0 MiB   -753.1 MiB         257       for row in grid:
    30    107.0 MiB -192191.6 MiB       65792           for spot in row:
    31    107.0 MiB -191443.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.6 MiB     -7.4 MiB           1       count = 0
    34     99.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.6 MiB      0.0 MiB           1       came_from = {}
    37    102.2 MiB -39187.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     98.4 MiB     -3.8 MiB           1       g_score[start] = 0
    39    100.7 MiB -548647.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     87.3 MiB    -13.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     87.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     87.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     87.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     87.6 MiB      0.0 MiB        1356       while not open_set.empty():
    47     87.6 MiB      0.0 MiB        1356           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     87.6 MiB      0.0 MiB        1356           current = open_set.get()[2]
    53     87.6 MiB      0.0 MiB        1356           open_set_hash.remove(current)
    54                                         
    55     87.6 MiB      0.0 MiB        1356           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     87.6 MiB      0.0 MiB        1356           if current == end:
    60     87.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     87.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     87.6 MiB      0.0 MiB       11234           for neighbor in current.neighbors:
    65     87.6 MiB      0.0 MiB        9879               if current.row != neighbor.row and current.col != neighbor.col:
    66     87.6 MiB      0.0 MiB        4917                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     87.6 MiB      0.0 MiB        4962                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     87.6 MiB      0.0 MiB        9879               if temp_g_score < g_score[neighbor]:
    71     87.6 MiB      0.2 MiB        1870                   came_from[neighbor] = current
    72     87.6 MiB      0.0 MiB        1870                   g_score[neighbor] = temp_g_score
    73     87.6 MiB      0.0 MiB        1870                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     87.6 MiB      0.0 MiB        1870                   if neighbor not in open_set_hash:
    75     87.6 MiB      0.0 MiB        1804                       count += 1
    76     87.6 MiB      0.0 MiB        1804                       open_set.put((f_score[neighbor], count, neighbor))
    77     87.6 MiB      0.1 MiB        1804                       open_set_hash.add(neighbor)
    78                                                             
    79     87.6 MiB      0.0 MiB        1355           if draw is not None:
    80                                                     draw()
    81                                         
    82     87.6 MiB      0.0 MiB        1355           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.2 MiB    105.2 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.2 MiB  -1907.1 MiB         257       for row in grid:
    30    105.2 MiB -485607.1 MiB       65792           for spot in row:
    31    105.2 MiB -483720.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     77.3 MiB    -27.8 MiB           1       count = 0
    34     77.7 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     77.9 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     77.9 MiB      0.0 MiB           1       came_from = {}
    37     81.6 MiB -428409.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     75.1 MiB     -6.6 MiB           1       g_score[start] = 0
    39     78.6 MiB -19487.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     78.8 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     78.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     78.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     78.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     79.1 MiB   -358.3 MiB        1278       while not open_set.empty():
    47     79.1 MiB   -358.5 MiB        1278           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     79.1 MiB   -358.5 MiB        1278           current = open_set.get()[2]
    53     79.1 MiB   -358.5 MiB        1278           open_set_hash.remove(current)
    54                                         
    55     79.1 MiB   -358.5 MiB        1278           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     79.1 MiB   -358.5 MiB        1278           if current == end:
    60     76.9 MiB     -2.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     79.1 MiB  -2952.5 MiB       10567           for neighbor in current.neighbors:
    65     79.1 MiB  -2594.5 MiB        9290               if current.row != neighbor.row and current.col != neighbor.col:
    66     79.1 MiB  -1292.5 MiB        4619                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     79.1 MiB  -1302.2 MiB        4671                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     79.1 MiB  -2594.7 MiB        9290               if temp_g_score < g_score[neighbor]:
    71     79.1 MiB   -469.2 MiB        1604                   came_from[neighbor] = current
    72     79.1 MiB   -469.3 MiB        1604                   g_score[neighbor] = temp_g_score
    73     79.1 MiB   -470.8 MiB        1604                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     79.1 MiB   -470.8 MiB        1604                   if neighbor not in open_set_hash:
    75     79.1 MiB   -469.4 MiB        1592                       count += 1
    76     79.1 MiB   -469.3 MiB        1592                       open_set.put((f_score[neighbor], count, neighbor))
    77     79.1 MiB   -469.2 MiB        1592                       open_set_hash.add(neighbor)
    78                                                             
    79     79.1 MiB   -358.3 MiB        1277           if draw is not None:
    80                                                     draw()
    81                                         
    82     79.1 MiB   -358.3 MiB        1277           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.2 MiB    107.2 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.2 MiB     -7.4 MiB         257       for row in grid:
    30    107.2 MiB  -1893.4 MiB       65792           for spot in row:
    31    107.2 MiB  -1886.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.1 MiB     -0.0 MiB           1       count = 0
    34    107.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.1 MiB      0.0 MiB           1       came_from = {}
    37    107.5 MiB -312075.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.6 MiB     -3.9 MiB           1       g_score[start] = 0
    39    106.1 MiB -24871.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.2 MiB    -26.5 MiB        1598       while not open_set.empty():
    47    106.2 MiB    -26.5 MiB        1598           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.2 MiB    -26.5 MiB        1598           current = open_set.get()[2]
    53    106.2 MiB    -26.5 MiB        1598           open_set_hash.remove(current)
    54                                         
    55    106.2 MiB    -26.5 MiB        1598           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.2 MiB    -26.5 MiB        1598           if current == end:
    60    106.2 MiB     -0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.2 MiB   -216.5 MiB       13202           for neighbor in current.neighbors:
    65    106.2 MiB   -190.1 MiB       11605               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.2 MiB    -94.5 MiB        5774                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.2 MiB    -95.6 MiB        5831                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.2 MiB   -190.2 MiB       11605               if temp_g_score < g_score[neighbor]:
    71    106.2 MiB    -30.7 MiB        1910                   came_from[neighbor] = current
    72    106.2 MiB    -30.7 MiB        1910                   g_score[neighbor] = temp_g_score
    73    106.2 MiB    -30.7 MiB        1910                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.2 MiB    -30.7 MiB        1910                   if neighbor not in open_set_hash:
    75    106.2 MiB    -30.3 MiB        1888                       count += 1
    76    106.2 MiB    -30.3 MiB        1888                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.2 MiB    -30.2 MiB        1888                       open_set_hash.add(neighbor)
    78                                                             
    79    106.2 MiB    -26.5 MiB        1597           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.2 MiB    -26.5 MiB        1597           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.8 MiB    106.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.8 MiB   -433.7 MiB         257       for row in grid:
    30    106.8 MiB -110852.0 MiB       65792           for spot in row:
    31    106.8 MiB -110419.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.7 MiB     -4.0 MiB           1       count = 0
    34    102.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.7 MiB      0.0 MiB           1       came_from = {}
    37    104.6 MiB -106146.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.9 MiB     -7.7 MiB           1       g_score[start] = 0
    39    100.1 MiB -130672.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     95.1 MiB     -5.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     95.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     95.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     95.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     95.8 MiB   -275.6 MiB        1310       while not open_set.empty():
    47     95.8 MiB   -275.8 MiB        1310           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     95.8 MiB   -275.6 MiB        1310           current = open_set.get()[2]
    53     95.8 MiB   -275.8 MiB        1310           open_set_hash.remove(current)
    54                                         
    55     95.8 MiB   -275.8 MiB        1310           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     95.8 MiB   -275.8 MiB        1310           if current == end:
    60     95.4 MiB     -0.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     95.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     95.8 MiB  -2294.0 MiB       10818           for neighbor in current.neighbors:
    65     95.8 MiB  -2018.4 MiB        9509               if current.row != neighbor.row and current.col != neighbor.col:
    66     95.8 MiB  -1004.5 MiB        4731                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     95.8 MiB  -1014.0 MiB        4778                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     95.8 MiB  -2018.8 MiB        9509               if temp_g_score < g_score[neighbor]:
    71     95.8 MiB   -333.6 MiB        1617                   came_from[neighbor] = current
    72     95.8 MiB   -333.6 MiB        1617                   g_score[neighbor] = temp_g_score
    73     95.8 MiB   -333.6 MiB        1617                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     95.8 MiB   -333.7 MiB        1617                   if neighbor not in open_set_hash:
    75     95.8 MiB   -330.5 MiB        1603                       count += 1
    76     95.8 MiB   -330.5 MiB        1603                       open_set.put((f_score[neighbor], count, neighbor))
    77     95.8 MiB   -330.5 MiB        1603                       open_set_hash.add(neighbor)
    78                                                             
    79     95.8 MiB   -275.8 MiB        1309           if draw is not None:
    80                                                     draw()
    81                                         
    82     95.8 MiB   -275.8 MiB        1309           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.1 MiB    106.1 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.1 MiB   -748.1 MiB         257       for row in grid:
    30    106.1 MiB -191009.1 MiB       65792           for spot in row:
    31    106.1 MiB -190269.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.9 MiB    -10.2 MiB           1       count = 0
    34     95.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.0 MiB      0.0 MiB           1       came_from = {}
    37    100.1 MiB  -1407.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    103.3 MiB  -8450.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.9 MiB     -0.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.0 MiB -86785.7 MiB        3804       while not open_set.empty():
    47    103.0 MiB -86786.2 MiB        3804           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.0 MiB -86790.7 MiB        3804           current = open_set.get()[2]
    53    103.0 MiB -86792.5 MiB        3804           open_set_hash.remove(current)
    54                                         
    55    103.0 MiB -86795.6 MiB        3804           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.0 MiB -86795.9 MiB        3804           if current == end:
    60     43.8 MiB    -59.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     43.8 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.0 MiB -704629.2 MiB       31110           for neighbor in current.neighbors:
    65    103.0 MiB -617857.2 MiB       27307               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.0 MiB -306650.0 MiB       13553                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.0 MiB -311215.3 MiB       13754                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.0 MiB -617869.8 MiB       27307               if temp_g_score < g_score[neighbor]:
    71    103.0 MiB -154809.5 MiB        6456                   came_from[neighbor] = current
    72    103.0 MiB -154810.7 MiB        6456                   g_score[neighbor] = temp_g_score
    73    103.0 MiB -154812.8 MiB        6456                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.0 MiB -154823.1 MiB        6456                   if neighbor not in open_set_hash:
    75    103.0 MiB -99197.4 MiB        4740                       count += 1
    76    103.0 MiB -99198.5 MiB        4740                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.0 MiB -99199.2 MiB        4740                       open_set_hash.add(neighbor)
    78                                                             
    79    103.0 MiB -86783.3 MiB        3803           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.0 MiB -86784.5 MiB        3803           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.8 MiB     92.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.8 MiB   -117.2 MiB         257       for row in grid:
    30     92.8 MiB -30048.7 MiB       65792           for spot in row:
    31     92.8 MiB -29932.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     91.9 MiB     -1.0 MiB           1       count = 0
    34     92.0 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     92.1 MiB      0.1 MiB           1       open_set.put((0, count, start))
    36     92.1 MiB      0.0 MiB           1       came_from = {}
    37     97.1 MiB   -250.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.4 MiB  -3204.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.5 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.6 MiB      0.0 MiB         374       while not open_set.empty():
    47    101.6 MiB      0.0 MiB         374           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.6 MiB      0.0 MiB         374           current = open_set.get()[2]
    53    101.6 MiB      0.0 MiB         374           open_set_hash.remove(current)
    54                                         
    55    101.6 MiB      0.0 MiB         374           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.6 MiB      0.0 MiB         374           if current == end:
    60    101.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.6 MiB      0.0 MiB        3033           for neighbor in current.neighbors:
    65    101.6 MiB      0.0 MiB        2660               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.6 MiB      0.0 MiB        1326                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.6 MiB      0.0 MiB        1334                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.6 MiB      0.0 MiB        2660               if temp_g_score < g_score[neighbor]:
    71    101.6 MiB      0.0 MiB         817                   came_from[neighbor] = current
    72    101.6 MiB      0.0 MiB         817                   g_score[neighbor] = temp_g_score
    73    101.6 MiB      0.0 MiB         817                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.6 MiB      0.0 MiB         817                   if neighbor not in open_set_hash:
    75    101.6 MiB      0.0 MiB         747                       count += 1
    76    101.6 MiB      0.0 MiB         747                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.6 MiB      0.0 MiB         747                       open_set_hash.add(neighbor)
    78                                                             
    79    101.6 MiB      0.0 MiB         373           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.6 MiB      0.0 MiB         373           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.5 MiB    102.5 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.5 MiB      0.0 MiB         257       for row in grid:
    30    102.5 MiB      0.0 MiB       65792           for spot in row:
    31    102.5 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.5 MiB      0.0 MiB           1       count = 0
    34    102.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.5 MiB      0.0 MiB           1       came_from = {}
    37    106.0 MiB      3.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    106.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    108.5 MiB  -9073.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.8 MiB     -0.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.9 MiB      0.0 MiB         540       while not open_set.empty():
    47    107.9 MiB      0.0 MiB         540           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.9 MiB      0.0 MiB         540           current = open_set.get()[2]
    53    107.9 MiB      0.0 MiB         540           open_set_hash.remove(current)
    54                                         
    55    107.9 MiB      0.0 MiB         540           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.9 MiB      0.0 MiB         540           if current == end:
    60    107.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.9 MiB      0.0 MiB        4384           for neighbor in current.neighbors:
    65    107.9 MiB      0.0 MiB        3845               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.9 MiB      0.0 MiB        1921                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.9 MiB      0.0 MiB        1924                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.9 MiB      0.0 MiB        3845               if temp_g_score < g_score[neighbor]:
    71    107.9 MiB      0.0 MiB         738                   came_from[neighbor] = current
    72    107.9 MiB      0.0 MiB         738                   g_score[neighbor] = temp_g_score
    73    107.9 MiB      0.0 MiB         738                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.9 MiB      0.0 MiB         738                   if neighbor not in open_set_hash:
    75    107.9 MiB      0.0 MiB         733                       count += 1
    76    107.9 MiB      0.0 MiB         733                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.9 MiB      0.0 MiB         733                       open_set_hash.add(neighbor)
    78                                                             
    79    107.9 MiB      0.0 MiB         539           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.9 MiB      0.0 MiB         539           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.9 MiB    105.9 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.9 MiB   -433.2 MiB         257       for row in grid:
    30    105.9 MiB -110569.1 MiB       65792           for spot in row:
    31    105.9 MiB -110139.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.4 MiB     -4.5 MiB           1       count = 0
    34    101.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.4 MiB      0.0 MiB           1       came_from = {}
    37    105.0 MiB      3.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.8 MiB   -273.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.8 MiB      0.0 MiB         162       while not open_set.empty():
    47    109.8 MiB      0.0 MiB         162           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.8 MiB      0.0 MiB         162           current = open_set.get()[2]
    53    109.8 MiB      0.0 MiB         162           open_set_hash.remove(current)
    54                                         
    55    109.8 MiB      0.0 MiB         162           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.8 MiB      0.0 MiB         162           if current == end:
    60    109.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    109.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.8 MiB      0.0 MiB        1301           for neighbor in current.neighbors:
    65    109.8 MiB      0.0 MiB        1140               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.8 MiB      0.0 MiB         567                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.8 MiB      0.0 MiB         573                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.8 MiB      0.0 MiB        1140               if temp_g_score < g_score[neighbor]:
    71    109.8 MiB      0.0 MiB         300                   came_from[neighbor] = current
    72    109.8 MiB      0.0 MiB         300                   g_score[neighbor] = temp_g_score
    73    109.8 MiB      0.0 MiB         300                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.8 MiB      0.0 MiB         300                   if neighbor not in open_set_hash:
    75    109.8 MiB      0.0 MiB         288                       count += 1
    76    109.8 MiB      0.0 MiB         288                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.8 MiB      0.0 MiB         288                       open_set_hash.add(neighbor)
    78                                                             
    79    109.8 MiB      0.0 MiB         161           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.8 MiB      0.0 MiB         161           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    110.1 MiB    110.1 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    110.1 MiB   -311.6 MiB         257       for row in grid:
    30    110.1 MiB -79732.0 MiB       65792           for spot in row:
    31    110.1 MiB -79423.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.0 MiB     -3.2 MiB           1       count = 0
    34    107.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.0 MiB      0.0 MiB           1       came_from = {}
    37    111.1 MiB      4.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    111.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    112.9 MiB   -699.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.9 MiB  -1425.8 MiB        1833       while not open_set.empty():
    47    112.9 MiB  -1425.8 MiB        1833           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.9 MiB  -1426.1 MiB        1833           current = open_set.get()[2]
    53    112.9 MiB  -1426.3 MiB        1833           open_set_hash.remove(current)
    54                                         
    55    112.9 MiB  -1426.6 MiB        1833           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.9 MiB  -1426.9 MiB        1833           if current == end:
    60    111.6 MiB     -1.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    111.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.9 MiB -11876.4 MiB       15257           for neighbor in current.neighbors:
    65    112.9 MiB -10450.6 MiB       13425               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.9 MiB  -5207.6 MiB        6684                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.9 MiB  -5243.0 MiB        6741                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.9 MiB -10450.6 MiB       13425               if temp_g_score < g_score[neighbor]:
    71    112.9 MiB  -1775.1 MiB        2261                   came_from[neighbor] = current
    72    112.9 MiB  -1775.1 MiB        2261                   g_score[neighbor] = temp_g_score
    73    112.9 MiB  -1775.2 MiB        2261                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.9 MiB  -1775.2 MiB        2261                   if neighbor not in open_set_hash:
    75    112.9 MiB  -1756.6 MiB        2237                       count += 1
    76    112.9 MiB  -1756.8 MiB        2237                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.9 MiB  -1756.7 MiB        2237                       open_set_hash.add(neighbor)
    78                                                             
    79    112.9 MiB  -1425.8 MiB        1832           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.9 MiB  -1425.8 MiB        1832           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.0 MiB    112.0 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.0 MiB   -236.7 MiB         257       for row in grid:
    30    112.0 MiB -59908.7 MiB       65792           for spot in row:
    31    112.0 MiB -59675.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.8 MiB     -4.2 MiB           1       count = 0
    34    107.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.8 MiB      0.0 MiB           1       came_from = {}
    37    109.7 MiB -61722.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    108.7 MiB     -1.0 MiB           1       g_score[start] = 0
    39    112.7 MiB      4.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    112.7 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    112.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    112.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    112.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    112.8 MiB  -1393.7 MiB         801       while not open_set.empty():
    47    112.8 MiB  -1393.9 MiB         801           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    112.8 MiB  -1393.9 MiB         801           current = open_set.get()[2]
    53    112.8 MiB  -1394.4 MiB         801           open_set_hash.remove(current)
    54                                         
    55    112.8 MiB  -1394.5 MiB         801           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    112.8 MiB  -1394.5 MiB         801           if current == end:
    60    106.7 MiB     -6.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    112.8 MiB -11334.9 MiB        6593           for neighbor in current.neighbors:
    65    112.8 MiB  -9942.8 MiB        5793               if current.row != neighbor.row and current.col != neighbor.col:
    66    112.8 MiB  -4952.2 MiB        2881                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    112.8 MiB  -4993.3 MiB        2912                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    112.8 MiB  -9945.9 MiB        5793               if temp_g_score < g_score[neighbor]:
    71    112.8 MiB  -1777.6 MiB        1016                   came_from[neighbor] = current
    72    112.8 MiB  -1777.6 MiB        1016                   g_score[neighbor] = temp_g_score
    73    112.8 MiB  -1777.6 MiB        1016                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    112.8 MiB  -1777.6 MiB        1016                   if neighbor not in open_set_hash:
    75    112.8 MiB  -1765.5 MiB        1006                       count += 1
    76    112.8 MiB  -1765.7 MiB        1006                       open_set.put((f_score[neighbor], count, neighbor))
    77    112.8 MiB  -1765.7 MiB        1006                       open_set_hash.add(neighbor)
    78                                                             
    79    112.8 MiB  -1393.7 MiB         800           if draw is not None:
    80                                                     draw()
    81                                         
    82    112.8 MiB  -1393.7 MiB         800           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.8 MiB    111.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.8 MiB  -1015.7 MiB         257       for row in grid:
    30    111.8 MiB -260283.5 MiB       65792           for spot in row:
    31    111.8 MiB -259271.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.4 MiB     -6.4 MiB           1       count = 0
    34    105.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.4 MiB      0.0 MiB           1       came_from = {}
    37    107.8 MiB -443798.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     84.6 MiB    -23.2 MiB           1       g_score[start] = 0
    39     88.5 MiB     -9.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     88.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     88.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     88.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     88.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     88.6 MiB  -2166.5 MiB        2869       while not open_set.empty():
    47     88.6 MiB  -2166.5 MiB        2869           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     88.6 MiB  -2166.7 MiB        2869           current = open_set.get()[2]
    53     88.6 MiB  -2166.7 MiB        2869           open_set_hash.remove(current)
    54                                         
    55     88.6 MiB  -2166.7 MiB        2869           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     88.6 MiB  -2166.7 MiB        2869           if current == end:
    60     86.8 MiB     -1.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     86.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     88.6 MiB -17675.1 MiB       23483           for neighbor in current.neighbors:
    65     88.6 MiB -15509.0 MiB       20615               if current.row != neighbor.row and current.col != neighbor.col:
    66     88.6 MiB  -7701.8 MiB       10240                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     88.6 MiB  -7808.2 MiB       10375                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     88.6 MiB -15510.1 MiB       20615               if temp_g_score < g_score[neighbor]:
    71     88.6 MiB  -2465.4 MiB        3333                   came_from[neighbor] = current
    72     88.6 MiB  -2465.5 MiB        3333                   g_score[neighbor] = temp_g_score
    73     88.6 MiB  -2465.5 MiB        3333                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     88.6 MiB  -2465.5 MiB        3333                   if neighbor not in open_set_hash:
    75     88.6 MiB  -2431.3 MiB        3294                       count += 1
    76     88.6 MiB  -2431.4 MiB        3294                       open_set.put((f_score[neighbor], count, neighbor))
    77     88.6 MiB  -2431.4 MiB        3294                       open_set_hash.add(neighbor)
    78                                                             
    79     88.6 MiB  -2166.1 MiB        2868           if draw is not None:
    80                                                     draw()
    81                                         
    82     88.6 MiB  -2166.1 MiB        2868           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.0 MiB    102.0 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.0 MiB   -853.9 MiB         257       for row in grid:
    30    102.0 MiB -219136.4 MiB       65792           for spot in row:
    31    102.0 MiB -218286.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.1 MiB     -3.9 MiB           1       count = 0
    34     98.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.1 MiB      0.0 MiB           1       came_from = {}
    37    103.1 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    103.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.6 MiB  -1644.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.6 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.6 MiB   -128.7 MiB        1292       while not open_set.empty():
    47    106.6 MiB   -128.8 MiB        1292           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.6 MiB   -128.8 MiB        1292           current = open_set.get()[2]
    53    106.6 MiB   -128.8 MiB        1292           open_set_hash.remove(current)
    54                                         
    55    106.6 MiB   -128.8 MiB        1292           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.6 MiB   -128.8 MiB        1292           if current == end:
    60    106.6 MiB     -0.1 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.6 MiB  -1048.2 MiB       10502           for neighbor in current.neighbors:
    65    106.6 MiB   -919.6 MiB        9211               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.6 MiB   -454.3 MiB        4572                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.6 MiB   -465.4 MiB        4639                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.6 MiB   -919.7 MiB        9211               if temp_g_score < g_score[neighbor]:
    71    106.6 MiB   -264.8 MiB        2267                   came_from[neighbor] = current
    72    106.6 MiB   -264.8 MiB        2267                   g_score[neighbor] = temp_g_score
    73    106.6 MiB   -264.8 MiB        2267                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.6 MiB   -264.8 MiB        2267                   if neighbor not in open_set_hash:
    75    106.6 MiB   -205.3 MiB        1987                       count += 1
    76    106.6 MiB   -205.2 MiB        1987                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.6 MiB   -205.2 MiB        1987                       open_set_hash.add(neighbor)
    78                                                             
    79    106.6 MiB   -128.7 MiB        1291           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.6 MiB   -128.7 MiB        1291           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.9 MiB    106.9 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.9 MiB   -830.7 MiB         257       for row in grid:
    30    106.9 MiB -212731.9 MiB       65792           for spot in row:
    31    106.9 MiB -211906.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.7 MiB     -7.1 MiB           1       count = 0
    34     99.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.7 MiB      0.0 MiB           1       came_from = {}
    37    102.6 MiB -10512.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.1 MiB     -0.5 MiB           1       g_score[start] = 0
    39    105.8 MiB  -8679.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    105.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    105.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    105.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    105.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    105.9 MiB -53662.3 MiB        4638       while not open_set.empty():
    47    105.9 MiB -53662.5 MiB        4638           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    105.9 MiB -53664.0 MiB        4638           current = open_set.get()[2]
    53    105.9 MiB -53664.3 MiB        4638           open_set_hash.remove(current)
    54                                         
    55    105.9 MiB -53664.5 MiB        4638           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    105.9 MiB -53665.0 MiB        4638           if current == end:
    60     88.6 MiB    -17.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     88.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    105.9 MiB -440725.8 MiB       38124           for neighbor in current.neighbors:
    65    105.9 MiB -387066.9 MiB       33487               if current.row != neighbor.row and current.col != neighbor.col:
    66    105.9 MiB -192623.8 MiB       16662                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    105.9 MiB -194445.5 MiB       16825                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    105.9 MiB -387072.6 MiB       33487               if temp_g_score < g_score[neighbor]:
    71    105.9 MiB -59853.7 MiB        5261                   came_from[neighbor] = current
    72    105.9 MiB -59854.4 MiB        5261                   g_score[neighbor] = temp_g_score
    73    105.9 MiB -59855.4 MiB        5261                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    105.9 MiB -59856.1 MiB        5261                   if neighbor not in open_set_hash:
    75    105.9 MiB -59201.8 MiB        5206                       count += 1
    76    105.9 MiB -59202.9 MiB        5206                       open_set.put((f_score[neighbor], count, neighbor))
    77    105.9 MiB -59203.2 MiB        5206                       open_set_hash.add(neighbor)
    78                                                             
    79    105.9 MiB -53661.8 MiB        4637           if draw is not None:
    80                                                     draw()
    81                                         
    82    105.9 MiB -53662.0 MiB        4637           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.2 MiB    100.2 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.2 MiB   -100.0 MiB         257       for row in grid:
    30    100.2 MiB -25232.2 MiB       65792           for spot in row:
    31    100.2 MiB -25134.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.4 MiB     -2.9 MiB           1       count = 0
    34     97.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.4 MiB      0.0 MiB           1       came_from = {}
    37     98.8 MiB -20040.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     98.8 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.5 MiB -44754.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     97.8 MiB     -3.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     97.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     97.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     97.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.6 MiB   -649.5 MiB        1202       while not open_set.empty():
    47     98.6 MiB   -649.6 MiB        1202           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.6 MiB   -649.6 MiB        1202           current = open_set.get()[2]
    53     98.6 MiB   -649.6 MiB        1202           open_set_hash.remove(current)
    54                                         
    55     98.6 MiB   -649.6 MiB        1202           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.6 MiB   -650.6 MiB        1202           if current == end:
    60     98.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.6 MiB  -5363.9 MiB        9946           for neighbor in current.neighbors:
    65     98.6 MiB  -4713.4 MiB        8745               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.6 MiB  -2335.1 MiB        4344                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.6 MiB  -2379.2 MiB        4401                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.6 MiB  -4714.8 MiB        8745               if temp_g_score < g_score[neighbor]:
    71     98.6 MiB  -1458.5 MiB        2454                   came_from[neighbor] = current
    72     98.6 MiB  -1458.5 MiB        2454                   g_score[neighbor] = temp_g_score
    73     98.6 MiB  -1458.6 MiB        2454                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.6 MiB  -1458.6 MiB        2454                   if neighbor not in open_set_hash:
    75     98.6 MiB  -1173.8 MiB        1863                       count += 1
    76     98.6 MiB  -1171.8 MiB        1863                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.6 MiB  -1172.5 MiB        1863                       open_set_hash.add(neighbor)
    78                                                             
    79     98.6 MiB   -649.5 MiB        1201           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.6 MiB   -649.5 MiB        1201           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.1 MiB    102.1 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.1 MiB   -462.7 MiB         257       for row in grid:
    30    102.1 MiB -117881.1 MiB       65792           for spot in row:
    31    102.1 MiB -117429.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     89.0 MiB    -13.1 MiB           1       count = 0
    34     89.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     89.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     89.0 MiB      0.0 MiB           1       came_from = {}
    37     95.7 MiB      6.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    100.3 MiB      4.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    100.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    100.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    100.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    100.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.1 MiB  -3456.5 MiB        1569       while not open_set.empty():
    47    101.1 MiB  -3461.3 MiB        1569           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.1 MiB  -3462.0 MiB        1569           current = open_set.get()[2]
    53    101.1 MiB  -3462.5 MiB        1569           open_set_hash.remove(current)
    54                                         
    55    101.1 MiB  -3463.0 MiB        1569           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.1 MiB  -3463.6 MiB        1569           if current == end:
    60     76.3 MiB    -24.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     76.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.1 MiB -29137.0 MiB       12812           for neighbor in current.neighbors:
    65    101.1 MiB -25684.2 MiB       11244               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.1 MiB -12839.0 MiB        5587                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.1 MiB -12848.5 MiB        5657                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.1 MiB -25689.8 MiB       11244               if temp_g_score < g_score[neighbor]:
    71    101.1 MiB  -4313.6 MiB        1956                   came_from[neighbor] = current
    72    101.1 MiB  -4314.1 MiB        1956                   g_score[neighbor] = temp_g_score
    73    101.1 MiB  -4314.8 MiB        1956                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.1 MiB  -4315.2 MiB        1956                   if neighbor not in open_set_hash:
    75    101.1 MiB  -4297.0 MiB        1933                       count += 1
    76    101.1 MiB  -4297.9 MiB        1933                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.1 MiB  -4298.5 MiB        1933                       open_set_hash.add(neighbor)
    78                                                             
    79    101.1 MiB  -3455.5 MiB        1568           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.1 MiB  -3456.0 MiB        1568           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.9 MiB    104.9 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.9 MiB   -898.2 MiB         257       for row in grid:
    30    104.9 MiB -230055.5 MiB       65792           for spot in row:
    31    104.9 MiB -229158.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.3 MiB     -4.6 MiB           1       count = 0
    34    100.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.3 MiB      0.0 MiB           1       came_from = {}
    37    105.4 MiB      5.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    111.1 MiB      5.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    111.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    111.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    111.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    111.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    111.3 MiB   -383.6 MiB        2522       while not open_set.empty():
    47    111.3 MiB   -383.7 MiB        2522           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    111.3 MiB   -383.7 MiB        2522           current = open_set.get()[2]
    53    111.3 MiB   -383.7 MiB        2522           open_set_hash.remove(current)
    54                                         
    55    111.3 MiB   -383.7 MiB        2522           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    111.3 MiB   -383.7 MiB        2522           if current == end:
    60    107.0 MiB     -4.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    111.3 MiB  -2996.0 MiB       20702           for neighbor in current.neighbors:
    65    111.3 MiB  -2614.0 MiB       18181               if current.row != neighbor.row and current.col != neighbor.col:
    66    111.3 MiB  -1295.2 MiB        9039                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    111.3 MiB  -1318.8 MiB        9142                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    111.3 MiB  -2616.3 MiB       18181               if temp_g_score < g_score[neighbor]:
    71    111.3 MiB   -482.8 MiB        3063                   came_from[neighbor] = current
    72    111.3 MiB   -483.0 MiB        3063                   g_score[neighbor] = temp_g_score
    73    111.3 MiB   -483.0 MiB        3063                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    111.3 MiB   -483.0 MiB        3063                   if neighbor not in open_set_hash:
    75    111.3 MiB   -478.6 MiB        3022                       count += 1
    76    111.3 MiB   -478.6 MiB        3022                       open_set.put((f_score[neighbor], count, neighbor))
    77    111.3 MiB   -478.5 MiB        3022                       open_set_hash.add(neighbor)
    78                                                             
    79    111.3 MiB   -382.0 MiB        2521           if draw is not None:
    80                                                     draw()
    81                                         
    82    111.3 MiB   -382.0 MiB        2521           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    112.4 MiB    112.4 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    112.4 MiB  -1333.4 MiB         257       for row in grid:
    30    112.4 MiB -341537.2 MiB       65792           for spot in row:
    31    112.4 MiB -340209.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    105.2 MiB     -7.2 MiB           1       count = 0
    34    105.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    105.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    105.2 MiB      0.0 MiB           1       came_from = {}
    37    109.2 MiB -27141.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.9 MiB     -3.2 MiB           1       g_score[start] = 0
    39    106.2 MiB -1131169.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     74.6 MiB    -31.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     74.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     74.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     74.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     75.8 MiB    -18.5 MiB         269       while not open_set.empty():
    47     75.8 MiB    -18.6 MiB         269           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     75.8 MiB    -18.5 MiB         269           current = open_set.get()[2]
    53     75.8 MiB    -18.6 MiB         269           open_set_hash.remove(current)
    54                                         
    55     75.8 MiB    -18.6 MiB         269           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     75.8 MiB    -18.6 MiB         269           if current == end:
    60     75.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     75.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     75.8 MiB   -177.0 MiB        2194           for neighbor in current.neighbors:
    65     75.8 MiB   -157.6 MiB        1926               if current.row != neighbor.row and current.col != neighbor.col:
    66     75.8 MiB    -79.5 MiB         953                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     75.8 MiB    -78.9 MiB         973                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     75.8 MiB   -158.3 MiB        1926               if temp_g_score < g_score[neighbor]:
    71     75.8 MiB    -31.4 MiB         435                   came_from[neighbor] = current
    72     75.8 MiB    -31.6 MiB         435                   g_score[neighbor] = temp_g_score
    73     75.8 MiB    -31.6 MiB         435                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     75.8 MiB    -31.6 MiB         435                   if neighbor not in open_set_hash:
    75     75.8 MiB    -31.6 MiB         421                       count += 1
    76     75.8 MiB    -31.6 MiB         421                       open_set.put((f_score[neighbor], count, neighbor))
    77     75.8 MiB    -31.6 MiB         421                       open_set_hash.add(neighbor)
    78                                                             
    79     75.8 MiB    -21.2 MiB         268           if draw is not None:
    80                                                     draw()
    81                                         
    82     75.8 MiB    -18.6 MiB         268           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.5 MiB    107.5 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.5 MiB  -5300.0 MiB         257       for row in grid:
    30    107.5 MiB -1358493.0 MiB       65792           for spot in row:
    31    107.5 MiB -1353195.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     80.8 MiB    -26.6 MiB           1       count = 0
    34     81.0 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     81.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     81.0 MiB      0.0 MiB           1       came_from = {}
    37     88.2 MiB -10489.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     88.2 MiB      0.0 MiB           1       g_score[start] = 0
    39     94.5 MiB      6.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     94.5 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     94.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     94.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     94.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     94.6 MiB  -4695.3 MiB        2285       while not open_set.empty():
    47     94.6 MiB  -4695.3 MiB        2285           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     94.6 MiB  -4695.3 MiB        2285           current = open_set.get()[2]
    53     94.6 MiB  -4695.3 MiB        2285           open_set_hash.remove(current)
    54                                         
    55     94.6 MiB  -4695.3 MiB        2285           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     94.6 MiB  -4695.3 MiB        2285           if current == end:
    60     88.4 MiB     -6.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     88.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     94.6 MiB -38546.0 MiB       18658           for neighbor in current.neighbors:
    65     94.6 MiB -33851.7 MiB       16374               if current.row != neighbor.row and current.col != neighbor.col:
    66     94.6 MiB -16827.4 MiB        8134                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     94.6 MiB -17026.4 MiB        8240                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     94.6 MiB -33855.1 MiB       16374               if temp_g_score < g_score[neighbor]:
    71     94.6 MiB  -5242.8 MiB        2613                   came_from[neighbor] = current
    72     94.6 MiB  -5242.8 MiB        2613                   g_score[neighbor] = temp_g_score
    73     94.6 MiB  -5242.8 MiB        2613                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     94.6 MiB  -5242.8 MiB        2613                   if neighbor not in open_set_hash:
    75     94.6 MiB  -5196.5 MiB        2586                       count += 1
    76     94.6 MiB  -5196.5 MiB        2586                       open_set.put((f_score[neighbor], count, neighbor))
    77     94.6 MiB  -5196.5 MiB        2586                       open_set_hash.add(neighbor)
    78                                                             
    79     94.6 MiB  -4695.3 MiB        2284           if draw is not None:
    80                                                     draw()
    81                                         
    82     94.6 MiB  -4695.3 MiB        2284           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.4 MiB    105.4 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.4 MiB   -830.0 MiB         257       for row in grid:
    30    105.4 MiB -212739.0 MiB       65792           for spot in row:
    31    105.4 MiB -211911.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.8 MiB     -5.7 MiB           1       count = 0
    34     99.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.8 MiB      0.0 MiB           1       came_from = {}
    37    101.0 MiB -53249.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.6 MiB     -0.4 MiB           1       g_score[start] = 0
    39    101.7 MiB -537436.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     87.2 MiB    -14.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     87.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     87.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     87.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     87.9 MiB   -203.3 MiB         707       while not open_set.empty():
    47     87.9 MiB   -203.3 MiB         707           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     87.9 MiB   -203.3 MiB         707           current = open_set.get()[2]
    53     87.9 MiB   -203.3 MiB         707           open_set_hash.remove(current)
    54                                         
    55     87.9 MiB   -203.3 MiB         707           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     87.9 MiB   -203.3 MiB         707           if current == end:
    60     87.3 MiB     -0.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     87.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     87.9 MiB  -1660.4 MiB        5825           for neighbor in current.neighbors:
    65     87.9 MiB  -1457.0 MiB        5119               if current.row != neighbor.row and current.col != neighbor.col:
    66     87.9 MiB   -726.1 MiB        2546                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     87.9 MiB   -731.1 MiB        2573                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     87.9 MiB  -1457.2 MiB        5119               if temp_g_score < g_score[neighbor]:
    71     87.9 MiB   -350.4 MiB        1193                   came_from[neighbor] = current
    72     87.9 MiB   -350.4 MiB        1193                   g_score[neighbor] = temp_g_score
    73     87.9 MiB   -350.8 MiB        1193                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     87.9 MiB   -350.8 MiB        1193                   if neighbor not in open_set_hash:
    75     87.9 MiB   -307.5 MiB        1053                       count += 1
    76     87.9 MiB   -307.3 MiB        1053                       open_set.put((f_score[neighbor], count, neighbor))
    77     87.9 MiB   -307.4 MiB        1053                       open_set_hash.add(neighbor)
    78                                                             
    79     87.9 MiB   -203.3 MiB         706           if draw is not None:
    80                                                     draw()
    81                                         
    82     87.9 MiB   -203.3 MiB         706           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.4 MiB    100.4 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.4 MiB   -957.0 MiB         257       for row in grid:
    30    100.4 MiB -245475.3 MiB       65792           for spot in row:
    31    100.4 MiB -244519.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.0 MiB     -4.3 MiB           1       count = 0
    34     96.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.0 MiB      0.0 MiB           1       came_from = {}
    37    101.7 MiB -16985.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    100.8 MiB     -1.0 MiB           1       g_score[start] = 0
    39    103.2 MiB -312035.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     90.4 MiB    -12.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     90.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     90.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     90.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     91.4 MiB -100359.4 MiB        2505       while not open_set.empty():
    47     91.4 MiB -100361.8 MiB        2505           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     91.4 MiB -100362.2 MiB        2505           current = open_set.get()[2]
    53     91.4 MiB -100362.8 MiB        2505           open_set_hash.remove(current)
    54                                         
    55     91.4 MiB -100363.9 MiB        2505           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     91.4 MiB -100364.6 MiB        2505           if current == end:
    60     42.0 MiB    -49.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     42.1 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     91.5 MiB -822156.3 MiB       20618           for neighbor in current.neighbors:
    65     91.5 MiB -721800.9 MiB       18114               if current.row != neighbor.row and current.col != neighbor.col:
    66     91.5 MiB -359187.4 MiB        9017                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     91.5 MiB -362616.3 MiB        9097                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     91.5 MiB -721808.0 MiB       18114               if temp_g_score < g_score[neighbor]:
    71     91.5 MiB -117044.6 MiB        2967                   came_from[neighbor] = current
    72     91.5 MiB -117049.7 MiB        2967                   g_score[neighbor] = temp_g_score
    73     91.5 MiB -117071.1 MiB        2967                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     91.5 MiB -117072.2 MiB        2967                   if neighbor not in open_set_hash:
    75     91.5 MiB -115704.8 MiB        2935                       count += 1
    76     91.5 MiB -115705.4 MiB        2935                       open_set.put((f_score[neighbor], count, neighbor))
    77     91.5 MiB -115706.1 MiB        2935                       open_set_hash.add(neighbor)
    78                                                             
    79     91.4 MiB -100393.4 MiB        2504           if draw is not None:
    80                                                     draw()
    81                                         
    82     91.4 MiB -100358.6 MiB        2504           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.8 MiB    101.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.8 MiB  -1245.0 MiB         257       for row in grid:
    30    101.8 MiB -318694.5 MiB       65792           for spot in row:
    31    101.8 MiB -317458.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     87.6 MiB    -14.1 MiB           1       count = 0
    34     87.8 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     88.0 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     88.0 MiB      0.0 MiB           1       came_from = {}
    37     93.3 MiB  -4468.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     93.1 MiB     -0.2 MiB           1       g_score[start] = 0
    39     98.8 MiB  -4542.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     99.0 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     99.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     99.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     99.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     99.4 MiB -152569.6 MiB        5002       while not open_set.empty():
    47     99.4 MiB -152569.9 MiB        5002           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     99.4 MiB -152570.0 MiB        5002           current = open_set.get()[2]
    53     99.4 MiB -152570.1 MiB        5002           open_set_hash.remove(current)
    54                                         
    55     99.4 MiB -152570.1 MiB        5002           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     99.4 MiB -152570.3 MiB        5002           if current == end:
    60     66.5 MiB    -33.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     66.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     99.4 MiB -1256589.5 MiB       41123           for neighbor in current.neighbors:
    65     99.4 MiB -1104021.2 MiB       36122               if current.row != neighbor.row and current.col != neighbor.col:
    66     99.4 MiB -549504.5 MiB       17984                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     99.4 MiB -554555.0 MiB       18138                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     99.4 MiB -1104062.9 MiB       36122               if temp_g_score < g_score[neighbor]:
    71     99.4 MiB -169050.5 MiB        5676                   came_from[neighbor] = current
    72     99.4 MiB -169052.8 MiB        5676                   g_score[neighbor] = temp_g_score
    73     99.4 MiB -169054.0 MiB        5676                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     99.4 MiB -169054.5 MiB        5676                   if neighbor not in open_set_hash:
    75     99.4 MiB -167220.9 MiB        5613                       count += 1
    76     99.4 MiB -167201.9 MiB        5613                       open_set.put((f_score[neighbor], count, neighbor))
    77     99.4 MiB -167202.3 MiB        5613                       open_set_hash.add(neighbor)
    78                                                             
    79     99.4 MiB -152568.4 MiB        5001           if draw is not None:
    80                                                     draw()
    81                                         
    82     99.4 MiB -152569.0 MiB        5001           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.3 MiB     99.3 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.3 MiB  -1300.7 MiB         257       for row in grid:
    30     99.3 MiB -332301.8 MiB       65792           for spot in row:
    31     99.3 MiB -331009.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     88.4 MiB    -10.9 MiB           1       count = 0
    34     88.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     88.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     88.4 MiB      0.0 MiB           1       came_from = {}
    37     93.8 MiB   -256.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     93.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     98.4 MiB  -3691.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.1 MiB     -0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.3 MiB      0.0 MiB         269       while not open_set.empty():
    47     98.3 MiB      0.0 MiB         269           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.3 MiB      0.0 MiB         269           current = open_set.get()[2]
    53     98.3 MiB      0.0 MiB         269           open_set_hash.remove(current)
    54                                         
    55     98.3 MiB      0.0 MiB         269           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.3 MiB      0.0 MiB         269           if current == end:
    60     98.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.3 MiB      0.0 MiB        2235           for neighbor in current.neighbors:
    65     98.3 MiB      0.0 MiB        1967               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.3 MiB      0.0 MiB         979                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.3 MiB      0.0 MiB         988                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.3 MiB      0.0 MiB        1967               if temp_g_score < g_score[neighbor]:
    71     98.3 MiB      0.0 MiB         380                   came_from[neighbor] = current
    72     98.3 MiB      0.0 MiB         380                   g_score[neighbor] = temp_g_score
    73     98.3 MiB      0.0 MiB         380                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.3 MiB      0.0 MiB         380                   if neighbor not in open_set_hash:
    75     98.3 MiB      0.0 MiB         379                       count += 1
    76     98.3 MiB      0.1 MiB         379                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.3 MiB      0.0 MiB         379                       open_set_hash.add(neighbor)
    78                                                             
    79     98.3 MiB      0.0 MiB         268           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.3 MiB      0.0 MiB         268           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.2 MiB    104.2 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.2 MiB  -1065.7 MiB         257       for row in grid:
    30    104.2 MiB -272698.8 MiB       65792           for spot in row:
    31    104.2 MiB -271637.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     96.4 MiB     -7.9 MiB           1       count = 0
    34     96.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     96.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     96.4 MiB      0.0 MiB           1       came_from = {}
    37     99.9 MiB   -504.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    104.6 MiB  -6530.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.5 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.8 MiB  -6097.0 MiB        3883       while not open_set.empty():
    47    104.8 MiB  -6097.0 MiB        3883           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.8 MiB  -6097.0 MiB        3883           current = open_set.get()[2]
    53    104.8 MiB  -6097.0 MiB        3883           open_set_hash.remove(current)
    54                                         
    55    104.8 MiB  -6097.0 MiB        3883           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.8 MiB  -6097.0 MiB        3883           if current == end:
    60     89.5 MiB    -15.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     90.4 MiB      0.9 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.8 MiB -50797.5 MiB       31971           for neighbor in current.neighbors:
    65    104.8 MiB -44701.0 MiB       28089               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.8 MiB -22261.5 MiB       13979                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.8 MiB -22441.5 MiB       14110                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.8 MiB -44704.0 MiB       28089               if temp_g_score < g_score[neighbor]:
    71    104.8 MiB  -6944.6 MiB        4420                   came_from[neighbor] = current
    72    104.8 MiB  -6944.9 MiB        4420                   g_score[neighbor] = temp_g_score
    73    104.8 MiB  -6945.7 MiB        4420                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.8 MiB  -6947.3 MiB        4420                   if neighbor not in open_set_hash:
    75    104.8 MiB  -6909.7 MiB        4369                       count += 1
    76    104.8 MiB  -6918.3 MiB        4369                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.8 MiB  -6918.4 MiB        4369                       open_set_hash.add(neighbor)
    78                                                             
    79    104.8 MiB  -6097.0 MiB        3882           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.8 MiB  -6097.0 MiB        3882           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.8 MiB     98.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.8 MiB  -5511.9 MiB         257       for row in grid:
    30     98.8 MiB -1409785.2 MiB       65792           for spot in row:
    31     98.8 MiB -1404318.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     35.5 MiB    -63.2 MiB           1       count = 0
    34     35.9 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     36.1 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     36.1 MiB      0.0 MiB           1       came_from = {}
    37     53.0 MiB     16.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     53.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     57.3 MiB  -4406.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     57.5 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     57.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     57.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     57.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     59.3 MiB  -1797.0 MiB        1967       while not open_set.empty():
    47     59.3 MiB  -1797.0 MiB        1967           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     59.3 MiB  -1797.0 MiB        1967           current = open_set.get()[2]
    53     59.3 MiB  -1797.0 MiB        1967           open_set_hash.remove(current)
    54                                         
    55     59.3 MiB  -1797.0 MiB        1967           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     59.3 MiB  -1797.0 MiB        1967           if current == end:
    60     58.9 MiB     -0.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     58.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     59.3 MiB -14549.7 MiB       15827           for neighbor in current.neighbors:
    65     59.3 MiB -12751.7 MiB       13861               if current.row != neighbor.row and current.col != neighbor.col:
    66     59.3 MiB  -6342.6 MiB        6886                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     59.3 MiB  -6410.0 MiB        6975                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     59.3 MiB -12752.6 MiB       13861               if temp_g_score < g_score[neighbor]:
    71     59.3 MiB  -2274.0 MiB        2589                   came_from[neighbor] = current
    72     59.3 MiB  -2274.1 MiB        2589                   g_score[neighbor] = temp_g_score
    73     59.3 MiB  -2274.1 MiB        2589                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     59.3 MiB  -2274.1 MiB        2589                   if neighbor not in open_set_hash:
    75     59.3 MiB  -2166.2 MiB        2438                       count += 1
    76     59.3 MiB  -2166.1 MiB        2438                       open_set.put((f_score[neighbor], count, neighbor))
    77     59.3 MiB  -2166.0 MiB        2438                       open_set_hash.add(neighbor)
    78                                                             
    79     59.3 MiB  -1797.0 MiB        1966           if draw is not None:
    80                                                     draw()
    81                                         
    82     59.3 MiB  -1797.0 MiB        1966           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.3 MiB     99.3 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.3 MiB      0.0 MiB         257       for row in grid:
    30     99.3 MiB      0.0 MiB       65792           for spot in row:
    31     99.3 MiB      0.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.3 MiB      0.0 MiB           1       count = 0
    34     99.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.3 MiB      0.0 MiB           1       came_from = {}
    37    100.5 MiB -384551.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.7 MiB    -23.8 MiB           1       g_score[start] = 0
    39     77.2 MiB -3659820.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     17.2 MiB    -60.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     17.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     17.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     17.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     19.9 MiB   -320.4 MiB         520       while not open_set.empty():
    47     19.9 MiB   -320.6 MiB         520           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     19.9 MiB   -320.4 MiB         520           current = open_set.get()[2]
    53     19.9 MiB   -320.6 MiB         520           open_set_hash.remove(current)
    54                                         
    55     19.9 MiB   -320.7 MiB         520           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     19.9 MiB   -320.5 MiB         520           if current == end:
    60     17.1 MiB     -2.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     17.2 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     19.9 MiB  -2644.8 MiB        4270           for neighbor in current.neighbors:
    65     19.9 MiB  -2323.7 MiB        3751               if current.row != neighbor.row and current.col != neighbor.col:
    66     19.9 MiB  -1163.8 MiB        1873                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     19.9 MiB  -1162.5 MiB        1878                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     19.9 MiB  -2325.3 MiB        3751               if temp_g_score < g_score[neighbor]:
    71     19.9 MiB   -405.5 MiB         678                   came_from[neighbor] = current
    72     19.9 MiB   -405.7 MiB         678                   g_score[neighbor] = temp_g_score
    73     19.9 MiB   -405.4 MiB         678                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     19.9 MiB   -405.7 MiB         678                   if neighbor not in open_set_hash:
    75     19.9 MiB   -400.5 MiB         673                       count += 1
    76     19.9 MiB   -400.8 MiB         673                       open_set.put((f_score[neighbor], count, neighbor))
    77     19.9 MiB   -401.2 MiB         673                       open_set_hash.add(neighbor)
    78                                                             
    79     19.9 MiB   -320.6 MiB         519           if draw is not None:
    80                                                     draw()
    81                                         
    82     19.9 MiB   -320.6 MiB         519           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     88.8 MiB     88.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     88.8 MiB -16960.8 MiB         257       for row in grid:
    30     88.8 MiB -4351236.0 MiB       65792           for spot in row:
    31     88.8 MiB -4334317.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     18.6 MiB    -70.2 MiB           1       count = 0
    34     18.9 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     19.2 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     19.2 MiB      0.0 MiB           1       came_from = {}
    37     27.1 MiB -304941.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     26.3 MiB     -0.8 MiB           1       g_score[start] = 0
    39     35.0 MiB -101274.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     27.4 MiB     -7.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     27.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     27.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     27.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     56.1 MiB -20770.7 MiB        4746       while not open_set.empty():
    47     56.1 MiB -20773.8 MiB        4746           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     56.1 MiB -20774.4 MiB        4746           current = open_set.get()[2]
    53     56.1 MiB -20775.3 MiB        4746           open_set_hash.remove(current)
    54                                         
    55     56.1 MiB -20776.0 MiB        4746           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     56.1 MiB -20776.0 MiB        4746           if current == end:
    60     51.3 MiB     -4.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     51.8 MiB      0.5 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     56.1 MiB -170886.2 MiB       39065           for neighbor in current.neighbors:
    65     56.1 MiB -150115.0 MiB       34320               if current.row != neighbor.row and current.col != neighbor.col:
    66     56.1 MiB -74711.6 MiB       17079                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     56.1 MiB -75405.4 MiB       17241                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     56.1 MiB -150117.9 MiB       34320               if temp_g_score < g_score[neighbor]:
    71     56.1 MiB -23665.0 MiB        5455                   came_from[neighbor] = current
    72     56.1 MiB -23665.4 MiB        5455                   g_score[neighbor] = temp_g_score
    73     56.1 MiB -23664.4 MiB        5455                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     56.1 MiB -23664.6 MiB        5455                   if neighbor not in open_set_hash:
    75     56.1 MiB -23377.6 MiB        5388                       count += 1
    76     56.1 MiB -23344.3 MiB        5388                       open_set.put((f_score[neighbor], count, neighbor))
    77     56.1 MiB -23371.4 MiB        5388                       open_set_hash.add(neighbor)
    78                                                             
    79     56.1 MiB -20770.1 MiB        4745           if draw is not None:
    80                                                     draw()
    81                                         
    82     56.1 MiB -20770.3 MiB        4745           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     88.6 MiB     88.6 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     88.6 MiB -13317.2 MiB         257       for row in grid:
    30     88.6 MiB -3413168.3 MiB       65792           for spot in row:
    31     88.6 MiB -3399886.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     27.3 MiB    -61.4 MiB           1       count = 0
    34     27.6 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     27.9 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     27.9 MiB      0.0 MiB           1       came_from = {}
    37     40.9 MiB -12620.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     40.5 MiB     -0.4 MiB           1       g_score[start] = 0
    39     42.1 MiB -147370.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     39.6 MiB     -2.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     39.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     39.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     39.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     40.8 MiB  -4488.9 MiB         829       while not open_set.empty():
    47     40.8 MiB  -4489.0 MiB         829           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     40.8 MiB  -4488.9 MiB         829           current = open_set.get()[2]
    53     40.8 MiB  -4489.0 MiB         829           open_set_hash.remove(current)
    54                                         
    55     40.8 MiB  -4489.9 MiB         829           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     40.8 MiB  -4489.9 MiB         829           if current == end:
    60     33.2 MiB     -7.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     33.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     40.8 MiB -36458.6 MiB        6756           for neighbor in current.neighbors:
    65     40.8 MiB -31966.4 MiB        5928               if current.row != neighbor.row and current.col != neighbor.col:
    66     40.8 MiB -15981.1 MiB        2961                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     40.8 MiB -15986.0 MiB        2967                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     40.8 MiB -31967.0 MiB        5928               if temp_g_score < g_score[neighbor]:
    71     40.8 MiB  -6684.1 MiB        1244                   came_from[neighbor] = current
    72     40.8 MiB  -6684.2 MiB        1244                   g_score[neighbor] = temp_g_score
    73     40.8 MiB  -6685.1 MiB        1244                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     40.8 MiB  -6685.1 MiB        1244                   if neighbor not in open_set_hash:
    75     40.8 MiB  -5743.4 MiB        1087                       count += 1
    76     40.8 MiB  -5744.0 MiB        1087                       open_set.put((f_score[neighbor], count, neighbor))
    77     40.8 MiB  -5743.9 MiB        1087                       open_set_hash.add(neighbor)
    78                                                             
    79     40.8 MiB  -4489.0 MiB         828           if draw is not None:
    80                                                     draw()
    81                                         
    82     40.8 MiB  -4489.0 MiB         828           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     94.8 MiB     94.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     94.8 MiB -11140.2 MiB         257       for row in grid:
    30     94.8 MiB -2859442.2 MiB       65792           for spot in row:
    31     94.8 MiB -2848353.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     32.0 MiB    -62.8 MiB           1       count = 0
    34     32.4 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     32.6 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     32.6 MiB      0.0 MiB           1       came_from = {}
    37     46.9 MiB   -644.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     46.9 MiB     -0.0 MiB           1       g_score[start] = 0
    39     47.4 MiB -119218.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     43.9 MiB     -3.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     44.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     44.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     44.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     44.1 MiB   -226.6 MiB         155       while not open_set.empty():
    47     44.1 MiB   -226.7 MiB         155           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     44.1 MiB   -226.9 MiB         155           current = open_set.get()[2]
    53     44.1 MiB   -227.2 MiB         155           open_set_hash.remove(current)
    54                                         
    55     44.1 MiB   -227.3 MiB         155           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     44.1 MiB   -227.4 MiB         155           if current == end:
    60     40.0 MiB     -4.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     40.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     44.1 MiB  -1822.2 MiB        1258           for neighbor in current.neighbors:
    65     44.1 MiB  -1595.2 MiB        1104               if current.row != neighbor.row and current.col != neighbor.col:
    66     44.1 MiB   -795.6 MiB         547                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     44.1 MiB   -799.7 MiB         557                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     44.1 MiB  -1595.5 MiB        1104               if temp_g_score < g_score[neighbor]:
    71     44.1 MiB   -592.0 MiB         390                   came_from[neighbor] = current
    72     44.1 MiB   -592.2 MiB         390                   g_score[neighbor] = temp_g_score
    73     44.1 MiB   -594.1 MiB         390                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     44.1 MiB   -594.3 MiB         390                   if neighbor not in open_set_hash:
    75     44.1 MiB   -518.1 MiB         339                       count += 1
    76     44.1 MiB   -518.2 MiB         339                       open_set.put((f_score[neighbor], count, neighbor))
    77     44.1 MiB   -518.5 MiB         339                       open_set_hash.add(neighbor)
    78                                                             
    79     44.1 MiB   -226.5 MiB         154           if draw is not None:
    80                                                     draw()
    81                                         
    82     44.1 MiB   -226.6 MiB         154           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     91.2 MiB     91.2 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     91.2 MiB  -6496.5 MiB         257       for row in grid:
    30     91.2 MiB -1663007.8 MiB       65792           for spot in row:
    31     91.2 MiB -1656527.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     40.7 MiB    -50.5 MiB           1       count = 0
    34     41.1 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     41.4 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     41.4 MiB      0.0 MiB           1       came_from = {}
    37     55.0 MiB  -1919.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     54.8 MiB     -0.1 MiB           1       g_score[start] = 0
    39     55.6 MiB -275652.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     45.2 MiB    -10.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     45.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     45.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     45.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     46.5 MiB  -3403.4 MiB         815       while not open_set.empty():
    47     46.5 MiB  -3403.9 MiB         815           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     46.5 MiB  -3404.2 MiB         815           current = open_set.get()[2]
    53     46.5 MiB  -3404.3 MiB         815           open_set_hash.remove(current)
    54                                         
    55     46.5 MiB  -3404.4 MiB         815           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     46.5 MiB  -3404.5 MiB         815           if current == end:
    60     39.2 MiB     -7.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     39.3 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     46.5 MiB -27996.5 MiB        6758           for neighbor in current.neighbors:
    65     46.5 MiB -24592.8 MiB        5944               if current.row != neighbor.row and current.col != neighbor.col:
    66     46.5 MiB -12298.3 MiB        2967                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     46.5 MiB -12296.3 MiB        2977                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     46.5 MiB -24596.1 MiB        5944               if temp_g_score < g_score[neighbor]:
    71     46.5 MiB  -5381.8 MiB        1229                   came_from[neighbor] = current
    72     46.5 MiB  -5382.2 MiB        1229                   g_score[neighbor] = temp_g_score
    73     46.5 MiB  -5382.6 MiB        1229                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     46.5 MiB  -5383.0 MiB        1229                   if neighbor not in open_set_hash:
    75     46.5 MiB  -5366.0 MiB        1224                       count += 1
    76     46.5 MiB  -5367.1 MiB        1224                       open_set.put((f_score[neighbor], count, neighbor))
    77     46.5 MiB  -5367.4 MiB        1224                       open_set_hash.add(neighbor)
    78                                                             
    79     46.5 MiB  -3402.5 MiB         814           if draw is not None:
    80                                                     draw()
    81                                         
    82     46.5 MiB  -3402.9 MiB         814           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     90.8 MiB     90.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     90.8 MiB  -5133.2 MiB         257       for row in grid:
    30     90.8 MiB -1309571.4 MiB       65792           for spot in row:
    31     90.8 MiB -1304484.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     27.0 MiB    -63.8 MiB           1       count = 0
    34     27.4 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     27.6 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     27.6 MiB      0.0 MiB           1       came_from = {}
    37     43.5 MiB    -82.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     43.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     47.0 MiB -10873.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     46.5 MiB     -0.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     46.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     46.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     46.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     54.8 MiB -53941.6 MiB        4103       while not open_set.empty():
    47     54.8 MiB -53941.7 MiB        4103           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     54.8 MiB -53942.6 MiB        4103           current = open_set.get()[2]
    53     54.8 MiB -53942.9 MiB        4103           open_set_hash.remove(current)
    54                                         
    55     54.8 MiB -53947.1 MiB        4103           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     54.8 MiB -53947.6 MiB        4103           if current == end:
    60     54.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     54.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     54.8 MiB -442898.0 MiB       33754           for neighbor in current.neighbors:
    65     54.8 MiB -388958.8 MiB       29652               if current.row != neighbor.row and current.col != neighbor.col:
    66     54.8 MiB -193655.0 MiB       14764                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     54.8 MiB -195305.8 MiB       14888                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     54.8 MiB -388966.7 MiB       29652               if temp_g_score < g_score[neighbor]:
    71     54.8 MiB -62122.9 MiB        4781                   came_from[neighbor] = current
    72     54.8 MiB -62123.4 MiB        4781                   g_score[neighbor] = temp_g_score
    73     54.8 MiB -62124.0 MiB        4781                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     54.8 MiB -62124.3 MiB        4781                   if neighbor not in open_set_hash:
    75     54.8 MiB -61067.7 MiB        4712                       count += 1
    76     54.8 MiB -61040.3 MiB        4712                       open_set.put((f_score[neighbor], count, neighbor))
    77     54.8 MiB -61049.0 MiB        4712                       open_set_hash.add(neighbor)
    78                                                             
    79     54.8 MiB -53937.7 MiB        4102           if draw is not None:
    80                                                     draw()
    81                                         
    82     54.8 MiB -53941.4 MiB        4102           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     89.1 MiB     89.1 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     89.1 MiB -10531.9 MiB         257       for row in grid:
    30     89.1 MiB -2695649.8 MiB       65792           for spot in row:
    31     89.1 MiB -2685152.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     33.8 MiB    -55.3 MiB           1       count = 0
    34     34.1 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     34.3 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     34.3 MiB      0.0 MiB           1       came_from = {}
    37     39.6 MiB -962762.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     23.5 MiB    -16.1 MiB           1       g_score[start] = 0
    39     32.5 MiB  -4159.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     32.4 MiB     -0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     32.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     32.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     32.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     54.7 MiB -36103.7 MiB        8705       while not open_set.empty():
    47     54.7 MiB -36103.9 MiB        8705           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     54.7 MiB -36104.3 MiB        8705           current = open_set.get()[2]
    53     54.7 MiB -36105.0 MiB        8705           open_set_hash.remove(current)
    54                                         
    55     54.7 MiB -36105.8 MiB        8705           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     54.7 MiB -36106.0 MiB        8705           if current == end:
    60     53.8 MiB     -0.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     54.0 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     54.7 MiB -297938.9 MiB       71715           for neighbor in current.neighbors:
    65     54.7 MiB -261834.9 MiB       63011               if current.row != neighbor.row and current.col != neighbor.col:
    66     54.7 MiB -130230.7 MiB       31342                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     54.7 MiB -131609.4 MiB       31669                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     54.7 MiB -261841.8 MiB       63011               if temp_g_score < g_score[neighbor]:
    71     54.7 MiB -40037.4 MiB        9691                   came_from[neighbor] = current
    72     54.7 MiB -40038.6 MiB        9691                   g_score[neighbor] = temp_g_score
    73     54.7 MiB -40038.9 MiB        9691                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     54.7 MiB -40039.0 MiB        9691                   if neighbor not in open_set_hash:
    75     54.7 MiB -39420.4 MiB        9564                       count += 1
    76     54.7 MiB -39390.8 MiB        9564                       open_set.put((f_score[neighbor], count, neighbor))
    77     54.7 MiB -39411.1 MiB        9564                       open_set_hash.add(neighbor)
    78                                                             
    79     54.7 MiB -36103.5 MiB        8704           if draw is not None:
    80                                                     draw()
    81                                         
    82     54.7 MiB -36103.6 MiB        8704           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     88.5 MiB     88.5 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     88.5 MiB   -661.7 MiB         257       for row in grid:
    30     88.5 MiB -169194.1 MiB       65792           for spot in row:
    31     88.5 MiB -168537.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     82.0 MiB     -6.5 MiB           1       count = 0
    34     82.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     82.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     82.0 MiB      0.0 MiB           1       came_from = {}
    37     86.0 MiB -872454.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     23.4 MiB    -62.6 MiB           1       g_score[start] = 0
    39     33.4 MiB  -3088.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     33.6 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     33.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     33.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     33.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     35.7 MiB -25716.2 MiB        4507       while not open_set.empty():
    47     35.7 MiB -25716.5 MiB        4507           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     35.7 MiB -25718.2 MiB        4507           current = open_set.get()[2]
    53     35.7 MiB -25718.5 MiB        4507           open_set_hash.remove(current)
    54                                         
    55     35.7 MiB -25718.6 MiB        4507           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     35.7 MiB -25718.7 MiB        4507           if current == end:
    60     28.7 MiB     -7.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     29.5 MiB      0.8 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     35.7 MiB -212031.4 MiB       37141           for neighbor in current.neighbors:
    65     35.7 MiB -186313.6 MiB       32635               if current.row != neighbor.row and current.col != neighbor.col:
    66     35.7 MiB -92806.2 MiB       16248                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     35.7 MiB -93512.7 MiB       16387                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     35.7 MiB -186318.4 MiB       32635               if temp_g_score < g_score[neighbor]:
    71     35.7 MiB -28471.6 MiB        5107                   came_from[neighbor] = current
    72     35.7 MiB -28471.8 MiB        5107                   g_score[neighbor] = temp_g_score
    73     35.7 MiB -28472.2 MiB        5107                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     35.7 MiB -28472.3 MiB        5107                   if neighbor not in open_set_hash:
    75     35.7 MiB -28173.3 MiB        5057                       count += 1
    76     35.7 MiB -28173.4 MiB        5057                       open_set.put((f_score[neighbor], count, neighbor))
    77     35.7 MiB -28173.7 MiB        5057                       open_set_hash.add(neighbor)
    78                                                             
    79     35.7 MiB -25713.8 MiB        4506           if draw is not None:
    80                                                     draw()
    81                                         
    82     35.7 MiB -25715.9 MiB        4506           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     86.5 MiB     86.5 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     86.5 MiB -12697.4 MiB         257       for row in grid:
    30     86.5 MiB -3255438.8 MiB       65792           for spot in row:
    31     86.5 MiB -3242793.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     19.2 MiB    -67.3 MiB           1       count = 0
    34     19.6 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     19.8 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     19.8 MiB      0.0 MiB           1       came_from = {}
    37     39.1 MiB    -11.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     39.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     43.5 MiB -33080.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     43.7 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     43.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     43.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     43.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     48.1 MiB    -15.0 MiB        1079       while not open_set.empty():
    47     48.1 MiB    -15.0 MiB        1079           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     48.1 MiB    -15.0 MiB        1079           current = open_set.get()[2]
    53     48.1 MiB    -15.0 MiB        1079           open_set_hash.remove(current)
    54                                         
    55     48.1 MiB    -15.0 MiB        1079           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     48.1 MiB    -15.0 MiB        1079           if current == end:
    60     48.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     48.2 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     48.1 MiB   -122.2 MiB        8930           for neighbor in current.neighbors:
    65     48.1 MiB   -105.6 MiB        7852               if current.row != neighbor.row and current.col != neighbor.col:
    66     48.1 MiB    -54.6 MiB        3911                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     48.1 MiB    -53.7 MiB        3941                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     48.1 MiB   -108.6 MiB        7852               if temp_g_score < g_score[neighbor]:
    71     48.1 MiB    -17.2 MiB        1344                   came_from[neighbor] = current
    72     48.1 MiB    -17.3 MiB        1344                   g_score[neighbor] = temp_g_score
    73     48.1 MiB    -17.3 MiB        1344                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     48.1 MiB    -17.3 MiB        1344                   if neighbor not in open_set_hash:
    75     48.1 MiB    -17.3 MiB        1335                       count += 1
    76     48.1 MiB    -17.2 MiB        1335                       open_set.put((f_score[neighbor], count, neighbor))
    77     48.1 MiB    -17.2 MiB        1335                       open_set_hash.add(neighbor)
    78                                                             
    79     48.1 MiB    -15.0 MiB        1078           if draw is not None:
    80                                                     draw()
    81                                         
    82     48.1 MiB    -15.0 MiB        1078           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     95.9 MiB     95.9 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.9 MiB  -2892.1 MiB         257       for row in grid:
    30     95.9 MiB -728207.8 MiB       65792           for spot in row:
    31     95.9 MiB -725383.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     18.9 MiB    -77.0 MiB           1       count = 0
    34     19.2 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     19.4 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     19.5 MiB      0.0 MiB           1       came_from = {}
    37     38.7 MiB      2.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     38.7 MiB      0.0 MiB           1       g_score[start] = 0
    39     45.3 MiB   -561.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     45.5 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     45.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     45.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     45.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     46.1 MiB   -293.0 MiB         785       while not open_set.empty():
    47     46.1 MiB   -293.0 MiB         785           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     46.1 MiB   -293.0 MiB         785           current = open_set.get()[2]
    53     46.1 MiB   -293.0 MiB         785           open_set_hash.remove(current)
    54                                         
    55     46.1 MiB   -293.0 MiB         785           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     46.1 MiB   -293.0 MiB         785           if current == end:
    60     45.3 MiB     -0.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     45.3 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     46.1 MiB  -2412.9 MiB        6421           for neighbor in current.neighbors:
    65     46.1 MiB  -2119.5 MiB        5637               if current.row != neighbor.row and current.col != neighbor.col:
    66     46.1 MiB  -1058.2 MiB        2811                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     46.1 MiB  -1061.8 MiB        2826                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     46.1 MiB  -2120.3 MiB        5637               if temp_g_score < g_score[neighbor]:
    71     46.1 MiB   -427.2 MiB        1250                   came_from[neighbor] = current
    72     46.1 MiB   -427.3 MiB        1250                   g_score[neighbor] = temp_g_score
    73     46.1 MiB   -427.3 MiB        1250                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     46.1 MiB   -427.3 MiB        1250                   if neighbor not in open_set_hash:
    75     46.1 MiB   -390.4 MiB        1090                       count += 1
    76     46.1 MiB   -390.4 MiB        1090                       open_set.put((f_score[neighbor], count, neighbor))
    77     46.1 MiB   -390.4 MiB        1090                       open_set_hash.add(neighbor)
    78                                                             
    79     46.1 MiB   -293.0 MiB         784           if draw is not None:
    80                                                     draw()
    81                                         
    82     46.1 MiB   -293.0 MiB         784           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.0 MiB     97.0 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.0 MiB  -3292.1 MiB         257       for row in grid:
    30     97.0 MiB -843447.3 MiB       65792           for spot in row:
    31     97.0 MiB -840171.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     75.7 MiB    -21.3 MiB           1       count = 0
    34     76.0 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     76.2 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     76.2 MiB      0.0 MiB           1       came_from = {}
    37     79.1 MiB -1888917.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     43.5 MiB    -35.6 MiB           1       g_score[start] = 0
    39     50.1 MiB  -5646.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     47.5 MiB     -2.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     47.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     47.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     47.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     49.4 MiB -58699.0 MiB        4928       while not open_set.empty():
    47     49.4 MiB -58699.4 MiB        4928           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     49.4 MiB -58701.8 MiB        4928           current = open_set.get()[2]
    53     49.4 MiB -58703.0 MiB        4928           open_set_hash.remove(current)
    54                                         
    55     49.4 MiB -58703.7 MiB        4928           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     49.4 MiB -58706.4 MiB        4928           if current == end:
    60     20.6 MiB    -28.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     21.2 MiB      0.5 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     49.4 MiB -480482.2 MiB       40553           for neighbor in current.neighbors:
    65     49.4 MiB -421784.8 MiB       35626               if current.row != neighbor.row and current.col != neighbor.col:
    66     49.4 MiB -209739.2 MiB       17726                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     49.4 MiB -212047.6 MiB       17900                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     49.4 MiB -421799.6 MiB       35626               if temp_g_score < g_score[neighbor]:
    71     49.4 MiB -65026.5 MiB        5565                   came_from[neighbor] = current
    72     49.4 MiB -65026.9 MiB        5565                   g_score[neighbor] = temp_g_score
    73     49.4 MiB -65027.2 MiB        5565                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     49.4 MiB -65027.3 MiB        5565                   if neighbor not in open_set_hash:
    75     49.4 MiB -64232.6 MiB        5498                       count += 1
    76     49.4 MiB -64233.3 MiB        5498                       open_set.put((f_score[neighbor], count, neighbor))
    77     49.4 MiB -64233.2 MiB        5498                       open_set_hash.add(neighbor)
    78                                                             
    79     49.4 MiB -58698.9 MiB        4927           if draw is not None:
    80                                                     draw()
    81                                         
    82     49.4 MiB -58699.0 MiB        4927           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.6 MiB     92.6 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.6 MiB   -336.8 MiB         257       for row in grid:
    30     92.6 MiB -85943.8 MiB       65792           for spot in row:
    31     92.6 MiB -85609.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     88.0 MiB     -4.6 MiB           1       count = 0
    34     88.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     88.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     88.0 MiB      0.0 MiB           1       came_from = {}
    37     92.3 MiB  -7303.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     92.3 MiB     -0.0 MiB           1       g_score[start] = 0
    39     92.8 MiB -2456380.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     36.1 MiB    -56.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     36.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     36.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     36.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     38.7 MiB    -13.1 MiB         300       while not open_set.empty():
    47     38.7 MiB    -13.3 MiB         300           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     38.7 MiB    -13.0 MiB         300           current = open_set.get()[2]
    53     38.7 MiB    -13.3 MiB         300           open_set_hash.remove(current)
    54                                         
    55     38.7 MiB    -13.3 MiB         300           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     38.7 MiB    -13.3 MiB         300           if current == end:
    60     38.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     38.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     38.7 MiB   -107.2 MiB        2471           for neighbor in current.neighbors:
    65     38.7 MiB    -93.7 MiB        2172               if current.row != neighbor.row and current.col != neighbor.col:
    66     38.7 MiB    -47.6 MiB        1083                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     38.7 MiB    -47.3 MiB        1089                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     38.7 MiB    -94.8 MiB        2172               if temp_g_score < g_score[neighbor]:
    71     38.7 MiB    -16.2 MiB         414                   came_from[neighbor] = current
    72     38.7 MiB    -16.3 MiB         414                   g_score[neighbor] = temp_g_score
    73     38.7 MiB    -16.3 MiB         414                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     38.7 MiB    -16.3 MiB         414                   if neighbor not in open_set_hash:
    75     38.7 MiB    -16.3 MiB         413                       count += 1
    76     38.7 MiB    -16.2 MiB         413                       open_set.put((f_score[neighbor], count, neighbor))
    77     38.7 MiB    -16.3 MiB         413                       open_set_hash.add(neighbor)
    78                                                             
    79     38.7 MiB    -13.3 MiB         299           if draw is not None:
    80                                                     draw()
    81                                         
    82     38.7 MiB    -13.3 MiB         299           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     95.4 MiB     95.4 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     95.4 MiB   -739.8 MiB         257       for row in grid:
    30     95.4 MiB -189447.1 MiB       65792           for spot in row:
    31     95.4 MiB -188710.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     91.2 MiB     -4.2 MiB           1       count = 0
    34     91.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     91.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     91.2 MiB      0.0 MiB           1       came_from = {}
    37     92.4 MiB -1005019.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     27.4 MiB    -65.0 MiB           1       g_score[start] = 0
    39     35.4 MiB   -422.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     35.5 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     35.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     35.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     35.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     56.3 MiB   -126.0 MiB        1418       while not open_set.empty():
    47     56.3 MiB   -126.3 MiB        1418           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     56.3 MiB   -126.0 MiB        1418           current = open_set.get()[2]
    53     56.3 MiB   -126.3 MiB        1418           open_set_hash.remove(current)
    54                                         
    55     56.3 MiB   -126.3 MiB        1418           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     56.3 MiB   -126.3 MiB        1418           if current == end:
    60     56.3 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     56.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     56.3 MiB  -1050.5 MiB       11762           for neighbor in current.neighbors:
    65     56.3 MiB   -922.0 MiB       10345               if current.row != neighbor.row and current.col != neighbor.col:
    66     56.3 MiB   -458.5 MiB        5146                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     56.3 MiB   -467.3 MiB        5199                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     56.3 MiB   -926.2 MiB       10345               if temp_g_score < g_score[neighbor]:
    71     56.3 MiB   -222.1 MiB        2503                   came_from[neighbor] = current
    72     56.3 MiB   -222.2 MiB        2503                   g_score[neighbor] = temp_g_score
    73     56.3 MiB   -222.2 MiB        2503                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     56.3 MiB   -222.2 MiB        2503                   if neighbor not in open_set_hash:
    75     56.3 MiB   -175.2 MiB        2079                       count += 1
    76     56.3 MiB   -160.1 MiB        2079                       open_set.put((f_score[neighbor], count, neighbor))
    77     56.3 MiB   -175.1 MiB        2079                       open_set_hash.add(neighbor)
    78                                                             
    79     56.3 MiB   -128.7 MiB        1417           if draw is not None:
    80                                                     draw()
    81                                         
    82     56.3 MiB   -126.2 MiB        1417           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     94.2 MiB     94.2 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     94.2 MiB  -2170.1 MiB         257       for row in grid:
    30     94.2 MiB -548831.0 MiB       65792           for spot in row:
    31     94.2 MiB -546706.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     21.1 MiB    -73.1 MiB           1       count = 0
    34     21.5 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     21.7 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     21.7 MiB      0.0 MiB           1       came_from = {}
    37     38.0 MiB  -6241.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     37.6 MiB     -0.4 MiB           1       g_score[start] = 0
    39     42.6 MiB      5.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     42.8 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     42.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     42.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     42.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     44.8 MiB      0.1 MiB         106       while not open_set.empty():
    47     44.8 MiB      0.0 MiB         106           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     44.8 MiB      0.0 MiB         106           current = open_set.get()[2]
    53     44.8 MiB      0.0 MiB         106           open_set_hash.remove(current)
    54                                         
    55     44.8 MiB      0.0 MiB         106           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     44.8 MiB      0.0 MiB         106           if current == end:
    60     44.8 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     44.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     44.8 MiB      0.6 MiB         896           for neighbor in current.neighbors:
    65     44.8 MiB      1.2 MiB         791               if current.row != neighbor.row and current.col != neighbor.col:
    66     44.8 MiB      0.0 MiB         394                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     44.8 MiB      0.0 MiB         397                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     44.8 MiB      0.0 MiB         791               if temp_g_score < g_score[neighbor]:
    71     44.8 MiB      0.1 MiB         193                   came_from[neighbor] = current
    72     44.8 MiB      0.0 MiB         193                   g_score[neighbor] = temp_g_score
    73     44.8 MiB      0.0 MiB         193                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     44.8 MiB      0.0 MiB         193                   if neighbor not in open_set_hash:
    75     44.8 MiB      0.0 MiB         189                       count += 1
    76     44.8 MiB      0.0 MiB         189                       open_set.put((f_score[neighbor], count, neighbor))
    77     44.8 MiB      0.0 MiB         189                       open_set_hash.add(neighbor)
    78                                                             
    79     44.8 MiB      0.0 MiB         105           if draw is not None:
    80                                                     draw()
    81                                         
    82     44.8 MiB      0.0 MiB         105           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.5 MiB     92.5 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.5 MiB  -3564.0 MiB         257       for row in grid:
    30     92.5 MiB -914931.7 MiB       65792           for spot in row:
    31     92.5 MiB -911378.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     75.6 MiB    -16.9 MiB           1       count = 0
    34     75.9 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     76.1 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     76.1 MiB      0.0 MiB           1       came_from = {}
    37     79.3 MiB -1442731.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     46.0 MiB    -33.3 MiB           1       g_score[start] = 0
    39     52.9 MiB   -139.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     53.2 MiB      0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     53.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     53.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     53.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     53.6 MiB  -8403.3 MiB        4376       while not open_set.empty():
    47     53.6 MiB  -8403.7 MiB        4376           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     53.6 MiB  -8403.6 MiB        4376           current = open_set.get()[2]
    53     53.6 MiB  -8403.7 MiB        4376           open_set_hash.remove(current)
    54                                         
    55     53.6 MiB  -8403.7 MiB        4376           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     53.6 MiB  -8403.8 MiB        4376           if current == end:
    60     50.7 MiB     -3.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     50.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     53.6 MiB -69336.2 MiB       36081           for neighbor in current.neighbors:
    65     53.6 MiB -60934.0 MiB       31706               if current.row != neighbor.row and current.col != neighbor.col:
    66     53.6 MiB -30353.0 MiB       15791                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     53.6 MiB -30581.5 MiB       15915                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     53.6 MiB -60935.2 MiB       31706               if temp_g_score < g_score[neighbor]:
    71     53.6 MiB  -9359.6 MiB        4974                   came_from[neighbor] = current
    72     53.6 MiB  -9359.8 MiB        4974                   g_score[neighbor] = temp_g_score
    73     53.6 MiB  -9359.8 MiB        4974                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     53.6 MiB  -9359.8 MiB        4974                   if neighbor not in open_set_hash:
    75     53.6 MiB  -9254.6 MiB        4922                       count += 1
    76     53.6 MiB  -9254.5 MiB        4922                       open_set.put((f_score[neighbor], count, neighbor))
    77     53.6 MiB  -9254.4 MiB        4922                       open_set_hash.add(neighbor)
    78                                                             
    79     53.6 MiB  -8403.2 MiB        4375           if draw is not None:
    80                                                     draw()
    81                                         
    82     53.6 MiB  -8403.3 MiB        4375           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.3 MiB     93.3 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.3 MiB  -1295.5 MiB         257       for row in grid:
    30     93.3 MiB -331427.5 MiB       65792           for spot in row:
    31     93.3 MiB -330138.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     82.4 MiB    -10.9 MiB           1       count = 0
    34     82.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     82.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     82.4 MiB      0.0 MiB           1       came_from = {}
    37     82.8 MiB -1606164.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     51.7 MiB    -31.2 MiB           1       g_score[start] = 0
    39     58.0 MiB -146708.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     35.2 MiB    -22.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     35.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     35.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     35.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     39.5 MiB -19673.3 MiB        3328       while not open_set.empty():
    47     39.5 MiB -19674.0 MiB        3328           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     39.5 MiB -19680.6 MiB        3328           current = open_set.get()[2]
    53     39.5 MiB -19680.9 MiB        3328           open_set_hash.remove(current)
    54                                         
    55     39.5 MiB -19681.2 MiB        3328           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     39.5 MiB -19681.4 MiB        3328           if current == end:
    60     27.5 MiB    -12.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     28.6 MiB      1.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     39.5 MiB -161369.3 MiB       27364           for neighbor in current.neighbors:
    65     39.5 MiB -141695.8 MiB       24037               if current.row != neighbor.row and current.col != neighbor.col:
    66     39.5 MiB -70354.7 MiB       11945                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     39.5 MiB -71344.3 MiB       12092                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     39.5 MiB -141698.5 MiB       24037               if temp_g_score < g_score[neighbor]:
    71     39.5 MiB -22337.9 MiB        3837                   came_from[neighbor] = current
    72     39.5 MiB -22338.9 MiB        3837                   g_score[neighbor] = temp_g_score
    73     39.5 MiB -22339.1 MiB        3837                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     39.5 MiB -22340.0 MiB        3837                   if neighbor not in open_set_hash:
    75     39.5 MiB -22050.5 MiB        3792                       count += 1
    76     39.5 MiB -22050.2 MiB        3792                       open_set.put((f_score[neighbor], count, neighbor))
    77     39.5 MiB -22050.2 MiB        3792                       open_set_hash.add(neighbor)
    78                                                             
    79     39.5 MiB -19671.9 MiB        3327           if draw is not None:
    80                                                     draw()
    81                                         
    82     39.5 MiB -19673.5 MiB        3327           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     87.8 MiB     87.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     87.8 MiB  -3544.5 MiB         257       for row in grid:
    30     87.8 MiB -896122.2 MiB       65792           for spot in row:
    31     87.8 MiB -892643.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     16.6 MiB    -71.2 MiB           1       count = 0
    34     17.0 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     17.2 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     17.2 MiB      0.0 MiB           1       came_from = {}
    37     33.4 MiB -323584.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     15.5 MiB    -17.9 MiB           1       g_score[start] = 0
    39     29.0 MiB  -4089.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     29.4 MiB      0.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     29.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     29.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     29.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     33.3 MiB  -7476.0 MiB        2067       while not open_set.empty():
    47     33.3 MiB  -7476.3 MiB        2067           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     33.3 MiB  -7476.1 MiB        2067           current = open_set.get()[2]
    53     33.3 MiB  -7480.5 MiB        2067           open_set_hash.remove(current)
    54                                         
    55     33.3 MiB  -7481.7 MiB        2067           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     33.3 MiB  -7481.7 MiB        2067           if current == end:
    60     23.2 MiB    -10.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     23.8 MiB      0.7 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     33.3 MiB -62870.3 MiB       17059           for neighbor in current.neighbors:
    65     33.3 MiB -55365.1 MiB       14993               if current.row != neighbor.row and current.col != neighbor.col:
    66     33.3 MiB -27635.2 MiB        7463                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     33.3 MiB -27757.6 MiB        7530                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     33.3 MiB -55374.4 MiB       14993               if temp_g_score < g_score[neighbor]:
    71     33.3 MiB  -8661.5 MiB        2449                   came_from[neighbor] = current
    72     33.3 MiB  -8661.6 MiB        2449                   g_score[neighbor] = temp_g_score
    73     33.3 MiB  -8662.0 MiB        2449                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     33.3 MiB  -8663.8 MiB        2449                   if neighbor not in open_set_hash:
    75     33.3 MiB  -8578.8 MiB        2426                       count += 1
    76     33.3 MiB  -8580.0 MiB        2426                       open_set.put((f_score[neighbor], count, neighbor))
    77     33.3 MiB  -8581.2 MiB        2426                       open_set_hash.add(neighbor)
    78                                                             
    79     33.3 MiB  -7477.5 MiB        2066           if draw is not None:
    80                                                     draw()
    81                                         
    82     33.3 MiB  -7476.2 MiB        2066           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     85.1 MiB     85.1 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     85.1 MiB  -8860.1 MiB         257       for row in grid:
    30     85.1 MiB -2270701.1 MiB       65792           for spot in row:
    31     85.1 MiB -2261860.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     41.8 MiB    -43.4 MiB           1       count = 0
    34     42.1 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     42.3 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     42.3 MiB      0.0 MiB           1       came_from = {}
    37     55.3 MiB   -218.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     55.3 MiB      0.0 MiB           1       g_score[start] = 0
    39     61.5 MiB  -1958.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     61.7 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     61.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     61.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     61.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     62.0 MiB -27679.3 MiB        2842       while not open_set.empty():
    47     62.0 MiB -27680.3 MiB        2842           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     62.0 MiB -27682.4 MiB        2842           current = open_set.get()[2]
    53     62.0 MiB -27683.3 MiB        2842           open_set_hash.remove(current)
    54                                         
    55     62.0 MiB -27683.6 MiB        2842           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     62.0 MiB -27683.8 MiB        2842           if current == end:
    60     48.7 MiB    -13.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     48.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     62.0 MiB -226943.1 MiB       23255           for neighbor in current.neighbors:
    65     62.0 MiB -199264.9 MiB       20414               if current.row != neighbor.row and current.col != neighbor.col:
    66     62.0 MiB -99138.3 MiB       10160                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     62.0 MiB -100127.4 MiB       10254                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     62.0 MiB -199269.3 MiB       20414               if temp_g_score < g_score[neighbor]:
    71     62.0 MiB -31622.0 MiB        3320                   came_from[neighbor] = current
    72     62.0 MiB -31622.3 MiB        3320                   g_score[neighbor] = temp_g_score
    73     62.0 MiB -31623.6 MiB        3320                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     62.0 MiB -31624.1 MiB        3320                   if neighbor not in open_set_hash:
    75     62.0 MiB -31172.7 MiB        3274                       count += 1
    76     62.0 MiB -31172.9 MiB        3274                       open_set.put((f_score[neighbor], count, neighbor))
    77     62.0 MiB -31172.8 MiB        3274                       open_set_hash.add(neighbor)
    78                                                             
    79     62.0 MiB -27678.5 MiB        2841           if draw is not None:
    80                                                     draw()
    81                                         
    82     62.0 MiB -27678.7 MiB        2841           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     89.9 MiB     89.9 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     89.9 MiB  -1776.0 MiB         257       for row in grid:
    30     89.9 MiB -456382.6 MiB       65792           for spot in row:
    31     89.9 MiB -454605.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     81.3 MiB     -8.6 MiB           1       count = 0
    34     81.6 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     81.8 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     81.8 MiB      0.0 MiB           1       came_from = {}
    37     87.1 MiB -20056.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     84.4 MiB     -2.7 MiB           1       g_score[start] = 0
    39     89.9 MiB -264770.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     75.2 MiB    -14.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     75.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     75.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     75.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     77.5 MiB -92060.2 MiB        5068       while not open_set.empty():
    47     77.5 MiB -92060.3 MiB        5068           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     77.5 MiB -92060.3 MiB        5068           current = open_set.get()[2]
    53     77.5 MiB -92060.4 MiB        5068           open_set_hash.remove(current)
    54                                         
    55     77.5 MiB -92060.4 MiB        5068           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     77.5 MiB -92060.4 MiB        5068           if current == end:
    60     62.5 MiB    -15.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     62.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     77.5 MiB -757112.4 MiB       41673           for neighbor in current.neighbors:
    65     77.5 MiB -665049.8 MiB       36606               if current.row != neighbor.row and current.col != neighbor.col:
    66     77.5 MiB -330753.8 MiB       18212                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     77.5 MiB -334297.3 MiB       18394                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     77.5 MiB -665077.7 MiB       36606               if temp_g_score < g_score[neighbor]:
    71     77.5 MiB -102513.4 MiB        5730                   came_from[neighbor] = current
    72     77.5 MiB -102513.8 MiB        5730                   g_score[neighbor] = temp_g_score
    73     77.5 MiB -102513.9 MiB        5730                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     77.5 MiB -102514.1 MiB        5730                   if neighbor not in open_set_hash:
    75     77.5 MiB -101242.6 MiB        5669                       count += 1
    76     77.5 MiB -101233.1 MiB        5669                       open_set.put((f_score[neighbor], count, neighbor))
    77     77.5 MiB -101233.1 MiB        5669                       open_set_hash.add(neighbor)
    78                                                             
    79     77.5 MiB -92060.1 MiB        5067           if draw is not None:
    80                                                     draw()
    81                                         
    82     77.5 MiB -92060.1 MiB        5067           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.5 MiB     92.5 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.5 MiB  -2308.0 MiB         257       for row in grid:
    30     92.5 MiB -581974.7 MiB       65792           for spot in row:
    31     92.5 MiB -579699.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     29.3 MiB    -63.2 MiB           1       count = 0
    34     29.4 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     29.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     29.4 MiB      0.0 MiB           1       came_from = {}
    37     40.1 MiB -21103.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     40.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     45.9 MiB   -803.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     46.1 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     46.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     46.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     46.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     50.1 MiB     -0.1 MiB        2815       while not open_set.empty():
    47     50.1 MiB     -0.1 MiB        2815           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     50.1 MiB     -0.1 MiB        2815           current = open_set.get()[2]
    53     50.1 MiB     -0.1 MiB        2815           open_set_hash.remove(current)
    54                                         
    55     50.1 MiB     -0.1 MiB        2815           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     50.1 MiB     -0.1 MiB        2815           if current == end:
    60     50.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     50.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     50.1 MiB      0.8 MiB       22961           for neighbor in current.neighbors:
    65     50.1 MiB      0.9 MiB       20147               if current.row != neighbor.row and current.col != neighbor.col:
    66     50.1 MiB     -0.3 MiB       10021                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     50.1 MiB     -0.3 MiB       10126                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     50.1 MiB     -0.7 MiB       20147               if temp_g_score < g_score[neighbor]:
    71     50.1 MiB      0.4 MiB        3257                   came_from[neighbor] = current
    72     50.1 MiB     -0.1 MiB        3257                   g_score[neighbor] = temp_g_score
    73     50.1 MiB     -0.1 MiB        3257                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     50.1 MiB     -0.1 MiB        3257                   if neighbor not in open_set_hash:
    75     50.1 MiB     -0.1 MiB        3219                       count += 1
    76     50.1 MiB      0.0 MiB        3219                       open_set.put((f_score[neighbor], count, neighbor))
    77     50.1 MiB     -0.0 MiB        3219                       open_set_hash.add(neighbor)
    78                                                             
    79     50.1 MiB     -0.1 MiB        2814           if draw is not None:
    80                                                     draw()
    81                                         
    82     50.1 MiB     -0.1 MiB        2814           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.7 MiB     93.7 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.7 MiB  -1147.2 MiB         257       for row in grid:
    30     93.7 MiB -279582.6 MiB       65792           for spot in row:
    31     93.7 MiB -278497.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     24.5 MiB    -69.1 MiB           1       count = 0
    34     24.9 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     25.2 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     25.2 MiB      0.0 MiB           1       came_from = {}
    37     38.8 MiB -96442.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     35.1 MiB     -3.6 MiB           1       g_score[start] = 0
    39     41.3 MiB  -5585.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     41.5 MiB      0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     41.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     41.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     41.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     61.9 MiB    -82.3 MiB        2159       while not open_set.empty():
    47     61.9 MiB    -82.3 MiB        2159           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     61.9 MiB    -82.3 MiB        2159           current = open_set.get()[2]
    53     61.9 MiB    -82.3 MiB        2159           open_set_hash.remove(current)
    54                                         
    55     61.9 MiB    -82.3 MiB        2159           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     61.9 MiB    -82.3 MiB        2159           if current == end:
    60     61.9 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     61.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     61.9 MiB   -667.4 MiB       17621           for neighbor in current.neighbors:
    65     61.9 MiB   -583.0 MiB       15463               if current.row != neighbor.row and current.col != neighbor.col:
    66     61.9 MiB   -289.2 MiB        7679                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     61.9 MiB   -297.9 MiB        7784                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     61.9 MiB   -587.1 MiB       15463               if temp_g_score < g_score[neighbor]:
    71     61.9 MiB   -120.2 MiB        3439                   came_from[neighbor] = current
    72     61.9 MiB   -120.3 MiB        3439                   g_score[neighbor] = temp_g_score
    73     61.9 MiB   -120.3 MiB        3439                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     61.9 MiB   -120.6 MiB        3439                   if neighbor not in open_set_hash:
    75     61.9 MiB    -80.4 MiB        3007                       count += 1
    76     61.9 MiB    -66.7 MiB        3007                       open_set.put((f_score[neighbor], count, neighbor))
    77     61.9 MiB    -80.2 MiB        3007                       open_set_hash.add(neighbor)
    78                                                             
    79     61.9 MiB    -82.3 MiB        2158           if draw is not None:
    80                                                     draw()
    81                                         
    82     61.9 MiB    -82.3 MiB        2158           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


