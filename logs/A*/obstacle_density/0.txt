Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     67.7 MiB     67.7 MiB           1   @profile(stream=open('logs/A*/obstacle_density/0.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     68.3 MiB  -2920.9 MiB         257       for row in grid:
    30     68.3 MiB -749557.5 MiB       65792           for spot in row:
    31     68.3 MiB -746633.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     58.2 MiB    -10.1 MiB           1       count = 0
    34     58.3 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     58.3 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     58.3 MiB      0.0 MiB           1       came_from = {}
    37     65.4 MiB      7.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     65.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     72.0 MiB   -278.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     72.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     72.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     72.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44     72.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     72.2 MiB      0.0 MiB        1674       while not open_set.empty():
    47     72.2 MiB      0.0 MiB        1674           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     72.2 MiB      0.0 MiB        1674           current = open_set.get()[2]
    53     72.2 MiB      0.0 MiB        1674           open_set_hash.remove(current)
    54                                         
    55     72.2 MiB      0.0 MiB        1674           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     72.2 MiB      0.0 MiB        1674           if current == end:
    60     72.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     72.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     72.2 MiB      0.0 MiB       15057           for neighbor in current.neighbors:
    65     72.2 MiB      0.0 MiB       13384               if current.row != neighbor.row and current.col != neighbor.col:
    66     72.2 MiB      0.0 MiB        6692                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     72.2 MiB      0.0 MiB        6692                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     72.2 MiB      0.0 MiB       13384               if temp_g_score < g_score[neighbor]:
    71     72.2 MiB      0.1 MiB        1904                   came_from[neighbor] = current
    72     72.2 MiB      0.0 MiB        1904                   g_score[neighbor] = temp_g_score
    73     72.2 MiB      0.0 MiB        1904                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     72.2 MiB      0.0 MiB        1904                   if neighbor not in open_set_hash:
    75     72.2 MiB      0.0 MiB        1904                       count += 1
    76     72.2 MiB      0.0 MiB        1904                       open_set.put((f_score[neighbor], count, neighbor))
    77     72.2 MiB      0.0 MiB        1904                       open_set_hash.add(neighbor)
    78                                                             
    79     72.2 MiB      0.0 MiB        1673           if draw is not None:
    80                                                     draw()
    81                                         
    82     72.2 MiB      0.0 MiB        1673           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.6 MiB     96.6 MiB           1   @profile(stream=open('logs/A*/obstacle_density/0.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.2 MiB   -564.1 MiB         257       for row in grid:
    30     99.2 MiB -144791.8 MiB       65792           for spot in row:
    31     99.2 MiB -144231.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     88.5 MiB    -10.7 MiB           1       count = 0
    34     88.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     88.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     88.5 MiB      0.0 MiB           1       came_from = {}
    37     90.4 MiB -51815.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     90.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     97.0 MiB      6.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     97.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     97.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     97.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     97.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     97.1 MiB      0.0 MiB          38       while not open_set.empty():
    47     97.1 MiB      0.0 MiB          38           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     97.1 MiB      0.0 MiB          38           current = open_set.get()[2]
    53     97.1 MiB      0.0 MiB          38           open_set_hash.remove(current)
    54                                         
    55     97.1 MiB      0.0 MiB          38           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     97.1 MiB      0.0 MiB          38           if current == end:
    60     97.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     97.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     97.1 MiB      0.1 MiB         333           for neighbor in current.neighbors:
    65     97.1 MiB      0.0 MiB         296               if current.row != neighbor.row and current.col != neighbor.col:
    66     97.1 MiB      0.0 MiB         148                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     97.1 MiB      0.0 MiB         148                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     97.1 MiB      0.0 MiB         296               if temp_g_score < g_score[neighbor]:
    71     97.1 MiB      0.0 MiB         116                   came_from[neighbor] = current
    72     97.1 MiB      0.0 MiB         116                   g_score[neighbor] = temp_g_score
    73     97.1 MiB      0.0 MiB         116                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     97.1 MiB      0.0 MiB         116                   if neighbor not in open_set_hash:
    75     97.1 MiB      0.0 MiB         116                       count += 1
    76     97.1 MiB      0.0 MiB         116                       open_set.put((f_score[neighbor], count, neighbor))
    77     97.1 MiB      0.0 MiB         116                       open_set_hash.add(neighbor)
    78                                                             
    79     97.1 MiB      0.0 MiB          37           if draw is not None:
    80                                                     draw()
    81                                         
    82     97.1 MiB      0.0 MiB          37           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.0 MiB    101.0 MiB           1   @profile(stream=open('logs/A*/obstacle_density/0.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.0 MiB  -1693.3 MiB         257       for row in grid:
    30    101.0 MiB -431164.1 MiB       65792           for spot in row:
    31    101.0 MiB -429488.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     73.1 MiB    -27.9 MiB           1       count = 0
    34     73.4 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     73.6 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     73.6 MiB      0.0 MiB           1       came_from = {}
    37     75.4 MiB -147460.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     74.9 MiB     -0.5 MiB           1       g_score[start] = 0
    39     76.0 MiB -270787.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     72.1 MiB     -3.9 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     72.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     72.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     72.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     80.1 MiB      0.0 MiB        2533       while not open_set.empty():
    47     80.1 MiB      0.0 MiB        2533           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     80.1 MiB      0.0 MiB        2533           current = open_set.get()[2]
    53     80.1 MiB      0.0 MiB        2533           open_set_hash.remove(current)
    54                                         
    55     80.1 MiB      0.0 MiB        2533           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     80.1 MiB      0.0 MiB        2533           if current == end:
    60     80.1 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     80.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     80.1 MiB      1.3 MiB       22788           for neighbor in current.neighbors:
    65     80.1 MiB      4.4 MiB       20256               if current.row != neighbor.row and current.col != neighbor.col:
    66     80.1 MiB      0.0 MiB       10128                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     80.1 MiB      0.0 MiB       10128                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     80.1 MiB      0.0 MiB       20256               if temp_g_score < g_score[neighbor]:
    71     80.1 MiB      0.4 MiB        3161                   came_from[neighbor] = current
    72     80.1 MiB      0.0 MiB        3161                   g_score[neighbor] = temp_g_score
    73     80.1 MiB      0.0 MiB        3161                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     80.1 MiB      0.0 MiB        3161                   if neighbor not in open_set_hash:
    75     80.1 MiB      0.0 MiB        3161                       count += 1
    76     80.1 MiB      1.8 MiB        3161                       open_set.put((f_score[neighbor], count, neighbor))
    77     80.1 MiB      0.0 MiB        3161                       open_set_hash.add(neighbor)
    78                                                             
    79     80.1 MiB      0.0 MiB        2532           if draw is not None:
    80                                                     draw()
    81                                         
    82     80.1 MiB      0.0 MiB        2532           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.5 MiB    106.5 MiB           1   @profile(stream=open('logs/A*/obstacle_density/10.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.5 MiB  -1049.6 MiB         257       for row in grid:
    30    106.5 MiB -268310.2 MiB       65792           for spot in row:
    31    106.5 MiB -267268.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.8 MiB    -10.6 MiB           1       count = 0
    34     95.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.8 MiB      0.0 MiB           1       came_from = {}
    37     97.8 MiB -156759.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     94.9 MiB     -2.9 MiB           1       g_score[start] = 0
    39     98.4 MiB -12773.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     98.4 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     98.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     98.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     98.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     98.4 MiB      0.0 MiB          83       while not open_set.empty():
    47     98.4 MiB      0.0 MiB          83           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     98.4 MiB      0.0 MiB          83           current = open_set.get()[2]
    53     98.4 MiB      0.0 MiB          83           open_set_hash.remove(current)
    54                                         
    55     98.4 MiB      0.0 MiB          83           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     98.4 MiB      0.0 MiB          83           if current == end:
    60     98.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     98.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     98.4 MiB      0.0 MiB         738           for neighbor in current.neighbors:
    65     98.4 MiB      0.0 MiB         656               if current.row != neighbor.row and current.col != neighbor.col:
    66     98.4 MiB      0.0 MiB         328                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     98.4 MiB      0.0 MiB         328                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     98.4 MiB      0.0 MiB         656               if temp_g_score < g_score[neighbor]:
    71     98.4 MiB      0.0 MiB         251                   came_from[neighbor] = current
    72     98.4 MiB      0.0 MiB         251                   g_score[neighbor] = temp_g_score
    73     98.4 MiB      0.0 MiB         251                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     98.4 MiB      0.0 MiB         251                   if neighbor not in open_set_hash:
    75     98.4 MiB      0.0 MiB         251                       count += 1
    76     98.4 MiB      0.0 MiB         251                       open_set.put((f_score[neighbor], count, neighbor))
    77     98.4 MiB      0.0 MiB         251                       open_set_hash.add(neighbor)
    78                                                             
    79     98.4 MiB      0.0 MiB          82           if draw is not None:
    80                                                     draw()
    81                                         
    82     98.4 MiB      0.0 MiB          82           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.7 MiB    104.7 MiB           1   @profile(stream=open('logs/A*/obstacle_density/20.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.7 MiB   -943.2 MiB         257       for row in grid:
    30    104.7 MiB -241417.5 MiB       65792           for spot in row:
    31    104.7 MiB -240478.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.5 MiB     -6.2 MiB           1       count = 0
    34     98.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.6 MiB      0.0 MiB           1       came_from = {}
    37    101.2 MiB -425842.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.0 MiB    -25.3 MiB           1       g_score[start] = 0
    39     82.3 MiB  -7622.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     81.8 MiB     -0.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     81.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     81.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     81.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     81.9 MiB -143960.8 MiB        5676       while not open_set.empty():
    47     81.9 MiB -143960.8 MiB        5676           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     81.9 MiB -143960.8 MiB        5676           current = open_set.get()[2]
    53     81.9 MiB -143960.8 MiB        5676           open_set_hash.remove(current)
    54                                         
    55     81.9 MiB -143960.9 MiB        5676           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     81.9 MiB -143961.1 MiB        5676           if current == end:
    60     47.8 MiB    -34.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     48.2 MiB      0.4 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     81.9 MiB -1295475.9 MiB       51075           for neighbor in current.neighbors:
    65     81.9 MiB -1151520.8 MiB       45400               if current.row != neighbor.row and current.col != neighbor.col:
    66     81.9 MiB -575801.6 MiB       22700                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     81.9 MiB -575723.4 MiB       22700                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     81.9 MiB -1151537.4 MiB       45400               if temp_g_score < g_score[neighbor]:
    71     81.9 MiB -152760.6 MiB        6110                   came_from[neighbor] = current
    72     81.9 MiB -152760.6 MiB        6110                   g_score[neighbor] = temp_g_score
    73     81.9 MiB -152760.5 MiB        6110                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     81.9 MiB -152762.8 MiB        6110                   if neighbor not in open_set_hash:
    75     81.9 MiB -152774.2 MiB        6110                       count += 1
    76     81.9 MiB -152774.1 MiB        6110                       open_set.put((f_score[neighbor], count, neighbor))
    77     81.9 MiB -152774.0 MiB        6110                       open_set_hash.add(neighbor)
    78                                                             
    79     81.9 MiB -143960.8 MiB        5675           if draw is not None:
    80                                                     draw()
    81                                         
    82     81.9 MiB -143960.8 MiB        5675           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.8 MiB    102.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.8 MiB   -346.0 MiB         257       for row in grid:
    30    102.8 MiB -87610.3 MiB       65792           for spot in row:
    31    102.8 MiB -87271.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.2 MiB     -7.6 MiB           1       count = 0
    34     95.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.2 MiB      0.0 MiB           1       came_from = {}
    37     97.7 MiB -28847.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.7 MiB      0.0 MiB           1       g_score[start] = 0
    39    102.7 MiB      5.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.8 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.4 MiB    -74.2 MiB         990       while not open_set.empty():
    47    103.4 MiB    -74.2 MiB         990           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.4 MiB    -74.2 MiB         990           current = open_set.get()[2]
    53    103.4 MiB    -74.2 MiB         990           open_set_hash.remove(current)
    54                                         
    55    103.4 MiB    -74.2 MiB         990           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.4 MiB    -74.2 MiB         990           if current == end:
    60    103.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    103.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.4 MiB   -666.2 MiB        8901           for neighbor in current.neighbors:
    65    103.4 MiB   -591.4 MiB        7912               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.4 MiB   -296.1 MiB        3956                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.4 MiB   -295.8 MiB        3956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.4 MiB   -591.9 MiB        7912               if temp_g_score < g_score[neighbor]:
    71    103.4 MiB    -88.2 MiB        1226                   came_from[neighbor] = current
    72    103.4 MiB    -88.3 MiB        1226                   g_score[neighbor] = temp_g_score
    73    103.4 MiB    -88.3 MiB        1226                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.4 MiB    -88.3 MiB        1226                   if neighbor not in open_set_hash:
    75    103.4 MiB    -88.3 MiB        1226                       count += 1
    76    103.4 MiB    -88.2 MiB        1226                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.4 MiB    -88.3 MiB        1226                       open_set_hash.add(neighbor)
    78                                                             
    79    103.4 MiB    -74.2 MiB         989           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.4 MiB    -74.2 MiB         989           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.2 MiB    106.2 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.2 MiB  -1793.0 MiB         257       for row in grid:
    30    106.2 MiB -460063.1 MiB       65792           for spot in row:
    31    106.2 MiB -458278.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     89.1 MiB    -17.1 MiB           1       count = 0
    34     89.4 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     89.5 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     89.5 MiB      0.0 MiB           1       came_from = {}
    37     95.9 MiB      6.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     95.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     96.6 MiB -2009288.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     62.4 MiB    -34.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     62.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     62.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     62.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.0 MiB   -643.6 MiB        2010       while not open_set.empty():
    47     63.0 MiB   -643.6 MiB        2010           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.0 MiB   -643.6 MiB        2010           current = open_set.get()[2]
    53     63.0 MiB   -643.6 MiB        2010           open_set_hash.remove(current)
    54                                         
    55     63.0 MiB   -643.6 MiB        2010           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.0 MiB   -643.6 MiB        2010           if current == end:
    60     62.6 MiB     -0.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     62.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.0 MiB  -5790.5 MiB       18081           for neighbor in current.neighbors:
    65     63.0 MiB  -5146.5 MiB       16072               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.0 MiB  -2573.8 MiB        8036                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.0 MiB  -2573.0 MiB        8036                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.0 MiB  -5147.5 MiB       16072               if temp_g_score < g_score[neighbor]:
    71     63.0 MiB   -732.8 MiB        2336                   came_from[neighbor] = current
    72     63.0 MiB   -732.8 MiB        2336                   g_score[neighbor] = temp_g_score
    73     63.0 MiB   -732.8 MiB        2336                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.0 MiB   -732.8 MiB        2336                   if neighbor not in open_set_hash:
    75     63.0 MiB   -732.8 MiB        2336                       count += 1
    76     63.0 MiB   -732.8 MiB        2336                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.0 MiB   -732.7 MiB        2336                       open_set_hash.add(neighbor)
    78                                                             
    79     63.0 MiB   -643.6 MiB        2009           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.0 MiB   -643.6 MiB        2009           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    101.3 MiB    101.3 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    101.3 MiB   -603.6 MiB         257       for row in grid:
    30    101.3 MiB -154006.2 MiB       65792           for spot in row:
    31    101.3 MiB -153407.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.2 MiB     -7.0 MiB           1       count = 0
    34     94.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.2 MiB      0.0 MiB           1       came_from = {}
    37     96.6 MiB -52778.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     96.6 MiB      0.0 MiB           1       g_score[start] = 0
    39    101.2 MiB      4.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.4 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.7 MiB    -83.8 MiB        1332       while not open_set.empty():
    47    101.7 MiB    -83.8 MiB        1332           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.7 MiB    -83.8 MiB        1332           current = open_set.get()[2]
    53    101.7 MiB    -83.8 MiB        1332           open_set_hash.remove(current)
    54                                         
    55    101.7 MiB    -83.8 MiB        1332           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.7 MiB    -83.8 MiB        1332           if current == end:
    60    101.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.7 MiB   -754.2 MiB       11979           for neighbor in current.neighbors:
    65    101.7 MiB   -670.2 MiB       10648               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.7 MiB   -335.5 MiB        5324                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.7 MiB   -335.0 MiB        5324                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.7 MiB   -670.5 MiB       10648               if temp_g_score < g_score[neighbor]:
    71    101.7 MiB    -97.9 MiB        1550                   came_from[neighbor] = current
    72    101.7 MiB    -97.9 MiB        1550                   g_score[neighbor] = temp_g_score
    73    101.7 MiB    -97.9 MiB        1550                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.7 MiB    -97.9 MiB        1550                   if neighbor not in open_set_hash:
    75    101.7 MiB    -97.9 MiB        1550                       count += 1
    76    101.7 MiB    -97.9 MiB        1550                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.7 MiB    -97.9 MiB        1550                       open_set_hash.add(neighbor)
    78                                                             
    79    101.7 MiB    -83.8 MiB        1331           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.7 MiB    -83.8 MiB        1331           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.0 MiB    105.0 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.0 MiB  -3688.1 MiB         257       for row in grid:
    30    105.0 MiB -942180.4 MiB       65792           for spot in row:
    31    105.0 MiB -938523.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     61.5 MiB    -43.6 MiB           1       count = 0
    34     61.5 MiB      0.1 MiB           1       open_set = PriorityQueue()
    35     61.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     61.6 MiB      0.0 MiB           1       came_from = {}
    37     63.8 MiB -102946.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     63.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     66.9 MiB -47478.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     66.9 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     66.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     66.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     66.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     67.2 MiB  -9315.0 MiB        7480       while not open_set.empty():
    47     67.2 MiB  -9315.0 MiB        7480           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     67.2 MiB  -9315.0 MiB        7480           current = open_set.get()[2]
    53     67.2 MiB  -9315.0 MiB        7480           open_set_hash.remove(current)
    54                                         
    55     67.2 MiB  -9315.0 MiB        7480           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     67.2 MiB  -9315.0 MiB        7480           if current == end:
    60     64.1 MiB     -3.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     64.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     67.2 MiB -83820.2 MiB       67311           for neighbor in current.neighbors:
    65     67.2 MiB -74505.5 MiB       59832               if current.row != neighbor.row and current.col != neighbor.col:
    66     67.2 MiB -37257.2 MiB       29916                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     67.2 MiB -37250.5 MiB       29916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     67.2 MiB -74507.9 MiB       59832               if temp_g_score < g_score[neighbor]:
    71     67.2 MiB  -9880.5 MiB        8054                   came_from[neighbor] = current
    72     67.2 MiB  -9880.9 MiB        8054                   g_score[neighbor] = temp_g_score
    73     67.2 MiB  -9881.3 MiB        8054                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     67.2 MiB  -9881.4 MiB        8054                   if neighbor not in open_set_hash:
    75     67.2 MiB  -9881.4 MiB        8054                       count += 1
    76     67.2 MiB  -9881.3 MiB        8054                       open_set.put((f_score[neighbor], count, neighbor))
    77     67.2 MiB  -9881.3 MiB        8054                       open_set_hash.add(neighbor)
    78                                                             
    79     67.2 MiB  -9315.0 MiB        7479           if draw is not None:
    80                                                     draw()
    81                                         
    82     67.2 MiB  -9315.0 MiB        7479           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    102.0 MiB    102.0 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    102.0 MiB   -347.8 MiB         257       for row in grid:
    30    102.0 MiB -89126.7 MiB       65792           for spot in row:
    31    102.0 MiB -88780.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.4 MiB     -1.7 MiB           1       count = 0
    34    100.4 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.4 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.4 MiB      0.0 MiB           1       came_from = {}
    37    104.9 MiB  -4756.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.8 MiB     -0.0 MiB           1       g_score[start] = 0
    39    106.4 MiB -115991.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    101.7 MiB     -4.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    101.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    101.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    101.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    101.7 MiB      0.0 MiB         115       while not open_set.empty():
    47    101.7 MiB      0.0 MiB         115           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    101.7 MiB      0.0 MiB         115           current = open_set.get()[2]
    53    101.7 MiB      0.0 MiB         115           open_set_hash.remove(current)
    54                                         
    55    101.7 MiB      0.0 MiB         115           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    101.7 MiB      0.0 MiB         115           if current == end:
    60    101.7 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    101.7 MiB      0.0 MiB        1026           for neighbor in current.neighbors:
    65    101.7 MiB      0.0 MiB         912               if current.row != neighbor.row and current.col != neighbor.col:
    66    101.7 MiB      0.0 MiB         456                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    101.7 MiB      0.0 MiB         456                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    101.7 MiB      0.0 MiB         912               if temp_g_score < g_score[neighbor]:
    71    101.7 MiB      0.0 MiB         179                   came_from[neighbor] = current
    72    101.7 MiB      0.0 MiB         179                   g_score[neighbor] = temp_g_score
    73    101.7 MiB      0.0 MiB         179                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    101.7 MiB      0.0 MiB         179                   if neighbor not in open_set_hash:
    75    101.7 MiB      0.0 MiB         179                       count += 1
    76    101.7 MiB      0.0 MiB         179                       open_set.put((f_score[neighbor], count, neighbor))
    77    101.7 MiB      0.0 MiB         179                       open_set_hash.add(neighbor)
    78                                                             
    79    101.7 MiB      0.0 MiB         114           if draw is not None:
    80                                                     draw()
    81                                         
    82    101.7 MiB      0.0 MiB         114           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.6 MiB    109.6 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.6 MiB   -542.6 MiB         257       for row in grid:
    30    109.6 MiB -138690.3 MiB       65792           for spot in row:
    31    109.6 MiB -138152.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    104.1 MiB     -5.5 MiB           1       count = 0
    34    104.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    104.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    104.1 MiB      0.0 MiB           1       came_from = {}
    37    105.9 MiB  -8414.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.9 MiB      0.0 MiB           1       g_score[start] = 0
    39    107.5 MiB -163188.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    104.7 MiB     -2.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    104.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    104.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44    104.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.7 MiB -61901.2 MiB        3588       while not open_set.empty():
    47    104.7 MiB -61901.8 MiB        3588           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.7 MiB -61903.0 MiB        3588           current = open_set.get()[2]
    53    104.7 MiB -61907.3 MiB        3588           open_set_hash.remove(current)
    54                                         
    55    104.7 MiB -61908.2 MiB        3588           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.7 MiB -61909.2 MiB        3588           if current == end:
    60     63.2 MiB    -41.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.7 MiB -556949.6 MiB       32283           for neighbor in current.neighbors:
    65    104.7 MiB -495056.8 MiB       28696               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.7 MiB -247559.8 MiB       14348                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.7 MiB -247504.2 MiB       14348                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.7 MiB -495069.7 MiB       28696               if temp_g_score < g_score[neighbor]:
    71    104.7 MiB -66316.5 MiB        3926                   came_from[neighbor] = current
    72    104.7 MiB -66317.0 MiB        3926                   g_score[neighbor] = temp_g_score
    73    104.7 MiB -66317.5 MiB        3926                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.7 MiB -66318.1 MiB        3926                   if neighbor not in open_set_hash:
    75    104.7 MiB -66318.5 MiB        3926                       count += 1
    76    104.7 MiB -66319.4 MiB        3926                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.7 MiB -66320.0 MiB        3926                       open_set_hash.add(neighbor)
    78                                                             
    79    104.7 MiB -61899.7 MiB        3587           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.7 MiB -61900.6 MiB        3587           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.9 MiB    104.9 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.9 MiB  -5367.0 MiB         257       for row in grid:
    30    104.9 MiB -1373888.5 MiB       65792           for spot in row:
    31    104.9 MiB -1368557.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     58.0 MiB    -46.9 MiB           1       count = 0
    34     58.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     58.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     58.0 MiB      0.0 MiB           1       came_from = {}
    37     61.3 MiB -129970.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     58.0 MiB     -3.3 MiB           1       g_score[start] = 0
    39     63.1 MiB  -4438.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     63.2 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     63.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     63.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     63.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.5 MiB   -393.7 MiB        1170       while not open_set.empty():
    47     63.5 MiB   -393.7 MiB        1170           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.5 MiB   -393.7 MiB        1170           current = open_set.get()[2]
    53     63.5 MiB   -393.7 MiB        1170           open_set_hash.remove(current)
    54                                         
    55     63.5 MiB   -393.7 MiB        1170           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.5 MiB   -393.7 MiB        1170           if current == end:
    60     63.2 MiB     -0.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.5 MiB  -3543.8 MiB       10521           for neighbor in current.neighbors:
    65     63.5 MiB  -3150.1 MiB        9352               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.5 MiB  -1575.1 MiB        4676                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.5 MiB  -1575.0 MiB        4676                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.5 MiB  -3150.7 MiB        9352               if temp_g_score < g_score[neighbor]:
    71     63.5 MiB   -483.2 MiB        1464                   came_from[neighbor] = current
    72     63.5 MiB   -483.3 MiB        1464                   g_score[neighbor] = temp_g_score
    73     63.5 MiB   -483.3 MiB        1464                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.5 MiB   -483.3 MiB        1464                   if neighbor not in open_set_hash:
    75     63.5 MiB   -483.3 MiB        1464                       count += 1
    76     63.5 MiB   -483.2 MiB        1464                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.5 MiB   -483.2 MiB        1464                       open_set_hash.add(neighbor)
    78                                                             
    79     63.5 MiB   -393.7 MiB        1169           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.5 MiB   -393.7 MiB        1169           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    107.7 MiB    107.7 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    107.7 MiB    -75.9 MiB         257       for row in grid:
    30    107.7 MiB -19477.8 MiB       65792           for spot in row:
    31    107.7 MiB -19402.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    107.1 MiB     -0.7 MiB           1       count = 0
    34    107.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    107.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    107.1 MiB      0.0 MiB           1       came_from = {}
    37    110.0 MiB -24397.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    110.0 MiB      0.0 MiB           1       g_score[start] = 0
    39    113.1 MiB      3.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    113.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    113.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    113.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    113.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    113.1 MiB  -1091.0 MiB        1264       while not open_set.empty():
    47    113.1 MiB  -1091.0 MiB        1264           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    113.1 MiB  -1091.0 MiB        1264           current = open_set.get()[2]
    53    113.1 MiB  -1091.0 MiB        1264           open_set_hash.remove(current)
    54                                         
    55    113.1 MiB  -1093.6 MiB        1264           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    113.1 MiB  -1093.6 MiB        1264           if current == end:
    60    108.2 MiB     -4.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    108.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    113.1 MiB  -9809.6 MiB       11367           for neighbor in current.neighbors:
    65    113.1 MiB  -8719.0 MiB       10104               if current.row != neighbor.row and current.col != neighbor.col:
    66    113.1 MiB  -4363.5 MiB        5052                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    113.1 MiB  -4355.8 MiB        5052                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    113.1 MiB  -8719.7 MiB       10104               if temp_g_score < g_score[neighbor]:
    71    113.1 MiB  -1285.1 MiB        1484                   came_from[neighbor] = current
    72    113.1 MiB  -1285.2 MiB        1484                   g_score[neighbor] = temp_g_score
    73    113.1 MiB  -1285.4 MiB        1484                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    113.1 MiB  -1285.4 MiB        1484                   if neighbor not in open_set_hash:
    75    113.1 MiB  -1285.4 MiB        1484                       count += 1
    76    113.1 MiB  -1285.4 MiB        1484                       open_set.put((f_score[neighbor], count, neighbor))
    77    113.1 MiB  -1285.4 MiB        1484                       open_set_hash.add(neighbor)
    78                                                             
    79    113.1 MiB  -1091.0 MiB        1263           if draw is not None:
    80                                                     draw()
    81                                         
    82    113.1 MiB  -1091.0 MiB        1263           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    108.8 MiB    108.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    108.8 MiB   -631.0 MiB         257       for row in grid:
    30    108.8 MiB -161608.9 MiB       65792           for spot in row:
    31    108.8 MiB -160984.4 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.6 MiB     -7.2 MiB           1       count = 0
    34    101.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.6 MiB      0.0 MiB           1       came_from = {}
    37    105.3 MiB   -310.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    105.3 MiB      0.0 MiB           1       g_score[start] = 0
    39    109.0 MiB      3.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    109.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    109.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    109.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    109.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    109.1 MiB -30250.3 MiB       12669       while not open_set.empty():
    47    109.1 MiB -30251.4 MiB       12669           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    109.1 MiB -30251.4 MiB       12669           current = open_set.get()[2]
    53    109.1 MiB -30251.4 MiB       12669           open_set_hash.remove(current)
    54                                         
    55    109.1 MiB -30251.4 MiB       12669           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    109.1 MiB -30251.5 MiB       12669           if current == end:
    60    101.4 MiB     -7.6 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    109.1 MiB -272245.3 MiB      114009           for neighbor in current.neighbors:
    65    109.1 MiB -241994.9 MiB      101341               if current.row != neighbor.row and current.col != neighbor.col:
    66    109.1 MiB -121008.8 MiB       50670                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    109.1 MiB -120988.3 MiB       50671                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    109.1 MiB -242003.9 MiB      101341               if temp_g_score < g_score[neighbor]:
    71    109.1 MiB -31528.4 MiB       13322                   came_from[neighbor] = current
    72    109.1 MiB -31528.6 MiB       13322                   g_score[neighbor] = temp_g_score
    73    109.1 MiB -31529.3 MiB       13322                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    109.1 MiB -31529.3 MiB       13322                   if neighbor not in open_set_hash:
    75    109.1 MiB -31529.3 MiB       13322                       count += 1
    76    109.1 MiB -31525.8 MiB       13322                       open_set.put((f_score[neighbor], count, neighbor))
    77    109.1 MiB -31525.8 MiB       13322                       open_set_hash.add(neighbor)
    78                                                             
    79    109.1 MiB -30250.1 MiB       12668           if draw is not None:
    80                                                     draw()
    81                                         
    82    109.1 MiB -30250.2 MiB       12668           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.5 MiB    106.5 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.5 MiB   -726.9 MiB         257       for row in grid:
    30    106.5 MiB -185749.8 MiB       65792           for spot in row:
    31    106.5 MiB -185029.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.8 MiB     -6.6 MiB           1       count = 0
    34     99.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.8 MiB      0.0 MiB           1       came_from = {}
    37    102.2 MiB  -1574.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    102.2 MiB      0.0 MiB           1       g_score[start] = 0
    39    106.3 MiB      4.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    106.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    106.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    106.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    106.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    106.3 MiB -64570.2 MiB        8856       while not open_set.empty():
    47    106.3 MiB -64570.3 MiB        8856           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    106.3 MiB -64570.6 MiB        8856           current = open_set.get()[2]
    53    106.3 MiB -64620.5 MiB        8856           open_set_hash.remove(current)
    54                                         
    55    106.3 MiB -64620.5 MiB        8856           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    106.3 MiB -64620.5 MiB        8856           if current == end:
    60     58.6 MiB    -47.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     58.8 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    106.3 MiB -581093.8 MiB       79695           for neighbor in current.neighbors:
    65    106.3 MiB -516537.0 MiB       70840               if current.row != neighbor.row and current.col != neighbor.col:
    66    106.3 MiB -258242.4 MiB       35420                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    106.3 MiB -258297.3 MiB       35420                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    106.3 MiB -516541.2 MiB       70840               if temp_g_score < g_score[neighbor]:
    71    106.3 MiB -69740.5 MiB        9450                   came_from[neighbor] = current
    72    106.3 MiB -69740.5 MiB        9450                   g_score[neighbor] = temp_g_score
    73    106.3 MiB -69740.5 MiB        9450                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    106.3 MiB -69740.5 MiB        9450                   if neighbor not in open_set_hash:
    75    106.3 MiB -69740.5 MiB        9450                       count += 1
    76    106.3 MiB -69719.7 MiB        9450                       open_set.put((f_score[neighbor], count, neighbor))
    77    106.3 MiB -69719.6 MiB        9450                       open_set_hash.add(neighbor)
    78                                                             
    79    106.3 MiB -64569.8 MiB        8855           if draw is not None:
    80                                                     draw()
    81                                         
    82    106.3 MiB -64570.0 MiB        8855           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    100.8 MiB    100.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    100.8 MiB     -0.2 MiB         257       for row in grid:
    30    100.8 MiB    -46.5 MiB       65792           for spot in row:
    31    100.8 MiB    -46.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    100.7 MiB     -0.0 MiB           1       count = 0
    34    100.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    100.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    100.7 MiB      0.0 MiB           1       came_from = {}
    37    104.1 MiB      3.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.1 MiB      0.0 MiB           1       g_score[start] = 0
    39    107.8 MiB      3.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.8 MiB   -269.7 MiB        3348       while not open_set.empty():
    47    107.8 MiB   -269.7 MiB        3348           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.8 MiB   -269.7 MiB        3348           current = open_set.get()[2]
    53    107.8 MiB   -269.7 MiB        3348           open_set_hash.remove(current)
    54                                         
    55    107.8 MiB   -269.7 MiB        3348           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.8 MiB   -269.7 MiB        3348           if current == end:
    60    107.6 MiB     -0.3 MiB           1               if draw:
    61                                                         end.make_end()
    62    107.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.8 MiB  -2425.1 MiB       30123           for neighbor in current.neighbors:
    65    107.8 MiB  -2155.6 MiB       26776               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.8 MiB  -1077.9 MiB       13388                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.8 MiB  -1077.8 MiB       13388                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.8 MiB  -2155.7 MiB       26776               if temp_g_score < g_score[neighbor]:
    71    107.8 MiB   -293.0 MiB        3676                   came_from[neighbor] = current
    72    107.8 MiB   -293.0 MiB        3676                   g_score[neighbor] = temp_g_score
    73    107.8 MiB   -293.0 MiB        3676                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.8 MiB   -293.0 MiB        3676                   if neighbor not in open_set_hash:
    75    107.8 MiB   -293.0 MiB        3676                       count += 1
    76    107.8 MiB   -293.3 MiB        3676                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.8 MiB   -293.2 MiB        3676                       open_set_hash.add(neighbor)
    78                                                             
    79    107.8 MiB   -269.6 MiB        3347           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.8 MiB   -269.7 MiB        3347           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.9 MiB    105.9 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.9 MiB   -381.2 MiB         257       for row in grid:
    30    105.9 MiB -97680.6 MiB       65792           for spot in row:
    31    105.9 MiB -97300.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    101.9 MiB     -4.0 MiB           1       count = 0
    34    101.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    101.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    101.9 MiB      0.0 MiB           1       came_from = {}
    37    104.4 MiB -35140.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.4 MiB      0.0 MiB           1       g_score[start] = 0
    39    107.1 MiB   -908.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.1 MiB   -663.8 MiB        3157       while not open_set.empty():
    47    107.1 MiB   -663.8 MiB        3157           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.1 MiB   -663.8 MiB        3157           current = open_set.get()[2]
    53    107.1 MiB   -663.8 MiB        3157           open_set_hash.remove(current)
    54                                         
    55    107.1 MiB   -663.8 MiB        3157           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.1 MiB   -663.8 MiB        3157           if current == end:
    60    106.7 MiB     -0.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.1 MiB  -5974.5 MiB       28404           for neighbor in current.neighbors:
    65    107.1 MiB  -5310.8 MiB       25248               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.1 MiB  -2655.4 MiB       12624                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.1 MiB  -2655.4 MiB       12624                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.1 MiB  -5310.8 MiB       25248               if temp_g_score < g_score[neighbor]:
    71    107.1 MiB   -710.9 MiB        3473                   came_from[neighbor] = current
    72    107.1 MiB   -710.9 MiB        3473                   g_score[neighbor] = temp_g_score
    73    107.1 MiB   -710.9 MiB        3473                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.1 MiB   -710.9 MiB        3473                   if neighbor not in open_set_hash:
    75    107.1 MiB   -710.9 MiB        3473                       count += 1
    76    107.1 MiB   -710.9 MiB        3473                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.1 MiB   -710.9 MiB        3473                       open_set_hash.add(neighbor)
    78                                                             
    79    107.1 MiB   -663.8 MiB        3156           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.1 MiB   -663.8 MiB        3156           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.2 MiB    106.2 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.2 MiB  -1460.8 MiB         257       for row in grid:
    30    106.2 MiB -374259.4 MiB       65792           for spot in row:
    31    106.2 MiB -372806.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     97.9 MiB     -8.3 MiB           1       count = 0
    34     97.9 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     97.9 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     97.9 MiB      0.0 MiB           1       came_from = {}
    37     99.3 MiB -55727.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     98.7 MiB     -0.6 MiB           1       g_score[start] = 0
    39    103.8 MiB   -790.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.8 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    104.0 MiB  -2140.3 MiB        2850       while not open_set.empty():
    47    104.0 MiB  -2140.3 MiB        2850           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    104.0 MiB  -2140.5 MiB        2850           current = open_set.get()[2]
    53    104.0 MiB  -2140.7 MiB        2850           open_set_hash.remove(current)
    54                                         
    55    104.0 MiB  -2140.9 MiB        2850           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    104.0 MiB  -2141.0 MiB        2850           if current == end:
    60    101.7 MiB     -2.3 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    104.0 MiB -19258.5 MiB       25641           for neighbor in current.neighbors:
    65    104.0 MiB -17118.3 MiB       22792               if current.row != neighbor.row and current.col != neighbor.col:
    66    104.0 MiB  -8561.1 MiB       11396                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    104.0 MiB  -8558.8 MiB       11396                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    104.0 MiB -17119.8 MiB       22792               if temp_g_score < g_score[neighbor]:
    71    104.0 MiB  -2312.1 MiB        3162                   came_from[neighbor] = current
    72    104.0 MiB  -2312.2 MiB        3162                   g_score[neighbor] = temp_g_score
    73    104.0 MiB  -2312.2 MiB        3162                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    104.0 MiB  -2312.2 MiB        3162                   if neighbor not in open_set_hash:
    75    104.0 MiB  -2312.2 MiB        3162                       count += 1
    76    104.0 MiB  -2312.2 MiB        3162                       open_set.put((f_score[neighbor], count, neighbor))
    77    104.0 MiB  -2312.2 MiB        3162                       open_set_hash.add(neighbor)
    78                                                             
    79    104.0 MiB  -2140.3 MiB        2849           if draw is not None:
    80                                                     draw()
    81                                         
    82    104.0 MiB  -2140.3 MiB        2849           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    103.5 MiB    103.5 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    103.5 MiB   -635.5 MiB         257       for row in grid:
    30    103.5 MiB -162899.3 MiB       65792           for spot in row:
    31    103.5 MiB -162266.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     99.7 MiB     -3.8 MiB           1       count = 0
    34     99.7 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     99.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     99.7 MiB      0.0 MiB           1       came_from = {}
    37    101.6 MiB -1458034.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     67.1 MiB    -34.5 MiB           1       g_score[start] = 0
    39     71.8 MiB  -7666.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     70.3 MiB     -1.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     70.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     70.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     70.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     70.5 MiB   -351.7 MiB        1968       while not open_set.empty():
    47     70.5 MiB   -351.7 MiB        1968           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     70.5 MiB   -351.7 MiB        1968           current = open_set.get()[2]
    53     70.5 MiB   -351.7 MiB        1968           open_set_hash.remove(current)
    54                                         
    55     70.5 MiB   -351.7 MiB        1968           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     70.5 MiB   -351.7 MiB        1968           if current == end:
    60     70.5 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     70.6 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     70.5 MiB  -3165.0 MiB       17703           for neighbor in current.neighbors:
    65     70.5 MiB  -2813.1 MiB       15736               if current.row != neighbor.row and current.col != neighbor.col:
    66     70.5 MiB  -1406.7 MiB        7868                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     70.5 MiB  -1406.5 MiB        7868                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     70.5 MiB  -2813.3 MiB       15736               if temp_g_score < g_score[neighbor]:
    71     70.5 MiB   -403.8 MiB        2276                   came_from[neighbor] = current
    72     70.5 MiB   -403.8 MiB        2276                   g_score[neighbor] = temp_g_score
    73     70.5 MiB   -403.9 MiB        2276                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     70.5 MiB   -403.9 MiB        2276                   if neighbor not in open_set_hash:
    75     70.5 MiB   -403.9 MiB        2276                       count += 1
    76     70.5 MiB   -403.8 MiB        2276                       open_set.put((f_score[neighbor], count, neighbor))
    77     70.5 MiB   -403.8 MiB        2276                       open_set_hash.add(neighbor)
    78                                                             
    79     70.5 MiB   -351.7 MiB        1967           if draw is not None:
    80                                                     draw()
    81                                         
    82     70.5 MiB   -351.7 MiB        1967           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    105.2 MiB    105.2 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    105.2 MiB   -291.0 MiB         257       for row in grid:
    30    105.2 MiB -74108.1 MiB       65792           for spot in row:
    31    105.2 MiB -73819.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33    102.0 MiB     -3.2 MiB           1       count = 0
    34    102.0 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35    102.0 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36    102.0 MiB      0.0 MiB           1       came_from = {}
    37    105.5 MiB -10892.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    104.5 MiB     -1.0 MiB           1       g_score[start] = 0
    39    107.0 MiB  -1270.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    107.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    107.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    107.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44    107.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    107.0 MiB   -998.7 MiB        2352       while not open_set.empty():
    47    107.0 MiB   -998.7 MiB        2352           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    107.0 MiB   -998.7 MiB        2352           current = open_set.get()[2]
    53    107.0 MiB   -998.7 MiB        2352           open_set_hash.remove(current)
    54                                         
    55    107.0 MiB   -998.7 MiB        2352           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    107.0 MiB   -998.7 MiB        2352           if current == end:
    60    106.0 MiB     -0.9 MiB           1               if draw:
    61                                                         end.make_end()
    62    106.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    107.0 MiB  -8984.3 MiB       21159           for neighbor in current.neighbors:
    65    107.0 MiB  -7985.6 MiB       18808               if current.row != neighbor.row and current.col != neighbor.col:
    66    107.0 MiB  -3994.6 MiB        9404                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    107.0 MiB  -3991.6 MiB        9404                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    107.0 MiB  -7986.6 MiB       18808               if temp_g_score < g_score[neighbor]:
    71    107.0 MiB  -1110.4 MiB        2658                   came_from[neighbor] = current
    72    107.0 MiB  -1110.5 MiB        2658                   g_score[neighbor] = temp_g_score
    73    107.0 MiB  -1110.5 MiB        2658                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    107.0 MiB  -1110.5 MiB        2658                   if neighbor not in open_set_hash:
    75    107.0 MiB  -1110.5 MiB        2658                       count += 1
    76    107.0 MiB  -1110.5 MiB        2658                       open_set.put((f_score[neighbor], count, neighbor))
    77    107.0 MiB  -1110.4 MiB        2658                       open_set_hash.add(neighbor)
    78                                                             
    79    107.0 MiB   -998.7 MiB        2351           if draw is not None:
    80                                                     draw()
    81                                         
    82    107.0 MiB   -998.7 MiB        2351           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    111.5 MiB    111.5 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    111.5 MiB  -5087.3 MiB         257       for row in grid:
    30    111.5 MiB -1301012.2 MiB       65792           for spot in row:
    31    111.5 MiB -1295953.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     61.0 MiB    -50.6 MiB           1       count = 0
    34     61.1 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     61.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     61.1 MiB      0.0 MiB           1       came_from = {}
    37     63.6 MiB -410036.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     55.8 MiB     -7.8 MiB           1       g_score[start] = 0
    39     60.0 MiB -17754.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     60.0 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     60.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     60.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     60.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     63.2 MiB   -386.2 MiB        3807       while not open_set.empty():
    47     63.2 MiB   -386.2 MiB        3807           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     63.2 MiB   -386.2 MiB        3807           current = open_set.get()[2]
    53     63.2 MiB   -386.2 MiB        3807           open_set_hash.remove(current)
    54                                         
    55     63.2 MiB   -386.2 MiB        3807           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     63.2 MiB   -386.2 MiB        3807           if current == end:
    60     63.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     63.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     63.2 MiB  -3475.4 MiB       34254           for neighbor in current.neighbors:
    65     63.2 MiB  -3087.7 MiB       30448               if current.row != neighbor.row and current.col != neighbor.col:
    66     63.2 MiB  -1544.8 MiB       15224                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     63.2 MiB  -1544.5 MiB       15224                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     63.2 MiB  -3089.2 MiB       30448               if temp_g_score < g_score[neighbor]:
    71     63.2 MiB   -444.6 MiB        4423                   came_from[neighbor] = current
    72     63.2 MiB   -444.8 MiB        4423                   g_score[neighbor] = temp_g_score
    73     63.2 MiB   -444.8 MiB        4423                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     63.2 MiB   -444.8 MiB        4423                   if neighbor not in open_set_hash:
    75     63.2 MiB   -444.8 MiB        4423                       count += 1
    76     63.2 MiB   -443.1 MiB        4423                       open_set.put((f_score[neighbor], count, neighbor))
    77     63.2 MiB   -444.6 MiB        4423                       open_set_hash.add(neighbor)
    78                                                             
    79     63.2 MiB   -386.2 MiB        3806           if draw is not None:
    80                                                     draw()
    81                                         
    82     63.2 MiB   -386.2 MiB        3806           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    106.4 MiB    106.4 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    106.4 MiB  -1472.8 MiB         257       for row in grid:
    30    106.4 MiB -377338.7 MiB       65792           for spot in row:
    31    106.4 MiB -375869.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.2 MiB     -8.2 MiB           1       count = 0
    34     98.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.2 MiB      0.0 MiB           1       came_from = {}
    37    102.2 MiB -17588.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     99.8 MiB     -2.4 MiB           1       g_score[start] = 0
    39    103.3 MiB -13946.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    103.1 MiB     -0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    103.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    103.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    103.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    103.2 MiB     -1.2 MiB          30       while not open_set.empty():
    47    103.2 MiB     -1.2 MiB          30           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    103.2 MiB     -1.2 MiB          30           current = open_set.get()[2]
    53    103.2 MiB     -1.3 MiB          30           open_set_hash.remove(current)
    54                                         
    55    103.2 MiB     -1.3 MiB          30           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    103.2 MiB     -1.3 MiB          30           if current == end:
    60    102.8 MiB     -0.4 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    103.2 MiB     -9.0 MiB         261           for neighbor in current.neighbors:
    65    103.2 MiB     -7.9 MiB         232               if current.row != neighbor.row and current.col != neighbor.col:
    66    103.2 MiB     -4.3 MiB         116                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    103.2 MiB     -3.7 MiB         116                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    103.2 MiB     -8.1 MiB         232               if temp_g_score < g_score[neighbor]:
    71    103.2 MiB     -2.1 MiB          74                   came_from[neighbor] = current
    72    103.2 MiB     -2.1 MiB          74                   g_score[neighbor] = temp_g_score
    73    103.2 MiB     -2.1 MiB          74                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    103.2 MiB     -2.1 MiB          74                   if neighbor not in open_set_hash:
    75    103.2 MiB     -2.1 MiB          74                       count += 1
    76    103.2 MiB     -2.2 MiB          74                       open_set.put((f_score[neighbor], count, neighbor))
    77    103.2 MiB     -2.2 MiB          74                       open_set_hash.add(neighbor)
    78                                                             
    79    103.2 MiB     -1.2 MiB          29           if draw is not None:
    80                                                     draw()
    81                                         
    82    103.2 MiB     -1.2 MiB          29           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    109.3 MiB    109.3 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    109.3 MiB  -7635.0 MiB         257       for row in grid:
    30    109.3 MiB -1951870.3 MiB       65792           for spot in row:
    31    109.3 MiB -1944271.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     49.3 MiB    -60.0 MiB           1       count = 0
    34     49.6 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     49.8 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     49.8 MiB      0.0 MiB           1       came_from = {}
    37     53.8 MiB -218491.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     50.3 MiB     -3.5 MiB           1       g_score[start] = 0
    39     56.3 MiB -23190.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     54.5 MiB     -1.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     54.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     54.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     54.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     56.5 MiB -72609.2 MiB        9184       while not open_set.empty():
    47     56.5 MiB -72609.6 MiB        9184           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     56.5 MiB -72610.4 MiB        9184           current = open_set.get()[2]
    53     56.5 MiB -72610.6 MiB        9184           open_set_hash.remove(current)
    54                                         
    55     56.5 MiB -72611.4 MiB        9184           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     56.5 MiB -72611.7 MiB        9184           if current == end:
    60     53.1 MiB     -3.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     53.5 MiB      0.4 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     56.5 MiB -653485.3 MiB       82647           for neighbor in current.neighbors:
    65     56.5 MiB -580880.2 MiB       73464               if current.row != neighbor.row and current.col != neighbor.col:
    66     56.5 MiB -290452.6 MiB       36732                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     56.5 MiB -290433.3 MiB       36732                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     56.5 MiB -580891.2 MiB       73464               if temp_g_score < g_score[neighbor]:
    71     56.5 MiB -77847.7 MiB        9950                   came_from[neighbor] = current
    72     56.5 MiB -77848.4 MiB        9950                   g_score[neighbor] = temp_g_score
    73     56.5 MiB -77851.5 MiB        9950                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     56.5 MiB -77851.8 MiB        9950                   if neighbor not in open_set_hash:
    75     56.5 MiB -77852.5 MiB        9950                       count += 1
    76     56.5 MiB -77832.9 MiB        9950                       open_set.put((f_score[neighbor], count, neighbor))
    77     56.5 MiB -77833.0 MiB        9950                       open_set_hash.add(neighbor)
    78                                                             
    79     56.5 MiB -72604.3 MiB        9183           if draw is not None:
    80                                                     draw()
    81                                         
    82     56.5 MiB -72604.7 MiB        9183           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     99.3 MiB     99.3 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     99.4 MiB    -27.0 MiB         257       for row in grid:
    30     99.4 MiB  -6903.9 MiB       65792           for spot in row:
    31     99.4 MiB  -6877.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     98.8 MiB     -0.5 MiB           1       count = 0
    34     98.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     98.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     98.8 MiB      0.0 MiB           1       came_from = {}
    37    103.0 MiB -28574.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38    101.9 MiB     -1.1 MiB           1       g_score[start] = 0
    39    103.5 MiB -305954.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     82.5 MiB    -21.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     82.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     82.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     82.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     82.9 MiB -316766.5 MiB        7772       while not open_set.empty():
    47     82.9 MiB -316766.5 MiB        7772           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     82.9 MiB -316767.0 MiB        7772           current = open_set.get()[2]
    53     82.9 MiB -316767.1 MiB        7772           open_set_hash.remove(current)
    54                                         
    55     82.9 MiB -316767.4 MiB        7772           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     82.9 MiB -316768.0 MiB        7772           if current == end:
    60     56.6 MiB    -26.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     56.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     82.9 MiB -2850802.3 MiB       69939           for neighbor in current.neighbors:
    65     82.9 MiB -2534051.4 MiB       62168               if current.row != neighbor.row and current.col != neighbor.col:
    66     82.9 MiB -1267055.8 MiB       31084                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     82.9 MiB -1267002.2 MiB       31084                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     82.9 MiB -2534061.8 MiB       62168               if temp_g_score < g_score[neighbor]:
    71     82.9 MiB -336032.1 MiB        8368                   came_from[neighbor] = current
    72     82.9 MiB -336032.4 MiB        8368                   g_score[neighbor] = temp_g_score
    73     82.9 MiB -336032.3 MiB        8368                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     82.9 MiB -336032.7 MiB        8368                   if neighbor not in open_set_hash:
    75     82.9 MiB -336033.0 MiB        8368                       count += 1
    76     82.9 MiB -336013.0 MiB        8368                       open_set.put((f_score[neighbor], count, neighbor))
    77     82.9 MiB -336013.2 MiB        8368                       open_set_hash.add(neighbor)
    78                                                             
    79     82.9 MiB -316764.5 MiB        7771           if draw is not None:
    80                                                     draw()
    81                                         
    82     82.9 MiB -316766.3 MiB        7771           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     98.2 MiB     98.2 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     98.2 MiB    -62.5 MiB         257       for row in grid:
    30     98.2 MiB -15733.8 MiB       65792           for spot in row:
    31     98.2 MiB -15672.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     95.6 MiB     -2.7 MiB           1       count = 0
    34     95.6 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     95.6 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     95.6 MiB      0.0 MiB           1       came_from = {}
    37     97.8 MiB  -3620.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.6 MiB     -0.2 MiB           1       g_score[start] = 0
    39    102.1 MiB  -2975.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.1 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.1 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.1 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.1 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.1 MiB   -326.2 MiB        1080       while not open_set.empty():
    47    102.1 MiB   -326.2 MiB        1080           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.1 MiB   -326.2 MiB        1080           current = open_set.get()[2]
    53    102.1 MiB   -326.2 MiB        1080           open_set_hash.remove(current)
    54                                         
    55    102.1 MiB   -326.2 MiB        1080           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.1 MiB   -326.2 MiB        1080           if current == end:
    60    101.8 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62    101.8 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.1 MiB  -2934.1 MiB        9711           for neighbor in current.neighbors:
    65    102.1 MiB  -2608.0 MiB        8632               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.1 MiB  -1304.4 MiB        4316                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.1 MiB  -1303.8 MiB        4316                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.1 MiB  -2608.2 MiB        8632               if temp_g_score < g_score[neighbor]:
    71    102.1 MiB   -408.7 MiB        1380                   came_from[neighbor] = current
    72    102.1 MiB   -408.7 MiB        1380                   g_score[neighbor] = temp_g_score
    73    102.1 MiB   -408.7 MiB        1380                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.1 MiB   -408.7 MiB        1380                   if neighbor not in open_set_hash:
    75    102.1 MiB   -408.7 MiB        1380                       count += 1
    76    102.1 MiB   -408.7 MiB        1380                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.1 MiB   -408.7 MiB        1380                       open_set_hash.add(neighbor)
    78                                                             
    79    102.1 MiB   -326.1 MiB        1079           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.1 MiB   -326.1 MiB        1079           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.5 MiB    104.5 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.5 MiB  -5795.7 MiB         257       for row in grid:
    30    104.5 MiB -1477397.3 MiB       65792           for spot in row:
    31    104.5 MiB -1471636.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     42.5 MiB    -62.0 MiB           1       count = 0
    34     42.7 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     42.7 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     42.7 MiB      0.0 MiB           1       came_from = {}
    37     51.6 MiB   -464.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     51.6 MiB      0.0 MiB           1       g_score[start] = 0
    39     51.9 MiB -693556.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     35.7 MiB    -16.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     35.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     35.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     35.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     37.2 MiB    -38.0 MiB         374       while not open_set.empty():
    47     37.2 MiB    -38.2 MiB         374           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     37.2 MiB    -37.8 MiB         374           current = open_set.get()[2]
    53     37.2 MiB    -38.2 MiB         374           open_set_hash.remove(current)
    54                                         
    55     37.2 MiB    -38.2 MiB         374           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     37.2 MiB    -38.1 MiB         374           if current == end:
    60     37.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     37.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     37.2 MiB   -342.4 MiB        3357           for neighbor in current.neighbors:
    65     37.2 MiB   -304.0 MiB        2984               if current.row != neighbor.row and current.col != neighbor.col:
    66     37.2 MiB   -152.3 MiB        1492                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     37.2 MiB   -152.0 MiB        1492                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     37.2 MiB   -304.2 MiB        2984               if temp_g_score < g_score[neighbor]:
    71     37.2 MiB    -47.7 MiB         484                   came_from[neighbor] = current
    72     37.2 MiB    -47.8 MiB         484                   g_score[neighbor] = temp_g_score
    73     37.2 MiB    -47.8 MiB         484                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     37.2 MiB    -47.8 MiB         484                   if neighbor not in open_set_hash:
    75     37.2 MiB    -47.8 MiB         484                       count += 1
    76     37.2 MiB    -47.7 MiB         484                       open_set.put((f_score[neighbor], count, neighbor))
    77     37.2 MiB    -48.2 MiB         484                       open_set_hash.add(neighbor)
    78                                                             
    79     37.2 MiB    -38.2 MiB         373           if draw is not None:
    80                                                     draw()
    81                                         
    82     37.2 MiB    -38.2 MiB         373           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     97.8 MiB     97.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.8 MiB   -513.0 MiB         257       for row in grid:
    30     97.8 MiB -131280.7 MiB       65792           for spot in row:
    31     97.8 MiB -130771.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     94.2 MiB     -3.7 MiB           1       count = 0
    34     94.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     94.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     94.2 MiB      0.0 MiB           1       came_from = {}
    37     99.2 MiB  -9548.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     97.0 MiB     -2.1 MiB           1       g_score[start] = 0
    39    102.3 MiB   -162.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40    102.3 MiB      0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41    102.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43    102.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44    102.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46    102.4 MiB      0.0 MiB        1176       while not open_set.empty():
    47    102.4 MiB      0.0 MiB        1176           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52    102.4 MiB      0.0 MiB        1176           current = open_set.get()[2]
    53    102.4 MiB      0.0 MiB        1176           open_set_hash.remove(current)
    54                                         
    55    102.4 MiB      0.0 MiB        1176           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59    102.4 MiB      0.0 MiB        1176           if current == end:
    60    102.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62    102.4 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64    102.4 MiB      0.0 MiB       10575           for neighbor in current.neighbors:
    65    102.4 MiB      0.0 MiB        9400               if current.row != neighbor.row and current.col != neighbor.col:
    66    102.4 MiB      0.0 MiB        4700                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68    102.4 MiB      0.0 MiB        4700                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70    102.4 MiB      0.0 MiB        9400               if temp_g_score < g_score[neighbor]:
    71    102.4 MiB      0.0 MiB        1538                   came_from[neighbor] = current
    72    102.4 MiB      0.0 MiB        1538                   g_score[neighbor] = temp_g_score
    73    102.4 MiB      0.0 MiB        1538                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74    102.4 MiB      0.0 MiB        1538                   if neighbor not in open_set_hash:
    75    102.4 MiB      0.0 MiB        1538                       count += 1
    76    102.4 MiB      0.0 MiB        1538                       open_set.put((f_score[neighbor], count, neighbor))
    77    102.4 MiB      0.0 MiB        1538                       open_set_hash.add(neighbor)
    78                                                             
    79    102.4 MiB      0.0 MiB        1175           if draw is not None:
    80                                                     draw()
    81                                         
    82    102.4 MiB      0.0 MiB        1175           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26    104.0 MiB    104.0 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29    104.0 MiB -11065.4 MiB         257       for row in grid:
    30    104.0 MiB -2834243.3 MiB       65792           for spot in row:
    31    104.0 MiB -2823213.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     14.4 MiB    -89.5 MiB           1       count = 0
    34     14.8 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     15.0 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     15.0 MiB      0.0 MiB           1       came_from = {}
    37     19.1 MiB -62534.0 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     18.3 MiB     -0.8 MiB           1       g_score[start] = 0
    39     23.0 MiB -57026.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     22.8 MiB     -0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     22.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     22.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     22.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     26.1 MiB -14392.4 MiB        2415       while not open_set.empty():
    47     26.1 MiB -14393.1 MiB        2415           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     26.1 MiB -14393.3 MiB        2415           current = open_set.get()[2]
    53     26.1 MiB -14394.1 MiB        2415           open_set_hash.remove(current)
    54                                         
    55     26.1 MiB -14394.4 MiB        2415           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     26.1 MiB -14394.5 MiB        2415           if current == end:
    60     19.3 MiB     -6.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     19.5 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     26.1 MiB -129515.8 MiB       21726           for neighbor in current.neighbors:
    65     26.1 MiB -115124.6 MiB       19312               if current.row != neighbor.row and current.col != neighbor.col:
    66     26.1 MiB -57568.6 MiB        9656                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     26.1 MiB -57558.8 MiB        9656                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     26.1 MiB -115125.3 MiB       19312               if temp_g_score < g_score[neighbor]:
    71     26.1 MiB -16386.1 MiB        2795                   came_from[neighbor] = current
    72     26.1 MiB -16386.8 MiB        2795                   g_score[neighbor] = temp_g_score
    73     26.1 MiB -16383.0 MiB        2795                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     26.1 MiB -16383.1 MiB        2795                   if neighbor not in open_set_hash:
    75     26.1 MiB -16385.0 MiB        2795                       count += 1
    76     26.1 MiB -16384.8 MiB        2795                       open_set.put((f_score[neighbor], count, neighbor))
    77     26.1 MiB -16386.2 MiB        2795                       open_set_hash.add(neighbor)
    78                                                             
    79     26.1 MiB -14392.5 MiB        2414           if draw is not None:
    80                                                     draw()
    81                                         
    82     26.1 MiB -14392.5 MiB        2414           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     90.0 MiB     90.0 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     90.0 MiB -10833.5 MiB         257       for row in grid:
    30     90.0 MiB -2779293.2 MiB       65792           for spot in row:
    31     90.0 MiB -2768517.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     24.9 MiB    -65.1 MiB           1       count = 0
    34     25.3 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     25.5 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     25.5 MiB      0.0 MiB           1       came_from = {}
    37     36.2 MiB -11467.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     33.5 MiB     -2.7 MiB           1       g_score[start] = 0
    39     34.0 MiB -510020.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     19.5 MiB    -14.5 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     19.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     19.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     19.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     21.4 MiB  -7360.3 MiB        3128       while not open_set.empty():
    47     21.4 MiB  -7360.5 MiB        3128           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     21.4 MiB  -7360.1 MiB        3128           current = open_set.get()[2]
    53     21.4 MiB  -7360.5 MiB        3128           open_set_hash.remove(current)
    54                                         
    55     21.4 MiB  -7360.5 MiB        3128           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     21.4 MiB  -7360.5 MiB        3128           if current == end:
    60     18.0 MiB     -3.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     18.4 MiB      0.4 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     21.4 MiB -66206.9 MiB       28143           for neighbor in current.neighbors:
    65     21.4 MiB -58845.9 MiB       25016               if current.row != neighbor.row and current.col != neighbor.col:
    66     21.4 MiB -29433.1 MiB       12508                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     21.4 MiB -29415.0 MiB       12508                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     21.4 MiB -58848.3 MiB       25016               if temp_g_score < g_score[neighbor]:
    71     21.4 MiB  -8195.9 MiB        3490                   came_from[neighbor] = current
    72     21.4 MiB  -8196.1 MiB        3490                   g_score[neighbor] = temp_g_score
    73     21.4 MiB  -8195.3 MiB        3490                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     21.4 MiB  -8195.6 MiB        3490                   if neighbor not in open_set_hash:
    75     21.4 MiB  -8195.6 MiB        3490                       count += 1
    76     21.4 MiB  -8195.4 MiB        3490                       open_set.put((f_score[neighbor], count, neighbor))
    77     21.4 MiB  -8195.2 MiB        3490                       open_set_hash.add(neighbor)
    78                                                             
    79     21.4 MiB  -7360.5 MiB        3127           if draw is not None:
    80                                                     draw()
    81                                         
    82     21.4 MiB  -7360.5 MiB        3127           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.6 MiB     92.6 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.6 MiB  -7319.9 MiB         257       for row in grid:
    30     92.6 MiB -1873884.3 MiB       65792           for spot in row:
    31     92.6 MiB -1866629.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     26.3 MiB    -66.3 MiB           1       count = 0
    34     26.7 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     26.9 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     26.9 MiB      0.0 MiB           1       came_from = {}
    37     34.4 MiB -103850.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     31.6 MiB     -2.8 MiB           1       g_score[start] = 0
    39     34.0 MiB -132469.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     27.8 MiB     -6.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     27.8 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     27.8 MiB      0.0 MiB           1       cost_diagonal = 14
    44     27.8 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     29.4 MiB -10131.0 MiB        3198       while not open_set.empty():
    47     29.4 MiB -10131.3 MiB        3198           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     29.4 MiB -10131.1 MiB        3198           current = open_set.get()[2]
    53     29.4 MiB -10131.7 MiB        3198           open_set_hash.remove(current)
    54                                         
    55     29.4 MiB -10131.7 MiB        3198           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     29.4 MiB -10133.2 MiB        3198           if current == end:
    60     28.3 MiB     -1.1 MiB           1               if draw:
    61                                                         end.make_end()
    62     28.6 MiB      0.4 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     29.4 MiB -91212.0 MiB       28773           for neighbor in current.neighbors:
    65     29.4 MiB -81077.2 MiB       25576               if current.row != neighbor.row and current.col != neighbor.col:
    66     29.4 MiB -40544.2 MiB       12788                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     29.4 MiB -40537.5 MiB       12788                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     29.4 MiB -81080.7 MiB       25576               if temp_g_score < g_score[neighbor]:
    71     29.4 MiB -10994.1 MiB        3546                   came_from[neighbor] = current
    72     29.4 MiB -10994.1 MiB        3546                   g_score[neighbor] = temp_g_score
    73     29.4 MiB -10993.4 MiB        3546                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     29.4 MiB -10995.4 MiB        3546                   if neighbor not in open_set_hash:
    75     29.4 MiB -10995.4 MiB        3546                       count += 1
    76     29.4 MiB -10995.3 MiB        3546                       open_set.put((f_score[neighbor], count, neighbor))
    77     29.4 MiB -10995.5 MiB        3546                       open_set_hash.add(neighbor)
    78                                                             
    79     29.4 MiB -10138.7 MiB        3197           if draw is not None:
    80                                                     draw()
    81                                         
    82     29.4 MiB -10131.0 MiB        3197           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.0 MiB     92.0 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.0 MiB -11668.3 MiB         257       for row in grid:
    30     92.0 MiB -2995641.1 MiB       65792           for spot in row:
    31     92.0 MiB -2984019.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     31.2 MiB    -60.9 MiB           1       count = 0
    34     31.5 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     31.7 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     31.7 MiB      0.0 MiB           1       came_from = {}
    37     39.9 MiB -11972.7 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     39.1 MiB     -0.8 MiB           1       g_score[start] = 0
    39     40.3 MiB -85765.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     38.0 MiB     -2.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     38.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     38.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     38.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     44.8 MiB -71204.5 MiB        6160       while not open_set.empty():
    47     44.8 MiB -71204.7 MiB        6160           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     44.8 MiB -71205.4 MiB        6160           current = open_set.get()[2]
    53     44.8 MiB -71209.0 MiB        6160           open_set_hash.remove(current)
    54                                         
    55     44.8 MiB -71209.2 MiB        6160           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     44.8 MiB -71209.7 MiB        6160           if current == end:
    60     44.6 MiB     -0.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     44.8 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     44.8 MiB -643383.8 MiB       55431           for neighbor in current.neighbors:
    65     44.8 MiB -572177.7 MiB       49272               if current.row != neighbor.row and current.col != neighbor.col:
    66     44.8 MiB -286083.5 MiB       24636                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     44.8 MiB -286100.8 MiB       24636                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     44.8 MiB -570917.4 MiB       49272               if temp_g_score < g_score[neighbor]:
    71     44.8 MiB -74721.2 MiB        6602                   came_from[neighbor] = current
    72     44.8 MiB -74721.5 MiB        6602                   g_score[neighbor] = temp_g_score
    73     44.8 MiB -74723.5 MiB        6602                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     44.8 MiB -74723.8 MiB        6602                   if neighbor not in open_set_hash:
    75     44.8 MiB -74724.0 MiB        6602                       count += 1
    76     44.8 MiB -74701.5 MiB        6602                       open_set.put((f_score[neighbor], count, neighbor))
    77     44.8 MiB -74708.5 MiB        6602                       open_set_hash.add(neighbor)
    78                                                             
    79     44.8 MiB -71521.2 MiB        6159           if draw is not None:
    80                                                     draw()
    81                                         
    82     44.8 MiB -71204.4 MiB        6159           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     91.2 MiB     91.2 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     91.2 MiB  -2864.4 MiB         257       for row in grid:
    30     91.2 MiB -732160.6 MiB       65792           for spot in row:
    31     91.2 MiB -729346.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     20.0 MiB    -71.2 MiB           1       count = 0
    34     20.3 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     20.5 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     20.5 MiB      0.0 MiB           1       came_from = {}
    37     32.8 MiB  -4638.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     32.7 MiB     -0.1 MiB           1       g_score[start] = 0
    39     37.9 MiB  -5698.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     38.2 MiB      0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     38.2 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     38.2 MiB      0.0 MiB           1       cost_diagonal = 14
    44     38.2 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     39.3 MiB -68395.3 MiB        4980       while not open_set.empty():
    47     39.3 MiB -68396.0 MiB        4980           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     39.3 MiB -68396.2 MiB        4980           current = open_set.get()[2]
    53     39.3 MiB -68396.6 MiB        4980           open_set_hash.remove(current)
    54                                         
    55     39.3 MiB -68396.8 MiB        4980           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     39.3 MiB -68397.4 MiB        4980           if current == end:
    60     17.8 MiB    -21.5 MiB           1               if draw:
    61                                                         end.make_end()
    62     18.5 MiB      0.8 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     39.3 MiB -615421.8 MiB       44811           for neighbor in current.neighbors:
    65     39.3 MiB -547029.4 MiB       39832               if current.row != neighbor.row and current.col != neighbor.col:
    66     39.3 MiB -273531.9 MiB       19916                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     39.3 MiB -273504.6 MiB       19916                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     39.3 MiB -547041.9 MiB       39832               if temp_g_score < g_score[neighbor]:
    71     39.3 MiB -73141.2 MiB        5430                   came_from[neighbor] = current
    72     39.3 MiB -73141.9 MiB        5430                   g_score[neighbor] = temp_g_score
    73     39.3 MiB -73141.6 MiB        5430                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     39.3 MiB -73141.8 MiB        5430                   if neighbor not in open_set_hash:
    75     39.3 MiB -73141.9 MiB        5430                       count += 1
    76     39.3 MiB -73141.9 MiB        5430                       open_set.put((f_score[neighbor], count, neighbor))
    77     39.3 MiB -73141.9 MiB        5430                       open_set_hash.add(neighbor)
    78                                                             
    79     39.3 MiB -68391.3 MiB        4979           if draw is not None:
    80                                                     draw()
    81                                         
    82     39.3 MiB -68394.6 MiB        4979           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     88.8 MiB     88.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     88.8 MiB  -9153.1 MiB         257       for row in grid:
    30     88.8 MiB -2347732.5 MiB       65792           for spot in row:
    31     88.8 MiB -2338618.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     37.2 MiB    -51.5 MiB           1       count = 0
    34     37.6 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     37.8 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     37.8 MiB      0.0 MiB           1       came_from = {}
    37     41.0 MiB -120718.1 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     41.0 MiB      0.0 MiB           1       g_score[start] = 0
    39     41.2 MiB -132674.6 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     38.6 MiB     -2.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     38.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     38.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     38.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     49.2 MiB -25795.0 MiB        3190       while not open_set.empty():
    47     49.2 MiB -25795.1 MiB        3190           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     49.2 MiB -25795.3 MiB        3190           current = open_set.get()[2]
    53     49.2 MiB -25795.4 MiB        3190           open_set_hash.remove(current)
    54                                         
    55     49.2 MiB -25795.4 MiB        3190           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     49.2 MiB -25795.5 MiB        3190           if current == end:
    60     49.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     49.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     49.2 MiB -232155.0 MiB       28701           for neighbor in current.neighbors:
    65     49.2 MiB -206362.0 MiB       25512               if current.row != neighbor.row and current.col != neighbor.col:
    66     49.2 MiB -103194.4 MiB       12756                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     49.2 MiB -103173.0 MiB       12756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     49.2 MiB -206368.6 MiB       25512               if temp_g_score < g_score[neighbor]:
    71     49.2 MiB -29522.5 MiB        3686                   came_from[neighbor] = current
    72     49.2 MiB -29523.4 MiB        3686                   g_score[neighbor] = temp_g_score
    73     49.2 MiB -29523.4 MiB        3686                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     49.2 MiB -29523.5 MiB        3686                   if neighbor not in open_set_hash:
    75     49.2 MiB -29523.9 MiB        3686                       count += 1
    76     49.2 MiB -29502.9 MiB        3686                       open_set.put((f_score[neighbor], count, neighbor))
    77     49.2 MiB -29513.2 MiB        3686                       open_set_hash.add(neighbor)
    78                                                             
    79     49.2 MiB -25794.5 MiB        3189           if draw is not None:
    80                                                     draw()
    81                                         
    82     49.2 MiB -25794.9 MiB        3189           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     90.2 MiB     90.2 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     90.2 MiB   -780.4 MiB         257       for row in grid:
    30     90.2 MiB -199494.9 MiB       65792           for spot in row:
    31     90.2 MiB -198720.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     82.2 MiB     -8.0 MiB           1       count = 0
    34     82.5 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     82.7 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     82.7 MiB      0.0 MiB           1       came_from = {}
    37     85.9 MiB -359774.3 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     27.5 MiB    -58.4 MiB           1       g_score[start] = 0
    39     32.1 MiB -27911.4 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     31.6 MiB     -0.4 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     31.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     31.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     31.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     34.9 MiB  -6287.7 MiB        1792       while not open_set.empty():
    47     34.9 MiB  -6287.7 MiB        1792           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     34.9 MiB  -6287.7 MiB        1792           current = open_set.get()[2]
    53     34.9 MiB  -6287.7 MiB        1792           open_set_hash.remove(current)
    54                                         
    55     34.9 MiB  -6287.7 MiB        1792           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     34.9 MiB  -6287.7 MiB        1792           if current == end:
    60     23.3 MiB    -11.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     23.3 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     34.9 MiB -56514.4 MiB       16119           for neighbor in current.neighbors:
    65     34.9 MiB -50227.8 MiB       14328               if current.row != neighbor.row and current.col != neighbor.col:
    66     34.9 MiB -25122.1 MiB        7164                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     34.9 MiB -25106.9 MiB        7164                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     34.9 MiB -50227.8 MiB       14328               if temp_g_score < g_score[neighbor]:
    71     34.9 MiB  -7017.3 MiB        2030                   came_from[neighbor] = current
    72     34.9 MiB  -7017.4 MiB        2030                   g_score[neighbor] = temp_g_score
    73     34.9 MiB  -7017.2 MiB        2030                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     34.9 MiB  -7018.2 MiB        2030                   if neighbor not in open_set_hash:
    75     34.9 MiB  -7018.2 MiB        2030                       count += 1
    76     34.9 MiB  -7018.0 MiB        2030                       open_set.put((f_score[neighbor], count, neighbor))
    77     34.9 MiB  -7018.1 MiB        2030                       open_set_hash.add(neighbor)
    78                                                             
    79     34.9 MiB  -6287.6 MiB        1791           if draw is not None:
    80                                                     draw()
    81                                         
    82     34.9 MiB  -6287.6 MiB        1791           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     89.8 MiB     89.8 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     89.8 MiB  -2792.2 MiB         257       for row in grid:
    30     89.8 MiB -712428.4 MiB       65792           for spot in row:
    31     89.8 MiB -709693.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     23.8 MiB    -65.9 MiB           1       count = 0
    34     24.2 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     24.4 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     24.4 MiB      0.0 MiB           1       came_from = {}
    37     28.9 MiB -226631.8 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     27.3 MiB     -1.6 MiB           1       g_score[start] = 0
    39     28.1 MiB -335606.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     22.3 MiB     -5.8 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     22.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     22.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     22.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     48.4 MiB   -879.9 MiB        2190       while not open_set.empty():
    47     48.4 MiB   -880.1 MiB        2190           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     48.4 MiB   -879.8 MiB        2190           current = open_set.get()[2]
    53     48.4 MiB   -880.1 MiB        2190           open_set_hash.remove(current)
    54                                         
    55     48.4 MiB   -880.1 MiB        2190           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     48.4 MiB   -880.1 MiB        2190           if current == end:
    60     48.4 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     48.5 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     48.4 MiB  -8091.2 MiB       19701           for neighbor in current.neighbors:
    65     48.4 MiB  -7208.3 MiB       17512               if current.row != neighbor.row and current.col != neighbor.col:
    66     48.4 MiB  -3609.8 MiB        8756                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     48.4 MiB  -3602.2 MiB        8756                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     48.4 MiB  -7209.5 MiB       17512               if temp_g_score < g_score[neighbor]:
    71     48.4 MiB  -1167.2 MiB        2802                   came_from[neighbor] = current
    72     48.4 MiB  -1157.9 MiB        2802                   g_score[neighbor] = temp_g_score
    73     48.4 MiB  -1156.5 MiB        2802                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     48.4 MiB  -1167.2 MiB        2802                   if neighbor not in open_set_hash:
    75     48.4 MiB  -1167.2 MiB        2802                       count += 1
    76     48.4 MiB  -1150.0 MiB        2802                       open_set.put((f_score[neighbor], count, neighbor))
    77     48.4 MiB  -1167.1 MiB        2802                       open_set_hash.add(neighbor)
    78                                                             
    79     48.4 MiB   -902.8 MiB        2189           if draw is not None:
    80                                                     draw()
    81                                         
    82     48.4 MiB   -880.1 MiB        2189           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     88.5 MiB     88.5 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     88.5 MiB  -1250.8 MiB         257       for row in grid:
    30     88.5 MiB -320670.9 MiB       65792           for spot in row:
    31     88.5 MiB -319426.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     80.1 MiB     -8.4 MiB           1       count = 0
    34     80.1 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     80.1 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     80.1 MiB      0.0 MiB           1       came_from = {}
    37     82.4 MiB -992685.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     32.3 MiB    -50.1 MiB           1       g_score[start] = 0
    39     34.1 MiB -231645.9 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     31.4 MiB     -2.7 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     31.4 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     31.4 MiB      0.0 MiB           1       cost_diagonal = 14
    44     31.4 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     34.6 MiB      0.1 MiB         725       while not open_set.empty():
    47     34.6 MiB      0.0 MiB         725           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     34.6 MiB      0.2 MiB         725           current = open_set.get()[2]
    53     34.6 MiB      0.0 MiB         725           open_set_hash.remove(current)
    54                                         
    55     34.6 MiB      0.0 MiB         725           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     34.6 MiB      0.0 MiB         725           if current == end:
    60     34.6 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     34.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     34.6 MiB      0.5 MiB        6516           for neighbor in current.neighbors:
    65     34.6 MiB      0.6 MiB        5792               if current.row != neighbor.row and current.col != neighbor.col:
    66     34.6 MiB      0.0 MiB        2896                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     34.6 MiB      0.0 MiB        2896                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     34.6 MiB      1.2 MiB        5792               if temp_g_score < g_score[neighbor]:
    71     34.6 MiB      0.1 MiB         889                   came_from[neighbor] = current
    72     34.6 MiB      0.0 MiB         889                   g_score[neighbor] = temp_g_score
    73     34.6 MiB      0.0 MiB         889                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     34.6 MiB      0.0 MiB         889                   if neighbor not in open_set_hash:
    75     34.6 MiB      0.0 MiB         889                       count += 1
    76     34.6 MiB      0.1 MiB         889                       open_set.put((f_score[neighbor], count, neighbor))
    77     34.6 MiB      0.0 MiB         889                       open_set_hash.add(neighbor)
    78                                                             
    79     34.6 MiB      0.0 MiB         724           if draw is not None:
    80                                                     draw()
    81                                         
    82     34.6 MiB      0.0 MiB         724           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     90.7 MiB     90.7 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     90.7 MiB  -1709.3 MiB         257       for row in grid:
    30     90.7 MiB -437623.6 MiB       65792           for spot in row:
    31     90.7 MiB -435922.6 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     77.6 MiB    -13.1 MiB           1       count = 0
    34     78.0 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     78.2 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     78.2 MiB      0.0 MiB           1       came_from = {}
    37     79.2 MiB -1769571.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     38.6 MiB    -40.5 MiB           1       g_score[start] = 0
    39     39.5 MiB -175630.5 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     39.5 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     39.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     39.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     39.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     43.2 MiB    -30.1 MiB         695       while not open_set.empty():
    47     43.2 MiB    -30.2 MiB         695           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     43.2 MiB    -30.1 MiB         695           current = open_set.get()[2]
    53     43.2 MiB    -30.2 MiB         695           open_set_hash.remove(current)
    54                                         
    55     43.2 MiB    -30.2 MiB         695           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     43.2 MiB    -30.2 MiB         695           if current == end:
    60     43.2 MiB      0.0 MiB           1               if draw:
    61                                                         end.make_end()
    62     43.2 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     43.2 MiB   -268.8 MiB        6246           for neighbor in current.neighbors:
    65     43.2 MiB   -237.5 MiB        5552               if current.row != neighbor.row and current.col != neighbor.col:
    66     43.2 MiB   -119.7 MiB        2776                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     43.2 MiB   -120.1 MiB        2776                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     43.2 MiB   -239.8 MiB        5552               if temp_g_score < g_score[neighbor]:
    71     43.2 MiB    -53.4 MiB        1259                   came_from[neighbor] = current
    72     43.2 MiB    -53.5 MiB        1259                   g_score[neighbor] = temp_g_score
    73     43.2 MiB    -53.5 MiB        1259                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     43.2 MiB    -53.5 MiB        1259                   if neighbor not in open_set_hash:
    75     43.2 MiB    -53.5 MiB        1259                       count += 1
    76     43.2 MiB    -53.5 MiB        1259                       open_set.put((f_score[neighbor], count, neighbor))
    77     43.2 MiB    -53.5 MiB        1259                       open_set_hash.add(neighbor)
    78                                                             
    79     43.2 MiB    -29.9 MiB         694           if draw is not None:
    80                                                     draw()
    81                                         
    82     43.2 MiB    -29.9 MiB         694           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.9 MiB     92.9 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.9 MiB  -2214.2 MiB         257       for row in grid:
    30     92.9 MiB -565666.5 MiB       65792           for spot in row:
    31     92.9 MiB -563467.8 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     71.3 MiB    -21.7 MiB           1       count = 0
    34     71.6 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     71.8 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     71.8 MiB      0.0 MiB           1       came_from = {}
    37     75.3 MiB -1732140.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     26.1 MiB    -49.2 MiB           1       g_score[start] = 0
    39     28.5 MiB -67785.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     28.5 MiB     -0.0 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     28.5 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     28.5 MiB      0.0 MiB           1       cost_diagonal = 14
    44     28.5 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     33.4 MiB   -264.6 MiB        2226       while not open_set.empty():
    47     33.4 MiB   -264.8 MiB        2226           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     33.4 MiB   -265.8 MiB        2226           current = open_set.get()[2]
    53     33.4 MiB   -266.1 MiB        2226           open_set_hash.remove(current)
    54                                         
    55     33.4 MiB   -267.2 MiB        2226           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     33.4 MiB   -267.2 MiB        2226           if current == end:
    60     31.0 MiB     -2.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     31.0 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     33.4 MiB  -2390.5 MiB       20025           for neighbor in current.neighbors:
    65     33.4 MiB  -2125.0 MiB       17800               if current.row != neighbor.row and current.col != neighbor.col:
    66     33.4 MiB  -1063.3 MiB        8900                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     33.4 MiB  -1063.2 MiB        8900                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     33.4 MiB  -2123.8 MiB       17800               if temp_g_score < g_score[neighbor]:
    71     33.4 MiB   -319.8 MiB        2520                   came_from[neighbor] = current
    72     33.4 MiB   -320.2 MiB        2520                   g_score[neighbor] = temp_g_score
    73     33.4 MiB   -320.2 MiB        2520                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     33.4 MiB   -320.2 MiB        2520                   if neighbor not in open_set_hash:
    75     33.4 MiB   -320.2 MiB        2520                       count += 1
    76     33.4 MiB   -320.1 MiB        2520                       open_set.put((f_score[neighbor], count, neighbor))
    77     33.4 MiB   -320.1 MiB        2520                       open_set_hash.add(neighbor)
    78                                                             
    79     33.4 MiB   -265.9 MiB        2225           if draw is not None:
    80                                                     draw()
    81                                         
    82     33.4 MiB   -264.8 MiB        2225           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     94.0 MiB     94.0 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     94.0 MiB   -480.0 MiB         257       for row in grid:
    30     94.0 MiB -122530.7 MiB       65792           for spot in row:
    31     94.0 MiB -122053.7 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     87.5 MiB     -6.5 MiB           1       count = 0
    34     87.7 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     87.9 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     87.9 MiB      0.0 MiB           1       came_from = {}
    37     88.8 MiB -44752.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     88.5 MiB     -0.3 MiB           1       g_score[start] = 0
    39     89.0 MiB -1960953.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     38.8 MiB    -50.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     38.9 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     38.9 MiB      0.0 MiB           1       cost_diagonal = 14
    44     38.9 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     40.1 MiB   -583.7 MiB         740       while not open_set.empty():
    47     40.1 MiB   -583.7 MiB         740           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     40.1 MiB   -583.7 MiB         740           current = open_set.get()[2]
    53     40.1 MiB   -583.7 MiB         740           open_set_hash.remove(current)
    54                                         
    55     40.1 MiB   -584.1 MiB         740           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     40.1 MiB   -584.0 MiB         740           if current == end:
    60     38.7 MiB     -1.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     38.7 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     40.1 MiB  -5247.7 MiB        6651           for neighbor in current.neighbors:
    65     40.1 MiB  -4663.6 MiB        5912               if current.row != neighbor.row and current.col != neighbor.col:
    66     40.1 MiB  -2333.7 MiB        2956                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     40.1 MiB  -2330.6 MiB        2956                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     40.1 MiB  -4665.4 MiB        5912               if temp_g_score < g_score[neighbor]:
    71     40.1 MiB   -663.9 MiB         892                   came_from[neighbor] = current
    72     40.1 MiB   -663.9 MiB         892                   g_score[neighbor] = temp_g_score
    73     40.1 MiB   -663.9 MiB         892                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     40.1 MiB   -663.9 MiB         892                   if neighbor not in open_set_hash:
    75     40.1 MiB   -663.9 MiB         892                       count += 1
    76     40.1 MiB   -663.9 MiB         892                       open_set.put((f_score[neighbor], count, neighbor))
    77     40.1 MiB   -663.8 MiB         892                       open_set_hash.add(neighbor)
    78                                                             
    79     40.1 MiB   -583.7 MiB         739           if draw is not None:
    80                                                     draw()
    81                                         
    82     40.1 MiB   -583.7 MiB         739           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     96.9 MiB     96.9 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     97.0 MiB  -1358.6 MiB         257       for row in grid:
    30     97.0 MiB -347854.6 MiB       65792           for spot in row:
    31     97.0 MiB -346505.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     86.9 MiB    -10.1 MiB           1       count = 0
    34     87.1 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     87.3 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     87.3 MiB      0.0 MiB           1       came_from = {}
    37     88.0 MiB -428763.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     76.9 MiB    -11.1 MiB           1       g_score[start] = 0
    39     77.3 MiB -2256716.0 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     36.7 MiB    -40.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     36.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     36.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     36.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     40.2 MiB -43606.9 MiB        4416       while not open_set.empty():
    47     40.2 MiB -43606.9 MiB        4416           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     40.2 MiB -43606.9 MiB        4416           current = open_set.get()[2]
    53     40.2 MiB -43607.0 MiB        4416           open_set_hash.remove(current)
    54                                         
    55     40.2 MiB -43607.5 MiB        4416           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     40.2 MiB -43608.1 MiB        4416           if current == end:
    60     20.3 MiB    -19.9 MiB           1               if draw:
    61                                                         end.make_end()
    62     20.5 MiB      0.2 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     40.2 MiB -392367.1 MiB       39735           for neighbor in current.neighbors:
    65     40.2 MiB -348771.2 MiB       35320               if current.row != neighbor.row and current.col != neighbor.col:
    66     40.2 MiB -174409.7 MiB       17660                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     40.2 MiB -174363.5 MiB       17660                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     40.2 MiB -348772.7 MiB       35320               if temp_g_score < g_score[neighbor]:
    71     40.2 MiB -46344.2 MiB        4790                   came_from[neighbor] = current
    72     40.2 MiB -46344.9 MiB        4790                   g_score[neighbor] = temp_g_score
    73     40.2 MiB -46345.7 MiB        4790                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     40.2 MiB -46346.7 MiB        4790                   if neighbor not in open_set_hash:
    75     40.2 MiB -46347.0 MiB        4790                       count += 1
    76     40.2 MiB -46347.1 MiB        4790                       open_set.put((f_score[neighbor], count, neighbor))
    77     40.2 MiB -46347.0 MiB        4790                       open_set_hash.add(neighbor)
    78                                                             
    79     40.2 MiB -43606.9 MiB        4415           if draw is not None:
    80                                                     draw()
    81                                         
    82     40.2 MiB -43606.9 MiB        4415           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     90.6 MiB     90.6 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     90.6 MiB   -975.1 MiB         257       for row in grid:
    30     90.6 MiB -249786.0 MiB       65792           for spot in row:
    31     90.6 MiB -248814.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     83.8 MiB     -6.8 MiB           1       count = 0
    34     83.8 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     83.8 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     83.8 MiB      0.0 MiB           1       came_from = {}
    37     85.3 MiB -1691512.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     38.8 MiB    -46.6 MiB           1       g_score[start] = 0
    39     43.1 MiB -19602.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     43.3 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     43.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     43.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     43.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     54.0 MiB  -6783.6 MiB        5508       while not open_set.empty():
    47     54.0 MiB  -6783.8 MiB        5508           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     54.0 MiB  -6783.6 MiB        5508           current = open_set.get()[2]
    53     54.0 MiB  -6783.8 MiB        5508           open_set_hash.remove(current)
    54                                         
    55     54.0 MiB  -6783.8 MiB        5508           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     54.0 MiB  -6783.8 MiB        5508           if current == end:
    60     36.6 MiB    -17.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     37.7 MiB      1.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     54.0 MiB -60945.9 MiB       49563           for neighbor in current.neighbors:
    65     54.0 MiB -54160.8 MiB       44056               if current.row != neighbor.row and current.col != neighbor.col:
    66     54.0 MiB -27099.6 MiB       22028                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     54.0 MiB -27061.8 MiB       22028                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     54.0 MiB -54161.4 MiB       44056               if temp_g_score < g_score[neighbor]:
    71     54.0 MiB  -7711.8 MiB        6190                   came_from[neighbor] = current
    72     54.0 MiB  -7713.0 MiB        6190                   g_score[neighbor] = temp_g_score
    73     54.0 MiB  -7713.0 MiB        6190                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     54.0 MiB  -7713.0 MiB        6190                   if neighbor not in open_set_hash:
    75     54.0 MiB  -7713.0 MiB        6190                       count += 1
    76     54.0 MiB  -7703.7 MiB        6190                       open_set.put((f_score[neighbor], count, neighbor))
    77     54.0 MiB  -7712.9 MiB        6190                       open_set_hash.add(neighbor)
    78                                                             
    79     54.0 MiB  -6783.8 MiB        5507           if draw is not None:
    80                                                     draw()
    81                                         
    82     54.0 MiB  -6783.8 MiB        5507           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     92.4 MiB     92.4 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     92.4 MiB  -1098.6 MiB         257       for row in grid:
    30     92.4 MiB -280700.0 MiB       65792           for spot in row:
    31     92.4 MiB -279611.5 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     76.0 MiB    -16.3 MiB           1       count = 0
    34     76.2 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     76.4 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     76.4 MiB      0.0 MiB           1       came_from = {}
    37     82.5 MiB    -17.2 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     82.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     85.7 MiB -1798581.7 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     30.6 MiB    -55.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     30.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     30.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     30.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     35.3 MiB     -3.0 MiB         399       while not open_set.empty():
    47     35.3 MiB     -3.0 MiB         399           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     35.3 MiB     -3.0 MiB         399           current = open_set.get()[2]
    53     35.3 MiB     -3.0 MiB         399           open_set_hash.remove(current)
    54                                         
    55     35.3 MiB     -3.0 MiB         399           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     35.3 MiB     -3.0 MiB         399           if current == end:
    60     34.9 MiB     -0.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     34.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     35.3 MiB    -31.8 MiB        3582           for neighbor in current.neighbors:
    65     35.3 MiB    -27.1 MiB        3184               if current.row != neighbor.row and current.col != neighbor.col:
    66     35.3 MiB    -15.7 MiB        1592                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     35.3 MiB    -14.1 MiB        1592                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     35.3 MiB    -24.3 MiB        3184               if temp_g_score < g_score[neighbor]:
    71     35.3 MiB     -5.5 MiB         639                   came_from[neighbor] = current
    72     35.3 MiB     -5.6 MiB         639                   g_score[neighbor] = temp_g_score
    73     35.3 MiB     -5.6 MiB         639                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     35.3 MiB     -5.7 MiB         639                   if neighbor not in open_set_hash:
    75     35.3 MiB     -5.6 MiB         639                       count += 1
    76     35.3 MiB     -5.5 MiB         639                       open_set.put((f_score[neighbor], count, neighbor))
    77     35.3 MiB     -6.0 MiB         639                       open_set_hash.add(neighbor)
    78                                                             
    79     35.3 MiB     -4.0 MiB         398           if draw is not None:
    80                                                     draw()
    81                                         
    82     35.3 MiB     -3.0 MiB         398           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     91.4 MiB     91.4 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     91.4 MiB  -4427.5 MiB         257       for row in grid:
    30     91.4 MiB -1123475.8 MiB       65792           for spot in row:
    31     91.4 MiB -1119101.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     30.9 MiB    -60.5 MiB           1       count = 0
    34     31.2 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     31.4 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     31.4 MiB      0.0 MiB           1       came_from = {}
    37     40.1 MiB -16324.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     40.1 MiB      0.0 MiB           1       g_score[start] = 0
    39     43.2 MiB -705375.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     19.6 MiB    -23.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     19.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     19.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     19.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     24.8 MiB -15478.7 MiB        2760       while not open_set.empty():
    47     24.8 MiB -15479.8 MiB        2760           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     24.8 MiB -15479.5 MiB        2760           current = open_set.get()[2]
    53     24.8 MiB -15479.9 MiB        2760           open_set_hash.remove(current)
    54                                         
    55     24.8 MiB -15479.9 MiB        2760           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     24.8 MiB -15479.9 MiB        2760           if current == end:
    60     21.0 MiB     -3.8 MiB           1               if draw:
    61                                                         end.make_end()
    62     21.7 MiB      0.7 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     24.8 MiB -139265.8 MiB       24831           for neighbor in current.neighbors:
    65     24.8 MiB -123786.9 MiB       22072               if current.row != neighbor.row and current.col != neighbor.col:
    66     24.8 MiB -61902.4 MiB       11036                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     24.8 MiB -61887.5 MiB       11036                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     24.8 MiB -123789.3 MiB       22072               if temp_g_score < g_score[neighbor]:
    71     24.8 MiB -16743.2 MiB        3090                   came_from[neighbor] = current
    72     24.8 MiB -16743.4 MiB        3090                   g_score[neighbor] = temp_g_score
    73     24.8 MiB -16743.6 MiB        3090                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     24.8 MiB -16745.3 MiB        3090                   if neighbor not in open_set_hash:
    75     24.8 MiB -16745.3 MiB        3090                       count += 1
    76     24.8 MiB -16744.9 MiB        3090                       open_set.put((f_score[neighbor], count, neighbor))
    77     24.8 MiB -16744.8 MiB        3090                       open_set_hash.add(neighbor)
    78                                                             
    79     24.8 MiB -15478.5 MiB        2759           if draw is not None:
    80                                                     draw()
    81                                         
    82     24.8 MiB -15478.9 MiB        2759           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     87.7 MiB     87.7 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     87.7 MiB -12207.1 MiB         257       for row in grid:
    30     87.7 MiB -3128244.9 MiB       65792           for spot in row:
    31     87.7 MiB -3116085.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     25.7 MiB    -61.9 MiB           1       count = 0
    34     26.1 MiB      0.4 MiB           1       open_set = PriorityQueue()
    35     26.3 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     26.3 MiB      0.0 MiB           1       came_from = {}
    37     35.9 MiB  -8579.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     35.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     42.4 MiB  -2896.1 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     42.6 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     42.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     42.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     42.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     44.4 MiB  -5172.1 MiB        2832       while not open_set.empty():
    47     44.4 MiB  -5172.2 MiB        2832           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     44.4 MiB  -5172.3 MiB        2832           current = open_set.get()[2]
    53     44.4 MiB  -5173.1 MiB        2832           open_set_hash.remove(current)
    54                                         
    55     44.4 MiB  -5173.1 MiB        2832           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     44.4 MiB  -5173.1 MiB        2832           if current == end:
    60     41.1 MiB     -3.3 MiB           1               if draw:
    61                                                         end.make_end()
    62     41.1 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     44.4 MiB -45465.4 MiB       24951           for neighbor in current.neighbors:
    65     44.4 MiB -40291.3 MiB       22120               if current.row != neighbor.row and current.col != neighbor.col:
    66     44.4 MiB -19980.5 MiB       10972                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     44.4 MiB -20316.3 MiB       11148                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     44.4 MiB -40296.9 MiB       22120               if temp_g_score < g_score[neighbor]:
    71     44.4 MiB  -5505.4 MiB        3070                   came_from[neighbor] = current
    72     44.4 MiB  -5505.4 MiB        3070                   g_score[neighbor] = temp_g_score
    73     44.4 MiB  -5505.4 MiB        3070                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     44.4 MiB  -5505.5 MiB        3070                   if neighbor not in open_set_hash:
    75     44.4 MiB  -5505.5 MiB        3070                       count += 1
    76     44.4 MiB  -5505.5 MiB        3070                       open_set.put((f_score[neighbor], count, neighbor))
    77     44.4 MiB  -5505.5 MiB        3070                       open_set_hash.add(neighbor)
    78                                                             
    79     44.4 MiB  -5170.3 MiB        2831           if draw is not None:
    80                                                     draw()
    81                                         
    82     44.4 MiB  -5170.9 MiB        2831           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     90.6 MiB     90.6 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     90.6 MiB   -629.0 MiB         257       for row in grid:
    30     90.6 MiB -160767.3 MiB       65792           for spot in row:
    31     90.6 MiB -160142.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     83.5 MiB     -7.1 MiB           1       count = 0
    34     83.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     83.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     83.5 MiB      0.0 MiB           1       came_from = {}
    37     87.7 MiB -25079.5 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     87.7 MiB     -0.0 MiB           1       g_score[start] = 0
    39     89.9 MiB -73593.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     87.7 MiB     -2.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     87.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     87.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     87.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     88.0 MiB -324355.7 MiB        6955       while not open_set.empty():
    47     88.0 MiB -324356.5 MiB        6955           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     88.0 MiB -324360.1 MiB        6955           current = open_set.get()[2]
    53     88.0 MiB -324360.9 MiB        6955           open_set_hash.remove(current)
    54                                         
    55     88.0 MiB -324361.8 MiB        6955           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     88.0 MiB -324362.4 MiB        6955           if current == end:
    60     36.6 MiB    -51.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     36.6 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     88.0 MiB -2918929.0 MiB       62586           for neighbor in current.neighbors:
    65     88.0 MiB -2594580.0 MiB       55632               if current.row != neighbor.row and current.col != neighbor.col:
    66     88.0 MiB -1297332.6 MiB       27816                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     88.0 MiB -1297253.8 MiB       27816                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     88.0 MiB -2594598.1 MiB       55632               if temp_g_score < g_score[neighbor]:
    71     88.0 MiB -345686.8 MiB        7511                   came_from[neighbor] = current
    72     88.0 MiB -345687.2 MiB        7511                   g_score[neighbor] = temp_g_score
    73     88.0 MiB -345688.5 MiB        7511                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     88.0 MiB -345689.0 MiB        7511                   if neighbor not in open_set_hash:
    75     88.0 MiB -345689.8 MiB        7511                       count += 1
    76     88.0 MiB -345690.7 MiB        7511                       open_set.put((f_score[neighbor], count, neighbor))
    77     88.0 MiB -345691.3 MiB        7511                       open_set_hash.add(neighbor)
    78                                                             
    79     88.0 MiB -324354.0 MiB        6954           if draw is not None:
    80                                                     draw()
    81                                         
    82     88.0 MiB -324354.5 MiB        6954           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     90.3 MiB     90.3 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     90.3 MiB  -3495.2 MiB         257       for row in grid:
    30     90.3 MiB -890483.0 MiB       65792           for spot in row:
    31     90.3 MiB -887034.1 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     21.0 MiB    -69.2 MiB           1       count = 0
    34     21.4 MiB      0.3 MiB           1       open_set = PriorityQueue()
    35     21.6 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     21.6 MiB      0.0 MiB           1       came_from = {}
    37     33.5 MiB  -5188.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     33.5 MiB      0.0 MiB           1       g_score[start] = 0
    39     39.3 MiB -17681.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     38.7 MiB     -0.6 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     38.7 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     38.7 MiB      0.0 MiB           1       cost_diagonal = 14
    44     38.7 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     50.2 MiB -17863.7 MiB        7176       while not open_set.empty():
    47     50.2 MiB -17863.8 MiB        7176           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     50.2 MiB -17863.8 MiB        7176           current = open_set.get()[2]
    53     50.2 MiB -17864.1 MiB        7176           open_set_hash.remove(current)
    54                                         
    55     50.2 MiB -17868.2 MiB        7176           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     50.2 MiB -17868.4 MiB        7176           if current == end:
    60     32.0 MiB    -18.2 MiB           1               if draw:
    61                                                         end.make_end()
    62     33.6 MiB      1.6 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     50.2 MiB -160706.2 MiB       64575           for neighbor in current.neighbors:
    65     50.2 MiB -142845.5 MiB       57400               if current.row != neighbor.row and current.col != neighbor.col:
    66     50.2 MiB -71437.0 MiB       28700                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     50.2 MiB -71416.1 MiB       28700                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     50.2 MiB -142855.9 MiB       57400               if temp_g_score < g_score[neighbor]:
    71     50.2 MiB -19418.4 MiB        7670                   came_from[neighbor] = current
    72     50.2 MiB -19418.6 MiB        7670                   g_score[neighbor] = temp_g_score
    73     50.2 MiB -19419.3 MiB        7670                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     50.2 MiB -19419.5 MiB        7670                   if neighbor not in open_set_hash:
    75     50.2 MiB -19419.7 MiB        7670                       count += 1
    76     50.2 MiB -19407.1 MiB        7670                       open_set.put((f_score[neighbor], count, neighbor))
    77     50.2 MiB -19415.2 MiB        7670                       open_set_hash.add(neighbor)
    78                                                             
    79     50.2 MiB -17862.7 MiB        7175           if draw is not None:
    80                                                     draw()
    81                                         
    82     50.2 MiB -17863.1 MiB        7175           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     91.4 MiB     91.4 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     91.4 MiB   -241.1 MiB         257       for row in grid:
    30     91.4 MiB -61767.8 MiB       65792           for spot in row:
    31     91.4 MiB -61527.9 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     89.4 MiB     -1.9 MiB           1       count = 0
    34     89.6 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     89.8 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     89.8 MiB      0.0 MiB           1       came_from = {}
    37     92.3 MiB -1601277.4 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     22.7 MiB    -69.6 MiB           1       g_score[start] = 0
    39     30.7 MiB  -2837.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     31.0 MiB      0.3 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     31.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     31.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     31.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     39.5 MiB   -103.5 MiB        2860       while not open_set.empty():
    47     39.5 MiB   -103.5 MiB        2860           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     39.5 MiB   -103.5 MiB        2860           current = open_set.get()[2]
    53     39.5 MiB   -103.5 MiB        2860           open_set_hash.remove(current)
    54                                         
    55     39.5 MiB   -103.5 MiB        2860           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     39.5 MiB   -103.5 MiB        2860           if current == end:
    60     38.0 MiB     -1.4 MiB           1               if draw:
    61                                                         end.make_end()
    62     38.0 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     39.5 MiB   -919.5 MiB       25731           for neighbor in current.neighbors:
    65     39.5 MiB   -814.5 MiB       22872               if current.row != neighbor.row and current.col != neighbor.col:
    66     39.5 MiB   -414.0 MiB       11436                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     39.5 MiB   -406.5 MiB       11436                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     39.5 MiB   -820.1 MiB       22872               if temp_g_score < g_score[neighbor]:
    71     39.5 MiB   -132.3 MiB        3182                   came_from[neighbor] = current
    72     39.5 MiB   -132.6 MiB        3182                   g_score[neighbor] = temp_g_score
    73     39.5 MiB   -132.6 MiB        3182                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     39.5 MiB   -132.6 MiB        3182                   if neighbor not in open_set_hash:
    75     39.5 MiB   -132.6 MiB        3182                       count += 1
    76     39.5 MiB   -132.5 MiB        3182                       open_set.put((f_score[neighbor], count, neighbor))
    77     39.5 MiB   -132.5 MiB        3182                       open_set_hash.add(neighbor)
    78                                                             
    79     39.5 MiB   -103.5 MiB        2859           if draw is not None:
    80                                                     draw()
    81                                         
    82     39.5 MiB   -103.5 MiB        2859           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     93.6 MiB     93.6 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     93.6 MiB  -1689.2 MiB         257       for row in grid:
    30     93.6 MiB -432291.8 MiB       65792           for spot in row:
    31     93.6 MiB -430613.0 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     80.5 MiB    -13.2 MiB           1       count = 0
    34     80.5 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     80.5 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     80.5 MiB      0.0 MiB           1       came_from = {}
    37     84.8 MiB -17185.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     84.8 MiB      0.0 MiB           1       g_score[start] = 0
    39     87.3 MiB -41576.8 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     86.0 MiB     -1.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     86.0 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     86.0 MiB      0.0 MiB           1       cost_diagonal = 14
    44     86.0 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     86.2 MiB -130068.5 MiB        3416       while not open_set.empty():
    47     86.2 MiB -130068.5 MiB        3416           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     86.2 MiB -130068.5 MiB        3416           current = open_set.get()[2]
    53     86.2 MiB -130068.5 MiB        3416           open_set_hash.remove(current)
    54                                         
    55     86.2 MiB -130068.6 MiB        3416           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     86.2 MiB -130068.8 MiB        3416           if current == end:
    60     36.6 MiB    -49.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     36.7 MiB      0.1 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     86.2 MiB -1170380.6 MiB       30735           for neighbor in current.neighbors:
    65     86.2 MiB -1040310.2 MiB       27320               if current.row != neighbor.row and current.col != neighbor.col:
    66     86.2 MiB -520200.0 MiB       13660                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     86.2 MiB -520118.3 MiB       13660                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     86.2 MiB -1040318.8 MiB       27320               if temp_g_score < g_score[neighbor]:
    71     86.2 MiB -140426.2 MiB        3760                   came_from[neighbor] = current
    72     86.2 MiB -140426.3 MiB        3760                   g_score[neighbor] = temp_g_score
    73     86.2 MiB -140447.3 MiB        3760                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     86.2 MiB -140447.3 MiB        3760                   if neighbor not in open_set_hash:
    75     86.2 MiB -140447.3 MiB        3760                       count += 1
    76     86.2 MiB -140447.1 MiB        3760                       open_set.put((f_score[neighbor], count, neighbor))
    77     86.2 MiB -140447.0 MiB        3760                       open_set_hash.add(neighbor)
    78                                                             
    79     86.2 MiB -130068.5 MiB        3415           if draw is not None:
    80                                                     draw()
    81                                         
    82     86.2 MiB -130068.5 MiB        3415           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     89.5 MiB     89.5 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     89.5 MiB  -1018.7 MiB         257       for row in grid:
    30     89.5 MiB -260344.2 MiB       65792           for spot in row:
    31     89.5 MiB -259329.3 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     78.7 MiB    -10.9 MiB           1       count = 0
    34     78.9 MiB      0.2 MiB           1       open_set = PriorityQueue()
    35     79.1 MiB      0.2 MiB           1       open_set.put((0, count, start))
    36     79.1 MiB      0.0 MiB           1       came_from = {}
    37     82.9 MiB -13229.6 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     82.9 MiB      0.0 MiB           1       g_score[start] = 0
    39     88.1 MiB      5.2 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     88.3 MiB      0.1 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     88.3 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     88.3 MiB      0.0 MiB           1       cost_diagonal = 14
    44     88.3 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     88.5 MiB -17563.1 MiB        2407       while not open_set.empty():
    47     88.5 MiB -17563.1 MiB        2407           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     88.5 MiB -17563.1 MiB        2407           current = open_set.get()[2]
    53     88.5 MiB -17563.1 MiB        2407           open_set_hash.remove(current)
    54                                         
    55     88.5 MiB -17563.1 MiB        2407           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     88.5 MiB -17563.1 MiB        2407           if current == end:
    60     45.9 MiB    -42.6 MiB           1               if draw:
    61                                                         end.make_end()
    62     45.9 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     88.5 MiB -157986.0 MiB       21654           for neighbor in current.neighbors:
    65     88.5 MiB -140425.3 MiB       19248               if current.row != neighbor.row and current.col != neighbor.col:
    66     88.5 MiB -70245.3 MiB        9624                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     88.5 MiB -70211.1 MiB        9624                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     88.5 MiB -140458.2 MiB       19248               if temp_g_score < g_score[neighbor]:
    71     88.5 MiB -19768.2 MiB        2687                   came_from[neighbor] = current
    72     88.5 MiB -19768.2 MiB        2687                   g_score[neighbor] = temp_g_score
    73     88.5 MiB -19768.2 MiB        2687                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     88.5 MiB -19768.2 MiB        2687                   if neighbor not in open_set_hash:
    75     88.5 MiB -19768.2 MiB        2687                       count += 1
    76     88.5 MiB -19768.1 MiB        2687                       open_set.put((f_score[neighbor], count, neighbor))
    77     88.5 MiB -19768.1 MiB        2687                       open_set_hash.add(neighbor)
    78                                                             
    79     88.5 MiB -17562.4 MiB        2406           if draw is not None:
    80                                                     draw()
    81                                         
    82     88.5 MiB -17563.1 MiB        2406           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


Filename: /Users/selimhan/Documents/pathfinding-experiment/algorithm.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    26     90.1 MiB     90.1 MiB           1   @profile(stream=open('logs/A*/obstacle_density/30.txt', 'w+'))
    27                                         def algorithm(grid, start, end, draw=None, debug=False):
    28                                             
    29     90.1 MiB  -1138.3 MiB         257       for row in grid:
    30     90.1 MiB -292208.4 MiB       65792           for spot in row:
    31     90.1 MiB -291074.2 MiB       65536               spot.update_neighbors(grid)
    32                                             
    33     85.2 MiB     -4.9 MiB           1       count = 0
    34     85.2 MiB      0.0 MiB           1       open_set = PriorityQueue()
    35     85.2 MiB      0.0 MiB           1       open_set.put((0, count, start))
    36     85.2 MiB      0.0 MiB           1       came_from = {}
    37     88.4 MiB -26432.9 MiB       65795       g_score = {spot: float("inf") for row in grid for spot in row}
    38     88.4 MiB      0.0 MiB           1       g_score[start] = 0
    39     92.5 MiB  -4298.3 MiB       65795       f_score = {spot: float("inf") for row in grid for spot in row}
    40     92.6 MiB      0.2 MiB           1       f_score[start] = h(start.get_pos(), end.get_pos())
    41     92.6 MiB      0.0 MiB           1       open_set_hash = {start}
    42                                         
    43     92.6 MiB      0.0 MiB           1       cost_diagonal = 14
    44     92.6 MiB      0.0 MiB           1       cost_vertical_horizontal = 10
    45                                         
    46     93.2 MiB -108069.2 MiB        4698       while not open_set.empty():
    47     93.2 MiB -108073.2 MiB        4698           if draw: #if there is draw that means algorithm is called when the game is running 
    48                                                     for event in pygame.event.get():
    49                                                         if event.type == pygame.QUIT:
    50                                                             pygame.quit()
    51                                         
    52     93.2 MiB -108074.4 MiB        4698           current = open_set.get()[2]
    53     93.2 MiB -108074.6 MiB        4698           open_set_hash.remove(current)
    54                                         
    55     93.2 MiB -108075.2 MiB        4698           if debug:
    56                                                     if not current.is_blank():
    57                                                         print(current.color)
    58                                                   
    59     93.2 MiB -108076.0 MiB        4698           if current == end:
    60     37.5 MiB    -55.7 MiB           1               if draw:
    61                                                         end.make_end()
    62     37.5 MiB      0.0 MiB           1               return reconstruct_path(came_from, end)
    63                                         
    64     93.2 MiB -972388.7 MiB       42273           for neighbor in current.neighbors:
    65     93.2 MiB -864324.8 MiB       37576               if current.row != neighbor.row and current.col != neighbor.col:
    66     93.2 MiB -432230.1 MiB       18788                   temp_g_score = g_score[current] + cost_diagonal
    67                                                     else:
    68     93.2 MiB -432115.0 MiB       18788                   temp_g_score = g_score[current] + cost_vertical_horizontal
    69                                         
    70     93.2 MiB -864356.3 MiB       37576               if temp_g_score < g_score[neighbor]:
    71     93.2 MiB -114832.1 MiB        5086                   came_from[neighbor] = current
    72     93.2 MiB -114832.7 MiB        5086                   g_score[neighbor] = temp_g_score
    73     93.2 MiB -114835.7 MiB        5086                   f_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())
    74     93.2 MiB -114836.4 MiB        5086                   if neighbor not in open_set_hash:
    75     93.2 MiB -114837.0 MiB        5086                       count += 1
    76     93.2 MiB -114839.4 MiB        5086                       open_set.put((f_score[neighbor], count, neighbor))
    77     93.2 MiB -114839.8 MiB        5086                       open_set_hash.add(neighbor)
    78                                                             
    79     93.2 MiB -108067.9 MiB        4697           if draw is not None:
    80                                                     draw()
    81                                         
    82     93.2 MiB -108068.5 MiB        4697           if current != start and draw:
    83                                                     current.make_closed()
    84                                         
    85                                             print("No path found")
    86                                             return None


